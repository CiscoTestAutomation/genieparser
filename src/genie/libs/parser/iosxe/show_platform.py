''' show_platform.py
IOSXE parsers for the following show commands:

    * 'show bootvar'
    * 'show version'
    * 'dir'
    * 'show redundancy'
    * 'show inventory'
    * 'show platform'
    * 'show platform hardware qfp active feature appqoe stats all'
    * 'show boot'
    * 'show switch detail'
    * 'show switch'
    * 'show environment all'
    * 'show platform software fed switch {switch_type} mpls rlist'
    * 'show platform hardware fed switch active fwd-asic resource tcam utilization'
    * 'show module'
    * 'show platform hardware qfp active datapath utilization summary'
    * 'show platform resources'
    * 'show platform software fed switch active mpls rlist | sect RLIST id:'
    * 'show platform hardware qfp active tcam resource-manager usage'
    * 'show platform software yang-management process'
    * 'show platform software yang-management process monitor'
    * 'show platform software yang-management process state'
    * 'show platform software fed active fnf et-analytics-flows'
    * 'show platform software fed switch active mpls forwarding label {label} detail'
    * 'show platform software fed active mpls forwarding label {label} detail'
    * 'show platform hardware throughput crypto'
    * 'show platform software object-manager {switch} {switch_type} F0 error-object'
    * 'show platform software object-manager {switch} {switch_type} F0 statistics'
    * 'show platform software object-manager {switch} {switch_type} F0 pending-ack-update'
    * 'show platform software fed active inject packet-capture detailed'
    * 'show platform hardware throughput crypto'
    * 'show platform software dpidb index'
    * 'show platform software fed switch active ifm mappings lpn'
    * 'show platform software fed switch active ifm mappings lpn | include {interface}'
    * 'show platform software fed switch active ptp domain'
    * 'show platform software fed switch active ptp interface {interface}'
    * 'show platform software fed active acl usage'
    * 'show platform software fed active acl usage | include {aclName}'
    * 'show platform sudi certificate sign nonce {sig}'
    * 'show environment status'
    * 'show platform hardware fed switch active fwd-asic drops exceptions'
    * 'show platform software fed {switchvirtualstate} mpls lspa all | c {mode}'
    * 'show platform software fed {switchvirtualstate} mpls lspa all'
    * 'show platform software fed {switch} active mpls ipv4 vrf-name {vn_name} {ip_add}'
    * 'show platform software fed active mpls ipv4 vrf-name {vn_name} {ip_add}'
    * 'show platform software interface switch {mode} F0 brief'
    * 'show platform software fed switch {mode} port summary'
    * 'show platform software fed {switchvirtualstate} mpls lspa all | c {mode}'
    * 'show platform software fed {switchvirtualstate} mpls lspa all'
    * 'show platform software dns-umbrella statistics'
    * 'show platform hardware authentication status'
    * 'show platform sudi pki'
    * 'show platform packet-trace statistics'
    * 'show platform packet-trace summary'
    * 'show platform packet-trace all'
    * 'show platform hardware chassis fantray detail switch {mode}'
    * 'show platform hardware chassis power-supply detail switch {mode} all'
    * 'show platform software cpm switch {mode} B0 counters drop'
    * 'show platform software cpm switch {mode} B0 counters punt-inject'
    * 'show platform software cpm switch {mode} B0 ipc brief'
    * 'show platform software cpm switch {mode} B0 ipc detail'
    * 'show platform software install-manager RP active operation history summary'
    * 'show platform software install-manager switch active r0 operation history summary'
    * 'show version running'
    * 'show platform software fed switch active punt cpuq {cpu_q_id}'
    * 'show platform hardware fed switch active fwd-asic resource tcam table pbr record 0 format 0 | begin {nat_region}'
    * 'show platform nat translations active statistics'
    * 'show platform nat translations active'
    * 'show platform hardware fed switch active fwd-asic resource tcam table acl | begin {INPUT_NAT}'
    * 'show platform software object-manager switch {switchstate} {serviceprocessor} active statistics'
    * 'show platform software object-manager FP active statistics'
    * 'show call admission statistics'
    * 'show call admission statistics detailed'
    * 'show platform hardware fed active qos schedule interface {interface}'
    * 'show platform hardware fed active qos schedule interface {sub_interface}'
    * 'show platform software fed switch active ipsec counters if-id all'
    * 'show platform hardware fed active qos queue stats interface {interface}'
    * 'show platform hardware fed switch {state} qos queue stats interface {interface}'
    * 'show platform hardware fed active qos queue label2qmap qmap-egress-data interface {interface}'
    * 'show platform hardware fed switch {state} qos queue label2qmap qmap-egress-data interface {interface}'
    * 'show platform software fed {state} matm macTable vlan {vlan}'
    * 'show platform software fed {state} ip igmp snooping vlan {vlan}'
    * 'show platform software fed {state} ip igmp snooping groups vlan {vlan}'
    * 'show platform software fed {state} ipv6 mld snooping groups vlan {vlan}'
    * 'show platform software fed {state} ipv6 mld snooping vlan {vlan}'
    * 'show platform hardware qfp active infrastructure bqs status | include QOS|QFP'
    * 'show platform hardware qfp active feature qos interface {interface} hierarchy detail | include subdev'
    * 'show platform software bp crimson content config'
    * 'show platform software node cluster-manager switch {mode} B0 node {node}'
    * 'show platform hardware fed switch active fwd resource utilization | include LABEL'
    * 'show file systems'
    * 'show platform software fed {switch} active vt counter'
    * 'show platform software fed switch active vt all '
    * 'show platform hardware qfp active interface all statistics drop_summary'
    * 'show platform software factory-reset secure log'
    * 'show platform hardware qfp active infra punt stat type per | ex _0_'
    * 'show platform hardware qfp active datapath infra sw-cio'
    * 'show platform hardware qfp active datapath infra sw-nic'
    * 'show platform hardware qfp {status} statistics drop clear'
    * 'show platform hardware qfp {status} statistics drop | exclude _0_'
    * 'show platform soft infra bipc | inc buffer'
    * 'show platform hardware fed switch active fwd resource utilization | include LABEL'
    * 'show platform hardware qfp active system state'
    * 'show platform hardware qfp active feature ipsec datapath drops all'
    * 'show platform hardware qfp active datapath pmd ifdev'
    * 'show platform hardware throughput level'
    * 'show platform software wired-client switch {switch_state} r0'
    * 'show platform hardware fed active qos queue config interface'
    * 'show platform hardware fed switch <no> qos queue config interface'
    * 'show platform hardware iomd <slot> qos port <no> ingress queue stats'
    * 'show platform hardware iomd switch <switch_no> <slot> qos port <no> ingress queue stats'
    * 'show platform hardware iomd <slot> portgroups'
    * 'show platform hardware iomd switch <switch_no> <slot> portgroups'
    * 'show platform hardware fed active fwd-asic register read register-name xyz asic n core m'
    * 'show platform hardware fed switch x fwd-asic register read register-name xyz asic n core m'
    * 'show redundancy config-sync failures mcl'
    * 'show platform software fed <state> vp summary interface if_id <if_id>'
    * 'show platform hardware fed switch <state> fwd-asic abstraction print-resource-handle <client_le> 1'
    * 'show platform authentication sbinfo interface {interface}'
    * 'show platform software fed switch <state> ifm if-id <if_id>'
    * 'show platform hardware fed switch active matm macTable'
    * 'show platform usb status'
    * 'show platform software monitor session {session}'
    * 'show platform software fed active vp summary interface if_id {interface_id}'
    * 'show platform software fed {switch} active ifm interfaces vlan'
    * 'show platform software fed active ifm interfaces vlan'
    * 'show platform software fed switch active matm adjacencies vlan {vlan_id}'
    * 'show platform software fed switch active matm adjacencies adjkey {adj_key}'
    * 'show platform software fed switch active matm adjacencies'
    * 'show platform software fed active qos policy target status'
    * 'show platform software fed switch {switch} qos policy target status'
    * 'show platform software fed switch {switch} vp key {if_id} {vlan_id}'
    * 'show platform software install-manager chassis active r0 operation history summary'
    * 'show platform hardware fed switch active qos dscp-cos counters interface {interface}'
    * 'show platform software fed {switch} {mode} qos interface {interface} ingress npd'
    * 'show platform software fed {mode} qos interface {interface} ingress npd'
    * 'show platform software fed {switch} {mode} qos interface {interface} ingress npd detailed'
    * 'show platform software fed {mode} qos interface {interface} ingress npd detailed'
    * 'show platform software fed {switch} {mode} qos interface {interface} egress sdk detailed'
    * 'show platform software fed {mode} qos interface {interface} egress sdk detailed'
    * 'show platform software fed {switch} {mode} qos interface {interface} ingress sdk'
    * 'show platform software fed {mode} qos interface {interface} ingress sdk'
    * 'show platform software fed {switch} {mode} qos interface {interface} ingress sdk detailed'
    * 'show platform software fed {mode} qos interface {interface} ingress sdk detailed'
    * 'show platform software fed active vt hardware if-id {ifid}'
    * 'show platform software fed switch {switch_var} vt hardware if-id {ifid}'
    * 'show platform software fed {switch} active ifm interfaces {label}'
    * 'show platform software fed active ifm interfaces {label}'
    * 'show platform software fed active matm stats'
    * 'show platform software fed switch {mode} matm stats'
    * 'show platform software audit summary'
    * 'show platform software fed {switch} {mode} qos interface {interface} ingress npi detailed'
    * 'show platform software fed {mode} qos interface {interface} ingress npi detailed'
    * 'show platform software fed active ptp domain'
    * 'show platform hardware fed active qos queue stats oq multicast attach'
    * 'show platform hardware fed switch {switch_num} qos queue stats oq multicast attach'
    * 'show platform software fed {switch} {mode} security-fed ipsg if-id {if_id}'
    * 'show platform software fed {mode} security-fed ipsg if-id {if_id}'
    * 'show xfsu status'
    * 'show graceful-reload'
    '''

# Python
import re
import logging
from collections import OrderedDict
import xml.etree.ElementTree as ET
from xml.dom import minidom

# Metaparser
from genie.metaparser import MetaParser
from genie.metaparser.util.schemaengine import Schema, Any, Or, Optional, Use, And
from genie.libs.parser.utils.common import Common
from genie.parsergen import oper_fill_tabular
# genie.parsergen
try:
    import genie.parsergen
except (ImportError, OSError):
    pass

# pyATS
from pyats.utils.exceptions import SchemaTypeError

log = logging.getLogger(__name__)

class ShowBootvarSchema(MetaParser):
    """Schema for show bootvar"""

    schema = {
        Optional('current_boot_variable'): str,
        Optional('next_reload_boot_variable'): str,
        Optional('config_file'): str,
        Optional('bootldr'): str,
        Optional('active'): {
            Optional('configuration_register'): str,
            Optional("next_reload_configuration_register"): str,
            Optional('boot_variable'): str,
            Optional('manual_boot'): bool,
        },
        Optional('standby'): {
            Optional('configuration_register'): str,
            Optional("next_reload_configuration_register"): str,
            Optional('boot_variable'): str,
            Optional('standby_manual_boot'): bool,
        },
    }


class ShowBootvar(ShowBootvarSchema):
    """Parser for show bootvar"""

    cli_command = 'show bootvar'

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        boot_dict = {}
        boot_variable = None

        # BOOT variable = bootflash:/asr1000rpx.bin,12;
        # BOOT variable = flash:cat3k_caa-universalk9.BLD_POLARIS_DEV_LATEST_20150907_031219.bin;flash:cat3k_caa-universalk9.BLD_POLARIS_DEV_LATEST_20150828_174328.SSA.bin;flash:ISSUCleanGolden;
        # BOOT variable = tftp:/auto/tftp-best/genie_images/genie_clean/asr1000-genie-image 255.255.255.255,12;
        # BOOT variable = tftp:/auto/tftp-best/genie_images/genie_clean/asr1000-genie-image 255.255.255.255,12;harddisk:/asr1000-genie-image_asr-MIB-1,12;
        p1 = re.compile(r'^BOOT +variable +=( *(?P<var>\S+);?)?$')

        # Standby BOOT variable = bootflash:/asr1000rpx.bin,12;
        p2 = re.compile(r'^Standby +BOOT +variable +=( *(?P<var>\S+);)?$')

        # Configuration register is 0x2002
        # Configuration register is 0x2 (will be 0x2102 at next reload)
        # Configuration Register is 0x102
        p3 = re.compile(r'Configuration +[R|r]egister +is +(?P<var1>(\S+))'
                        r'(?: +\(will +be +(?P<var2>(\S+)) +at +next +reload\))?$')

        # Standby Configuration register is 0x2002
        # Standby Configuration register is 0x1  (will be 0x2102 at next reload)
        p4 = re.compile(r'^Standby +Configuration +register +is +(?P<var>\w+)'
                        r'(?: +\(will +be +(?P<var2>\S+) +at +next +reload\))?$')

        # CONFIG_FILE variable =
        p5 = re.compile(r'^CONFIG_FILE +variable += +(?P<var>\S+)$')

        # BOOTLDR variable =
        p6 = re.compile(r'^BOOTLDR +variable += +(?P<var>\S+)$')

        # BOOTLDR variable does not exist
        # not parsing

        # Standby not ready to show bootvar
        # not parsing
        # MANUAL_BOOT variable = no
        p7 = re.compile(r'(^MANUAL_BOOT\s*variable)\s*=\s*(?P<manual_boot>\w+)$')

        # Standby MANUAL_BOOT variable = no
        p8 = re.compile(r'(^Standby\s*MANUAL_BOOT\s*variable)\s*=\s*(?P<standby_manual_boot>\w+)$')

        for line in out.splitlines():
            line = line.strip()
            # BOOT variable = disk0:s72033-adventerprisek9-mz.122-33.SRE0a-ssr-nxos-76k-1,12;
            m = p1.match(line)
            if m:
                boot = m.groupdict()['var']
                if boot:
                    boot_dict['next_reload_boot_variable'] = boot
                    boot_dict.setdefault('active', {})['boot_variable'] = boot
                continue

            # Standby BOOT variable = bootflash:/asr1000rpx.bin,12;
            m = p2.match(line)
            if m:
                boot = m.groupdict()['var']
                if boot:
                    boot_dict.setdefault('standby', {})['boot_variable'] = boot
                continue

            # Configuration register is 0x2002
            m = p3.match(line)
            if m:
                boot_dict.setdefault('active', {})['configuration_register'] = m.groupdict()['var1']
                if m.groupdict()['var2']:
                    boot_dict.setdefault('active', {})['next_reload_configuration_register'] = m.groupdict()['var2']
                continue

            # Standby Configuration register is 0x2002
            m = p4.match(line)
            if m:
                boot_dict.setdefault('standby', {})['configuration_register'] = m.groupdict()['var']
                if m.groupdict()['var2']:
                    boot_dict.setdefault('standby', {})['next_reload_configuration_register'] = m.groupdict()['var2']
                continue

            # CONFIG_FILE variable =
            m = p5.match(line)
            if m:
                if m.groupdict()['var']:
                    boot_dict.update({'config_file': m.groupdict()['var']})
                continue

            # BOOTLDR variable =
            m = p6.match(line)
            if m:
                if m.groupdict()['var']:
                    boot_dict.setdefault('standby', {})['bootldr'] = m.groupdict()['var']
                continue

            # MANUAL_BOOT variable = no
            m = p7.match(line)
            if m:
                if m.groupdict()['manual_boot'].lower() == 'yes':
                    boot_dict.setdefault('active', {})['manual_boot'] = True
                else:
                    boot_dict.setdefault('active', {})['manual_boot'] = False
                continue

            # Standby MANUAL_BOOT variable = yes
            m = p8.match(line)
            if m:
                if m.groupdict()['standby_manual_boot'].lower() == 'yes':
                    boot_dict.setdefault(
                        'standby', {})['standby_manual_boot'] = True
                else:
                    boot_dict.setdefault(
                        'standby', {})['standby_manual_boot'] = False
                continue

        return boot_dict


class ShowVersionSchema(MetaParser):
    """Schema for show version"""
    schema = {
        'version': {
            Optional('xe_version'): str,
            'version_short': str,
            'platform': str,
            'version': str,
            Optional('label'): str,
            Optional('build_label'): str,
            'image_id': str,
            'rom': str,
            'image_type': str,
            Optional('installation_mode'): str,
            Optional('bootldr'): str,
            'hostname': str,
            'uptime': str,
            Optional('uptime_this_cp'): str,
            Optional('jawa_revision'): str,
            Optional('snowtrooper_revision'): str,
            Optional('running_default_software'): bool,
            Optional('processor_board_flash'): str,
            Optional('last_reload_type'): str,
            Optional('returned_to_rom_by'):  str,
            Optional('returned_to_rom_at'): str,
            Optional('compiled_date'): str,
            Optional('location'): str,
            Optional('copyright_years'): str,
            Optional('sp_by'): str,
            Optional('compiled_by'): str,
            Optional('system_restarted_at'): str,
            Optional('system_image'): str,
            Optional('last_reload_reason'): str,
            Optional('license_type'): str,
            Optional('license_level'): str,
            Optional('next_reload_license_level'): str,
            Optional('air_license_level'): str,
            Optional('next_reload_air_license_level'): str,
            Optional('chassis'): str,
            Optional('processor_type'): str,
            Optional('chassis_sn'): str,
            Optional('rtr_type'): str,
            Optional('router_operating_mode'): str,
            'os': str,
            Optional('curr_config_register'): str,
            Optional('license_udi'): {
                Optional('device_num'): {
                    Any(): {
                        'pid': str,
                        'sn': str,
                    }
                },
            },
            Optional('next_config_register'): str,
            Optional('main_mem'): str,
            Optional('number_of_intfs'): {
                Any(): str,
            },
            Optional('mem_size'): {
                Any(): str,
            },
            Optional('disks'): {
                Any(): {
                    Optional('disk_size'): str,
                    Optional('type_of_disk'): str,
                }
            },
            Optional('switch_num'): {
                Any(): {
                    Optional('uptime'): str,
                    Optional('mac_address'): str,
                    Optional('mb_assembly_num'): str,
                    Optional('power_supply_part_nr'): str,
                    Optional('mb_sn'): str,
                    Optional('power_supply_sn'): str,
                    Optional('model_rev_num'): str,
                    Optional('mb_rev_num'): str,
                    Optional('model_num'): str,
                    Optional('db_assembly_num'): str,
                    Optional('db_sn'): str,
                    Optional('system_sn'): str,
                    Optional('top_assembly_part_num'): str,
                    Optional('top_assembly_rev_num'): str,
                    Optional('system_fpga_version'): str,
                    Optional('version_id'): str,
                    Optional('clei_code_num'): str,
                    Optional('db_rev_num'): str,
                    Optional('hb_rev_num'): str,
                    Optional('mode'): str,
                    Optional('model'): str,
                    Optional('sw_image'): str,
                    Optional('ports'): str,
                    Optional('sw_ver'): str,
                    Optional('active'): bool,
                }
            },
            Optional('processor'): {
                Optional('cpu_type'): str,
                Optional('speed'): str,
                Optional('core'): str,
                Optional('l2_cache'): str,
                Optional('supervisor'): str,
            },
            Optional('license_package'): {
                Any(): {
                    'license_level': str,
                    'license_type': str,
                    'next_reload_license_level': str,
                },
            },
            Optional('module'): {
                Any(): {
                    Any(): {
                        Optional('suite'): str,
                        Optional('suite_current'): str,
                        Optional('type'): str,
                        Optional('suite_next_reboot'): str,
                    },
                },
            },
            Optional('image'): {
                'text_base': str,
                'data_base': str,
            },
            Optional('interfaces'): {
                Optional('virtual_ethernet'): int,
                Optional('fastethernet'): int,
                Optional('gigabit_ethernet'): int,
            },
            Optional('revision'): {
                Any(): int,
            }
        }
    }


class ShowVersion(ShowVersionSchema):
    """Parser for show version
    parser class - implements detail parsing mechanisms for cli output.
    """
    # *************************
    # schema - class variable
    #
    # Purpose is to make sure the parser always return the output
    # (nested dict) that has the same data structure across all supported
    # parsing mechanisms (cli(), yang(), xml()).

    cli_command = 'show version'
    exclude = ['system_restarted_at', 'uptime_this_cp', 'uptime']

    def cli(self, output=None):
        """parsing mechanism: cli

        Function cli() defines the cli type output parsing mechanism which
        typically contains 3 steps: exe
        cuting, transforming, returning
        """
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        version_dict = {}
        active_dict = {}
        rtr_type = ''
        suite_flag = False
        license_flag = False

        # Cisco IOS XE Software, Version BLD_POLARIS_DEV_LATEST_20200702_122021_V17_4_0_67_2
        p0 = re.compile(
            r'^Cisco +([\S\s]+) +Software, +Version +(?P<xe_version>.*)$')

        # version
        # Cisco IOS Software [Everest], ISR Software (X86_64_LINUX_IOSD-UNIVERSALK9-M), Version 16.6.5, RELEASE SOFTWARE (fc3)
        # Cisco IOS Software, IOS-XE Software, Catalyst 4500 L3 Switch Software (cat4500e-UNIVERSALK9-M), Version 03.03.02.SG RELEASE SOFTWARE (fc1)
        p1 = re.compile(r'^[Cc]isco +IOS +[Ss]oftware\, +(?P<os>([\S]+)) +Software\, '
                        r'+(?P<platform>.+) Software +\((?P<image_id>.+)\).+[Vv]ersion '
                        r'+(?P<version>\S+) +.*$')

        # IOS (tm) Catalyst 4000 L3 Switch Software (cat4000-I9S-M), Version 12.2(18)EW5, RELEASE SOFTWARE (fc1)
        # IOS (tm) s72033_rp Software (s72033_rp-ADVENTERPRISEK9_WAN-M), Version 12.2(18)SXF7, RELEASE SOFTWARE (fc1)
        p1_1 = re.compile(r'^(?P<os>[A-Z]+) +\(.*\) +(?P<platform>.+) +Software'
                          r' +\((?P<image_id>.+)\).+( +Experimental)? +[Vv]ersion'
                          r' +(?P<version>\S+), +RELEASE SOFTWARE .*$')

        # 16.6.5
        p2 = re.compile(r'^(?P<ver_short>\d+\.\d+).*')

        # Cisco IOS Software [Fuji], ASR1000 Software (X86_64_LINUX_IOSD-UNIVERSALK9-M), Version 16.7.1prd4, RELEASE SOFTWARE (fc1)
        # Cisco IOS Software [Fuji], Catalyst L3 Switch Software (CAT3K_CAA-UNIVERSALK9-M), Experimental Version 16.8.20170924:182909 [polaris_dev-/nobackup/mcpre/BLD-BLD_POLARIS_DEV_LATEST_20170924_191550 132]
        # Cisco IOS Software, 901 Software (ASR901-UNIVERSALK9-M), Version 15.6(2)SP4, RELEASE SOFTWARE (fc3)
        # Cisco IOS Software [Amsterdam], Catalyst L3 Switch Software (CAT9K_IOSXE), Experimental Version 17.4.20200702:124009 [S2C-build-polaris_dev-116872-/nobackup/mcpre/BLD-BLD_POLARIS_DEV_LATEST_20200702_122021 243]
        # Cisco IOS Software [Denali], ASR1000 Software (X86_64_LINUX_IOSD-UNIVERSALK9-M), Experimental Version 16.3.20170410:103306 [v163_mr_throttle-BLD-BLD_V163_MR_THROTTLE_LATEST_20170410_093453 118]
        p3 = re.compile(r'^[Cc]isco +(?P<os>[A-Z]+) +[Ss]oftware\s*\[?(?P<location>\w*)?\]?\, '
                        r'+(?P<platform>.+) +Software +\((?P<image_id>.+)\).+( '
                        r'+Experimental)? +[Vv]ersion '
                        r'+(?P<version>[\w.:()]+) *,? *'
                        r'(?P<label>(\[.+?(?P<build_label>BLD_\w+)(-\S+)? \d+\])|.*)$')

        # Copyright (c) 1986-2016 by Cisco Systems, Inc.
        p4 = re.compile(r'^Copyright +\(c\) +(?P<copyright_years>\d+-\d+).*$')

        # Technical Support: http://www.cisco.com/techsupport
        p5 = re.compile(r'^Technical +Support: +http\:\/\/www'
                        r'\.cisco\.com\/techsupport')

        # rom
        p6 = re.compile(r'^ROM\: +(?P<rom>.+)$')

        # ROM: Bootstrap program is IOSv
        p7 = re.compile(r'^Bootstrap +program +is +(?P<os>.+)$')

        # bootldr
        p8 = re.compile(r'^BOOTLDR\: +(?P<bootldr>.+)$')

        # hostname & uptime
        p9 = re.compile(r'^(?P<hostname>.+) +uptime +is +(?P<uptime>.+)$')

        # uptime_this_cp
        p10 = re.compile(r'^[Uu]ptime +for +this +control +processor '
                         r'+is +(?P<uptime_this_cp>.+)$')

        # system_restarted_at
        p11 = re.compile(r'^[Ss]ystem +restarted +at '
                         r'+(?P<system_restarted_at>.+)$')

        # system_image
        # System image file is "tftp://10.1.6.241//auto/genie-ftp/Edison/cat3k_caa-universalk9.BLD__20170410_174845.SSA.bin"
        # System image file is "harddisk:test-image-PE1-13113029"
        p12 = re.compile(r'^[Ss]ystem +image +file +is '
                         r'+\"(?P<system_image>.+)\"')

        # last_reload_reason
        p13 = re.compile(r'^[Ll]ast +reload +reason\: '
                         r'+(?P<last_reload_reason>.+)$')

        # last_reload_reason
        # Last reset from power-on
        p14 = re.compile(r'^[Ll]ast +reset +from +(?P<last_reload_reason>.+)$')

        # license_type
        p15 = re.compile(r'^[Ll]icense +[Tt]ype\: +(?P<license_type>.+)$')

        # license_level
        p16 = re.compile(r'^\s*[Ll]icense +[Ll]evel\: +(?P<license_level>.+)$')

        # entservices   Type: Permanent
        p16_1 = re.compile(r'(?P<license_level>\S+) +Type\: +(?P<license_type>.+)$')

        # AIR License Level: AIR DNA Advantage
        p16_2 = re.compile(r'^\s*AIR [Ll]icense +[Ll]evel\: +(?P<air_license_level>.+)$')

        ## Technology Package License Information:
        ## Technology-package                                     Technology-package
        # Current                        Type                       Next reboot
        p16_3 = re.compile(r'^Current  +Type  +Next reboot')

        # network-advantage     Smart License                    network-advantage
        # dna-advantage         Subscription Smart License       dna-advantage
        p16_4 = re.compile(r'^(?P<license_package>[\w-]+)(?:\s{2,})(?P<package_license_type>(\w+ )+)(?:\s{2,})(?P<next_reload_license_level>\S+)\s*$')

        # next_reload_license_level
        p17 = re.compile(r'^[Nn]ext +(reload|reboot) +license +Level\: '
                         r'+(?P<next_reload_license_level>.+)$')

        # Next reload AIR license Level: AIR DNA Advantage
        p17_1 = re.compile(r'^[Nn]ext +(reload|reboot) +AIR license +Level\: '
                           r'+(?P<next_reload_air_license_level>.+)$')

        # chassis, processor_type, main_mem and rtr_type
        # cisco WS-C3650-24PD (MIPS) processor (revision H0) with 829481K/6147K bytes of memory.
        # cisco CSR1000V (VXE) processor (revision VXE) with 1987991K/3075K bytes of memory.
        # cisco C1111-4P (1RU) processor with 1453955K/6147K bytes of memory.
        # Cisco IOSv (revision 1.0) with  with 435457K/87040K bytes of memory.
        # cisco WS-C3750X-24P (PowerPC405) processor (revision W0) with 262144K bytes of memory.
        # cisco ISR4451-X/K9 (2RU) processor with 1795979K/6147K bytes of memory.
        # cisco WS-C4507R+E (MPC8572) processor (revision 10) with 2097152K/20480K bytes of memory.
        # Cisco CISCO1941/K9 (revision 1.0) with 491520K/32768K bytes of memory.
        p18 = re.compile(r'^(C|c)isco +(?P<chassis>[a-zA-Z0-9\-\/\+]+) '
                         r'+\((?P<processor_type>[^)]*)\) +(.*?)with '
                         r'+(?P<main_mem>[0-9]+)[kK](\/[0-9]+[kK])?')

        # Cisco CISCO3945-CHASSIS (revision 1.0) with C3900-SPE150/K9 with 1835264K/261888K bytes of memory.
        p18_2 = re.compile(r'^(C|c)isco +(?P<chassis>[a-zA-Z0-9\-\/\+]+) +.* '
                           r'+with +(?P<processor_type>.+) +with +(?P<main_mem>[0-9]+)[kK](\/[0-9]+[kK])?')

        # Allen-Bradley 1783-CMS10DP (ARM) processor (revision V00) with 634958K/6147K bytes of memory.
        p18_3 = re.compile(r'^(A|a)llen-Bradley +(?P<chassis>[a-zA-Z0-9\-\/\+]+) '
                         r'+\((?P<processor_type>[^)]*)\) +(.*?)with '
                         r'+(?P<main_mem>[0-9]+)[kK](\/[0-9]+[kK])?')

        # chassis_sn
        p19 = re.compile(r'^[pP]rocessor +board +ID '
                         r'+(?P<chassis_sn>[a-zA-Z0-9]+)')

        # number_of_intfs
        p20 = re.compile(r'^(?P<number_of_ports>\d+) +(?P<interface>.+) '
                         r'+(interface(?:s)?|line|port(?:s)?)$')

        # mem_size
        p21 = re.compile(r'^(?P<mem_size>\d+)K +bytes +of '
                         r'+(?P<memories>.+) +[Mm]emory\.')

        # disks, disk_size and type_of_disk
        p22 = re.compile(r'^(?P<disk_size>\d+)K bytes of '
                         r'(?P<type_of_disk>.*) at (?P<disks>.+)$')

        # os
        # Cisco IOS Software,
        p23 = re.compile(r'^[Cc]isco +(?P<os>[a-zA-Z\-]+) '
                         r'+[Ss]oftware\,')

        # curr_config_register
        p24 = re.compile(r'^[Cc]onfiguration +register +is '
                         r'+(?P<curr_config_register>[a-zA-Z0-9]+)')

        # next_config_register
        p25 = re.compile(r'^[Cc]onfiguration +register +is +[a-zA-Z0-9]+ '
                         r'+\(will be (?P<next_config_register>[a-zA-Z0-9]+) '
                         r'at next reload\)')

        # switch_number
        p26 = re.compile(r'^[Ss]witch +0(?P<switch_number>\d+)$')

        # uptime
        p27 = re.compile(r'^[Ss]witch +[Uu]ptime +\: +(?P<uptime>.+)$')

        # mac_address
        p28 = re.compile(r'^[Bb]ase +[Ee]thernet +MAC +[Aa]ddress '
                         r'+\: +(?P<mac_address>.+)$')

        # mb_assembly_num
        p29 = re.compile(r'^[Mm]otherboard +[Aa]ssembly +[Nn]umber +\: '
                         r'+(?P<mb_assembly_num>.+)$')

        # mb_sn
        p30 = re.compile(r'^[Mm]otherboard +[Ss]erial +[Nn]umber +\: '
                         r'+(?P<mb_sn>.+)$')

        # model_rev_num
        p31 = re.compile(r'^[Mm]odel +[Rr]evision +[Nn]umber +\: '
                         r'+(?P<model_rev_num>.+)$')

        # mb_rev_num
        p32 = re.compile(r'^[Mm]otherboard +[Rr]evision +[Nn]umber +\: '
                         r'+(?P<mb_rev_num>.+)$')

        # model_num
        p33 = re.compile(r'^[Mm]odel +[Nn]umber +\: +(?P<model_num>.+)$')

        # system_sn
        p34 = re.compile(r'^[Ss]ystem +[Ss]erial +[Nn]umber +\: +(?P<system_sn>.+)$')

        # Compiled Mon 10-Apr-17 04:35 by mcpre
        # Compiled Mon 19-Mar-18 16:39 by prod_rel_team
        p36 = re.compile(r'^Compiled +(?P<compiled_date>[\S\s]+) +by '
                         r'+(?P<compiled_by>\w+)$')

        # System returned to ROM by reload at 15:57:52 CDT Mon Sep 24 2018
        # System returned to ROM by Reload Command at 07:15:43 UTC Fri Feb 1 2019
        # System returned to ROM by reload
        # System returned to ROM by power cycle at 23:31:24 PDT Thu Sep 27 2007 (SP by power on)
        # System returned to ROM by power-on
        p37 = re.compile(r'^System +returned +to +ROM +by '
                         r'+(?P<returned_to_rom_by>[\w\s\-]+)(?: +at '
                         r'+(?P<returned_to_rom_at>[\w\s\:]+))?(?: +\(SP +by '
                         r'+(?P<sp_by>[\S\s\-]+)\))?$')

        # Last reload type: Normal Reload
        p38 = re.compile(
            r'^Last +reload +type\: +(?P<last_reload_type>[\S ]+)$')

        # P2020 CPU at 800MHz, E500v2 core, 512KB L2 Cache
        p39 = re.compile(r'^(?P<cpu_name>\S+) +(CPU|cpu|Cpu) +at '
                         r'+(?P<speed>\S+)\,(( +(?P<core>\S+) +core\, '
                         r'+(?P<l2_cache>\S+) +L2 +[Cc]ache)|( +Supervisor '
                         r'+(?P<supervisor>\S+)))$')

        # 98304K bytes of processor board System flash (Read/Write)
        p40 = re.compile(r'^(?P<processor_board_flash>\S+) +bytes .+$')

        # Running default software
        p41 = re.compile(r'^Running +(?P<running_default_software>\S+) +software$')

        # Jawa Revision 7, Snowtrooper Revision 0x0.0x1C
        p42 = re.compile(r'^Jawa +Revision +(?P<jawa_revision>\S+)\, '
                         r'+Snowtrooper +Revision +(?P<snowtrooper_rev>\S+)$')

        # ipbase           ipbasek9         Smart License    ipbasek9
        # securityk9       securityk9       RightToUse       securityk9
        p43 = re.compile(r'^(?P<technology>\w[\w\-]+)(?: {2,}'
                         r'(?P<license_level>\w+) {2,}(?P<license_type>\w+(?: '
                         r'+\w+)?) {2,}(?P<next_boot>\w+))?$')

        # Suite                 Suite Current         Type           Suite Next reboot
        # Technology    Technology-package           Technology-package
        p44 = re.compile(r'^(?P<aname>Suite|Technology) +((Suite +Current)|'
                         r'(Technology\-package))')

        # Suite License Information for Module:'esg'
        p45 = re.compile(r'^[Ss]uite +[Ll]icense +[Ii]nformation +for '
                         r'+[Mm]odule\:\'(?P<module>\S+)\'$')

        # License UDI:
        p46_0 = re.compile(r'^License UDI:$')

        #     *0        C3900-SPE150/K9       FOC16050QP6
        p46 = re.compile(r'^(?P<device_num>[*\d]+) +(?P<pid>[\S]+) +(?P<sn>[A-Z\d]+)$')

        # Image text-base: 0x40101040, data-base: 0x42D98000
        p47 = re.compile(r'^Image text-base: +(?P<text_base>\S+), '
                         r'data-base: +(?P<data_base>\S+)$')

        # 1 Virtual Ethernet/IEEE 802.3 interface(s)
        # 50 Gigabit Ethernet/IEEE 802.3 interface(s)
        p48 = re.compile(r'^(?P<interface>\d+) +(?P<ethernet_type>Virtual Ethernet|Gigabit Ethernet|FastEthernet)'
                         r'/IEEE 802\.3 +interface\(s\)$')

        # Dagobah Revision 95, Swamp Revision 6
        p50 = re.compile(r'^(?P<group1>\S+)\s+Revision\s+(?P<group1_int>\d+),'
                         r'\s+(?P<group2>\S+)\s+Revision\s+(?P<group2_int>\d+)$')

        # power_supply_part_nr
        # Power supply part number: 444-8888-00
        p51 = re.compile(r'^[Pp]ower\s+[Ss]upply\s+[Pp]art\s+[Nn]umber\s+\:\s+(?P<power_supply_part_nr>.+)$')

        # power_supply_sn
        # Power supply serial number: CCC4466B6LL
        p52 = re.compile(r'^[Pp]ower\s+[Ss]upply\s+[Ss]erial\s+[Nn]umber\s+\:\s+(?P<power_supply_sn>.+)$')

        # Daughterboard assembly number   : 73-11111-00
        # db_assembly_num
        p53 = re.compile(r'^[Dd]aughterboard\s+[Aa]ssembly\s+[Nn]umber\s+\:\s+(?P<db_assembly_num>.+)$')

        # Daughterboard serial number     : FOC87654CWW
        # db_sn
        p54 = re.compile(r'^[Dd]aughterboard\s+[Ss]erial\s+[Nn]umber\s+\:\s+(?P<db_sn>.+)$')

        # top_assembly_part_num
        # Top Assembly Part Number        : 800-55555-11
        p55 = re.compile(r'^[Tt]op\s+[Aa]ssembly\s+[Pp]art\s+[Nn]umber\s+\:\s+(?P<top_assembly_part_num>.+)$')

        # top_assembly_rev_num
        # Top Assembly Revision Number    : C0
        p56 = re.compile(r'^[Tt]op\s+[Aa]ssembly\s+[Rr]evision\s+[Nn]umber\s+\:\s+(?P<top_assembly_rev_num>.+)$')

        # version_id
        # Version ID                      : V02
        p57 = re.compile(r'^[Vv]ersion\s+ID\s+\:\s+(?P<version_id>.+)$')

        # clei_code_num
        # CLEI Code Number                : AAALJ00ERT
        p58 = re.compile(r'^CLEI\s+[Cc]ode\s+[Nn]umber\s+\:\s+(?P<clei_code_num>.+)$')

        # Daughterboard revision number   : A0
        # db_rev_num
        p59 = re.compile(r'^[Dd]aughterboard\s+[Rr]evision\s+[Nn]umber\s+\:\s+(?P<db_rev_num>.+)$')

        # Hardware Board Revision Number  : 0x12
        # hb_rev_num
        p60 = re.compile(r'^[Hh]ardware\s+[Bb]oard\s+[Rr]evision\s+[Nn]umber\s+\:\s+(?P<hb_rev_num>.+)$')

        # Router operating mode: Controller-Managed
        p61 = re.compile(r'^Router operating mode: (?P<router_operating_mode>.+)$')

        # Installation mode is BUNDLE
        p62 = re.compile(r'^Installation\s+mode\s+is\s+(?P<installation_mode>.+)$')

        #System FPGA version                : 0.2.11
        p63 = re.compile('^System FPGA version\s+:\s+(?P<system_fpga_version>(\d+\.?)+)')

        for line in out.splitlines():
            line = line.strip()

            # Cisco IOS XE Software, Version BLD_POLARIS_DEV_LATEST_20200702_122021_V17_4_0_67_2
            m = p0.match(line)
            if m:
                if 'version' not in version_dict:
                    version_dict['version'] = {}
                xe_version = m.groupdict()['xe_version']
                version_dict['version']['xe_version'] = xe_version
                continue

            # version
            # Cisco IOS Software [Everest], ISR Software (X86_64_LINUX_IOSD-UNIVERSALK9-M), Version 16.6.5, RELEASE SOFTWARE (fc3)
            # Cisco IOS Software, IOS-XE Software, Catalyst 4500 L3 Switch Software (cat4500e-UNIVERSALK9-M), Version 03.03.02.SG RELEASE SOFTWARE (fc1)
            # IOS (tm) Catalyst 4000 L3 Switch Software (cat4000-I9S-M), Version 12.2(18)EW5, RELEASE SOFTWARE (fc1)
            # IOS (tm) s72033_rp Software (s72033_rp-ADVENTERPRISEK9_WAN-M), Version 12.2(18)SXF7, RELEASE SOFTWARE (fc1)
            m = p1.match(line) or p1_1.match(line)
            if m:
                version = m.groupdict()['version']
                # 16.6.5
                m2 = p2.match(version)
                if m2:
                    if 'version' not in version_dict:
                        version_dict['version'] = {}
                    version_dict['version']['version_short'] = \
                        m2.groupdict()['ver_short']
                    version_dict['version']['platform'] = \
                        m.groupdict()['platform'].strip()
                    version_dict['version']['version'] = \
                        m.groupdict()['version']
                    version_dict['version']['image_id'] = \
                        m.groupdict()['image_id']
                    version_dict['version']['os'] = m.groupdict()['os']
                    continue

            # Cisco IOS Software [Fuji], ASR1000 Software (X86_64_LINUX_IOSD-UNIVERSALK9-M), Version 16.7.1prd4, RELEASE SOFTWARE (fc1)
            # Cisco IOS Software [Fuji], Catalyst L3 Switch Software (CAT3K_CAA-UNIVERSALK9-M), Experimental Version 16.8.20170924:182909 [polaris_dev-/nobackup/mcpre/BLD-BLD_POLARIS_DEV_LATEST_20170924_191550 132]
            # Cisco IOS Software, 901 Software (ASR901-UNIVERSALK9-M), Version 15.6(2)SP4, RELEASE SOFTWARE (fc3)
            # Cisco IOS Software [Amsterdam], Catalyst L3 Switch Software (CAT9K_IOSXE), Experimental Version 17.4.20200702:124009 [S2C-build-polaris_dev-116872-/nobackup/mcpre/BLD-BLD_POLARIS_DEV_LATEST_20200702_122021 243]
            # Cisco IOS Software [Denali], ASR1000 Software (X86_64_LINUX_IOSD-UNIVERSALK9-M), Experimental Version 16.3.20170410:103306 [v163_mr_throttle-BLD-BLD_V163_MR_THROTTLE_LATEST_20170410_093453 118]
            m = p3.match(line)
            if m:
                version = m.groupdict()['version']
                # 16.6.5

                m2 = p2.match(version)

                if m2:
                    if 'version' not in version_dict:
                        version_dict['version'] = {}
                    version_dict['version']['version_short'] = \
                        m2.groupdict()['ver_short']
                    version_dict['version']['platform'] = \
                        m.groupdict()['platform']
                    version_dict['version']['version'] = \
                        m.groupdict()['version']
                    version_dict['version']['image_id'] = \
                        m.groupdict()['image_id']
                    if m.groupdict()['label']:
                        version_dict['version']['label'] = \
                            m.groupdict()['label']
                    if m.groupdict()['build_label']:
                        version_dict['version']['build_label'] = \
                            m.groupdict()['build_label']
                    if m.groupdict()['os']:
                        version_dict['version']['os'] = m.groupdict()['os']
                    if m.groupdict()['location']:
                        version_dict['version']['location'] = m.groupdict()['location']
                    continue

            # Copyright (c) 1986-2016 by Cisco Systems, Inc.
            m = p4.match(line)
            if m:
                version_dict.setdefault('version', {}).setdefault('image_type', 'developer image')
                version_dict.setdefault('version', {}).setdefault('copyright_years', m.groupdict()['copyright_years'])
                continue

            # Technical Support: http://www.cisco.com/techsupport
            m = p5.match(line)
            if m:
                version_dict.setdefault('version', {}).setdefault('image_type', 'production image')
                continue

            # rom
            m = p6.match(line)
            if m:
                rom = m.groupdict()['rom']
                version_dict['version']['rom'] = rom

                # ROM: Bootstrap program is IOSv
                m = p7.match(rom)
                if m:
                    if 'os' not in version_dict['version']:
                        version_dict['version']['os'] = \
                            m.groupdict()['os']
                continue

            # bootldr
            m = p8.match(line)
            if m:
                version_dict['version']['bootldr'] = \
                    m.groupdict()['bootldr']
                continue

            # hostname & uptime
            m = p9.match(line)
            if m:
                version_dict['version']['hostname'] = \
                    m.groupdict()['hostname']
                version_dict['version']['uptime'] = \
                    m.groupdict()['uptime']
                continue

            # uptime_this_cp
            m = p10.match(line)
            if m:
                version_dict['version']['uptime_this_cp'] = \
                    m.groupdict()['uptime_this_cp']
                uptime_this_cp = m.groupdict()['uptime_this_cp']
                continue

            # system_restarted_at
            m = p11.match(line)
            if m:
                version_dict['version']['system_restarted_at'] = \
                    m.groupdict()['system_restarted_at']
                continue

            # system_image
            # System image file is "tftp://10.1.6.241//auto/tftp-ssr/Edison/cat3k_caa-universalk9.BLD_V164_THROTTLE_LATEST_20170410_174845.SSA.bin"
            # System image file is "harddisk:test-image-PE1-13113029"
            m = p12.match(line)
            if m:
                version_dict['version']['system_image'] = \
                    m.groupdict()['system_image']
                continue

            # last_reload_reason
            m = p13.match(line)
            if m:
                version_dict['version']['last_reload_reason'] = \
                    m.groupdict()['last_reload_reason']
                continue

            # last_reload_reason
            # Last reset from power-on
            m = p14.match(line)
            if m:
                version_dict['version']['last_reload_reason'] = \
                    m.groupdict()['last_reload_reason']
                continue

            # license_type
            m = p15.match(line)
            if m:
                version_dict['version']['license_type'] = \
                    m.groupdict()['license_type']
                continue

            # license_level
            # License Level: entservices   Type: Permanent
            # License Level: AdvancedMetroIPAccess
            m = p16.match(line)
            if m:
                group = m.groupdict()
                if 'Type:' in group['license_level']:
                    lic_type = group['license_level'].strip()
                    m_1 = p16_1.match(lic_type)
                    if m_1:
                        lic_group = m_1.groupdict()
                        version_dict['version']['license_type'] = lic_group['license_type']
                        version_dict['version']['license_level'] = lic_group['license_level']
                else:
                    version_dict['version']['license_level'] = group['license_level']
                continue

            # AIR License Level: AIR DNA Advantage
            m = p16_2.match(line)
            if m:
                version_dict['version']['air_license_level'] = m.groupdict()['air_license_level']
                continue

            # Current                        Type                       Next reboot
            m = p16_3.match(line)
            if m:
                version_dict['version'].setdefault('license_package', {})
                continue

            # network-advantage     Smart License                    network-advantage
            # dna-advantage         Subscription Smart License       dna-advantage
            m = p16_4.match(line)
            if m:
                group = m.groupdict()
                license_package = group['license_package']
                version_dict['version'].setdefault('license_package', {})
                version_dict['version']['license_package'][license_package] = {
                    'license_level': license_package,
                    'license_type': group['package_license_type'].strip(),
                    'next_reload_license_level': group['next_reload_license_level']
                }
                continue

            # next_reload_license_level
            # Next reboot license Level: entservices
            # Next reload license Level: advipservices
            m = p17.match(line)
            if m:
                version_dict['version']['next_reload_license_level'] = \
                    m.groupdict()['next_reload_license_level']
                continue

            # Next reload AIR license Level: AIR DNA Advantage
            m = p17_1.match(line)
            if m:
                version_dict['version']['next_reload_air_license_level'] = \
                    m.groupdict()['next_reload_air_license_level']

            # chassis, processor_type, main_mem and rtr_type
            # cisco WS-C3650-24PD (MIPS) processor (revision H0) with 829481K/6147K bytes of memory.
            # cisco CSR1000V (VXE) processor (revision VXE) with 1987991K/3075K bytes of memory.
            # cisco C1111-4P (1RU) processor with 1453955K/6147K bytes of memory.
            # Cisco IOSv (revision 1.0) with  with 435457K/87040K bytes of memory.
            # cisco WS-C3750X-24P (PowerPC405) processor (revision W0) with 262144K bytes of memory.
            # cisco ISR4451-X/K9 (2RU) processor with 1795979K/6147K bytes of memory.
            m = p18.match(line)

            # Cisco CISCO3945-CHASSIS (revision 1.0) with C3900-SPE150/K9 with 1835264K/261888K bytes of memory.
            m2 = p18_2.match(line)

            m3 = p18_3.match(line)

            if m or m2 or m3:
                if m:
                    group = m.groupdict()
                elif m2:
                    group = m2.groupdict()
                elif m3:
                    group = m3.groupdict()

                version_dict['version']['chassis'] = group['chassis']
                version_dict['version']['main_mem'] = group['main_mem']
                version_dict['version']['processor_type'] = group['processor_type']

                if 'C3850' in version_dict['version']['chassis'] or \
                   'C3650' in version_dict['version']['chassis']:
                    version_dict['version']['rtr_type'] = rtr_type = 'Edison'
                elif 'ASR1' in version_dict['version']['chassis']:
                    version_dict['version']['rtr_type'] = rtr_type = 'ASR1K'
                elif 'CSR1000V' in version_dict['version']['chassis']:
                    version_dict['version']['rtr_type'] = rtr_type = 'CSR1000V'
                elif 'C11' in version_dict['version']['chassis']:
                    version_dict['version']['rtr_type'] = rtr_type = 'ISR'
                else:
                    version_dict['version']['rtr_type'] = rtr_type = version_dict['version']['chassis']
                continue

            # Router operating mode: Controller-Managed
            m = p61.match(line)
            if m:
                version_dict['version']['router_operating_mode'] = m.groupdict()['router_operating_mode']
                continue

            # Installation mode is BUNDLE
            m = p62.match(line)
            if m:
                version_dict['version']['installation_mode'] = m.groupdict()['installation_mode']
                continue

            # chassis_sn
            m = p19.match(line)
            if m:
                version_dict['version']['chassis_sn'] \
                    = m.groupdict()['chassis_sn']
                continue

            # number_of_intfs
            # 1 External Alarm interface
            # 1 FastEthernet interface
            # 12 Gigabit Ethernet interfaces
            # 2 Ten Gigabit Ethernet interfaces
            # 1 terminal line
            # 8 Channelized T1 ports
            m = p20.match(line)
            if m:
                interface = m.groupdict()['interface']
                if 'number_of_intfs' not in version_dict['version']:
                    version_dict['version']['number_of_intfs'] = {}
                version_dict['version']['number_of_intfs'][interface] = \
                    m.groupdict()['number_of_ports']
                continue

            # mem_size
            m = p21.match(line)
            if m:
                memories = m.groupdict()['memories']
                if 'mem_size' not in version_dict['version']:
                    version_dict['version']['mem_size'] = {}
                version_dict['version']['mem_size'][memories] = \
                    m.groupdict()['mem_size']
                continue

            # disks, disk_size and type_of_disk
            m = p22.match(line)
            if m:
                disks = m.groupdict()['disks']
                if 'disks' not in version_dict['version']:
                    version_dict['version']['disks'] = {}
                if disks not in version_dict['version']['disks']:
                    version_dict['version']['disks'][disks] = {}
                version_dict['version']['disks'][disks]['disk_size'] = \
                    m.groupdict()['disk_size']
                version_dict['version']['disks'][disks]['type_of_disk'] = \
                    m.groupdict()['type_of_disk']
                continue

            # os
            m = p23.match(line)
            if m:
                version_dict['version']['os'] = m.groupdict()['os']

                continue

            # curr_config_register
            m = p24.match(line)
            if m:
                version_dict['version']['curr_config_register'] \
                    = m.groupdict()['curr_config_register']

            # next_config_register
            m = p25.match(line)
            if m:
                version_dict['version']['next_config_register'] \
                    = m.groupdict()['next_config_register']
                continue

            # switch_number
            m = p26.match(line)
            if m:
                switch_number = m.groupdict()['switch_number']

                if 'switch_num' not in version_dict['version']:
                    version_dict['version']['switch_num'] = {}
                if switch_number not in version_dict['version']['switch_num']:
                    version_dict['version']['switch_num'][switch_number] = {}

                continue

            # uptime
            m = p27.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    continue
                version_dict['version']['switch_num'][switch_number]['uptime'] = m.groupdict()['uptime']
                continue

            # mac_address
            m = p28.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('mac_address', m.groupdict()['mac_address'])
                    continue
                version_dict['version']['switch_num'][switch_number]['mac_address'] = m.groupdict()['mac_address']
                continue

            # mb_assembly_num
            m = p29.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('mb_assembly_num', m.groupdict()['mb_assembly_num'])
                    continue
                version_dict['version']['switch_num'][switch_number]['mb_assembly_num'] = m.groupdict()['mb_assembly_num']
                continue

            # mb_sn
            m = p30.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('mb_sn', m.groupdict()['mb_sn'])
                    continue
                version_dict['version']['switch_num'][switch_number]['mb_sn'] = m.groupdict()['mb_sn']
                continue

            # model_rev_num
            m = p31.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('model_rev_num', m.groupdict()['model_rev_num'])
                    continue
                version_dict['version']['switch_num'][switch_number]['model_rev_num'] = m.groupdict()['model_rev_num']
                continue

            # mb_rev_num
            m = p32.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('mb_rev_num', m.groupdict()['mb_rev_num'])
                    continue
                version_dict['version']['switch_num'][switch_number]['mb_rev_num'] = m.groupdict()['mb_rev_num']
                continue

            # model_num
            m = p33.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('model_num', m.groupdict()['model_num'])
                    continue
                version_dict['version']['switch_num'][switch_number]['model_num'] = m.groupdict()['model_num']
                continue

            # system_sn
            m = p34.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('system_sn', m.groupdict()['system_sn'])
                    continue
                version_dict['version']['switch_num'][switch_number]['system_sn'] = m.groupdict()['system_sn']
                continue

            # power_supply_part_nr
            m = p51.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('power_supply_part_nr', m.groupdict()['power_supply_part_nr'])
                    continue
                version_dict['version']['switch_num'][switch_number]['power_supply_part_nr'] = m.groupdict()['power_supply_part_nr']
                continue

            # power_supply_sn
            m = p52.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('power_supply_sn', m.groupdict()['power_supply_sn'])
                    continue
                version_dict['version']['switch_num'][switch_number]['power_supply_sn'] = m.groupdict()['power_supply_sn']
                continue

            # db_assembly_num
            m = p53.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('db_assembly_num', m.groupdict()['db_assembly_num'])
                    continue
                version_dict['version']['switch_num'][switch_number]['db_assembly_num'] = m.groupdict()['db_assembly_num']
                continue

            # db_sn
            m = p54.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('db_sn', m.groupdict()['db_sn'])
                    continue
                version_dict['version']['switch_num'][switch_number]['db_sn'] = m.groupdict()['db_sn']
                continue

            # top_assembly_part_num
            m = p55.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('top_assembly_part_num', m.groupdict()['top_assembly_part_num'])
                    continue
                version_dict['version']['switch_num'][switch_number]['top_assembly_part_num'] = m.groupdict()['top_assembly_part_num']
                continue

            # top_assembly_rev_num
            m = p56.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('top_assembly_rev_num', m.groupdict()['top_assembly_rev_num'])
                    continue
                version_dict['version']['switch_num'][switch_number]['top_assembly_rev_num'] = m.groupdict()['top_assembly_rev_num']
                continue

            # version_id
            m = p57.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('version_id', m.groupdict()['version_id'])
                    continue
                version_dict['version']['switch_num'][switch_number]['version_id'] = m.groupdict()['version_id']
                continue

            # clei_code_num
            m = p58.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('clei_code_num', m.groupdict()['clei_code_num'])
                    continue
                version_dict['version']['switch_num'][switch_number]['clei_code_num'] = m.groupdict()['clei_code_num']
                continue

            # db_rev_num
            m = p59.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('db_rev_num', m.groupdict()['db_rev_num'])
                    continue
                version_dict['version']['switch_num'][switch_number]['db_rev_num'] = m.groupdict()['db_rev_num']
                continue

            # hb_rev_num
            m = p60.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('hb_rev_num', m.groupdict()['hb_rev_num'])
                    continue
                version_dict['version']['switch_num'][switch_number]['hb_rev_num'] = m.groupdict()['hb_rev_num']
                continue

            # Compiled Mon 10-Apr-17 04:35 by mcpre
            # Compiled Mon 19-Mar-18 16:39 by prod_rel_team
            m36 = p36.match(line)
            if m36:
                group = m36.groupdict()
                version_dict['version']['compiled_date'] = group['compiled_date']
                version_dict['version']['compiled_by'] = group['compiled_by']

                continue

            # System returned to ROM by reload at 15:57:52 CDT Mon Sep 24 2018
            # System returned to ROM by Reload Command at 07:15:43 UTC Fri Feb 1 2019
            # System returned to ROM by reload
            # System returned to ROM by power cycle at 23:31:24 PDT Thu Sep 27 2007 (SP by power on)
            # System returned to ROM by power-on
            m37 = p37.match(line)
            if m37:
                group = m37.groupdict()

                if group['returned_to_rom_at']:
                    version_dict['version']['returned_to_rom_by'] = group['returned_to_rom_by']
                    version_dict['version']['returned_to_rom_at'] = group['returned_to_rom_at']
                else:
                    version_dict['version']['returned_to_rom_by'] = group['returned_to_rom_by']

                if group['sp_by']:
                    version_dict['version']['sp_by'] = group['sp_by']

                continue

            # Last reload type: Normal Reload
            m38 = p38.match(line)
            if m38:
                version_dict['version']['last_reload_type'] = m38.groupdict()['last_reload_type']

                continue

            # P2020 CPU at 800MHz, E500v2 core, 512KB L2 Cache
            # MPC8572 CPU at 1.5GHz, Supervisor 7
            m39 = p39.match(line)
            if m39:
                group = m39.groupdict()
                cpu_dict = version_dict['version'].setdefault('processor', {})
                if group['supervisor']:
                    cpu_dict['cpu_type'] = group['cpu_name']
                    cpu_dict['speed'] = group['speed']
                    cpu_dict['supervisor'] = group['supervisor']
                else:
                    cpu_dict['cpu_type'] = group['cpu_name']
                    cpu_dict['speed'] = group['speed']
                    cpu_dict['core'] = group['core']
                    cpu_dict['l2_cache'] = group['l2_cache']

                continue

            # 98304K bytes of processor board System flash (Read/Write)
            m40 = p40.match(line)
            if m40:
                flash_dict = version_dict['version']
                in_kb = m40.groupdict()['processor_board_flash']
                flash_dict['processor_board_flash'] = in_kb

                continue

            # Running default software
            m41 = p41.match(line)
            if m41:
                version_dict['version']['running_default_software'] = True

                continue

            # Jawa Revision 7, Snowtrooper Revision 0x0.0x1C
            m42 = p42.match(line)
            if m42:
                version_dict['version']['jawa_revision'] = m42.groupdict()['jawa_revision']
                version_dict['version']['snowtrooper_revision'] = m42.groupdict()['snowtrooper_rev']

                continue

            # ipbase           ipbasek9         Smart License    ipbasek9
            # securityk9       securityk9       RightToUse       securityk9
            m43 = p43.match(line)
            if m43:
                group = m43.groupdict()

                if license_flag:
                    lic_initial_dict = version_dict['version'].setdefault('license_package', {})
                    license_dict = lic_initial_dict.setdefault(group['technology'], {})

                    if group['license_type']:
                        license_dict.update({'license_type': group['license_type']})

                    if group['license_level']:
                        license_dict.update({'license_level': group['license_level']})

                    if group['next_boot']:
                        license_dict.update({'next_reload_license_level': group['next_boot']})

                if suite_flag:
                    suite_lic_dict = suite_dict.setdefault(group['technology'], {})

                    if group['license_level']:
                        suite_lic_dict.update({'suite_current': group['license_level']})

                    if group['license_type']:
                        suite_lic_dict.update({'type': group['license_type'].strip()})

                    if group['next_boot']:
                        suite_lic_dict.update({'suite_next_reboot': group['next_boot']})

                continue

            # Suite                 Suite Current         Type           Suite Next reboot
            # Technology    Technology-package           Technology-package
            m44 = p44.match(line)
            if m44:
                if 'Suite' in m44.groupdict()['aname']:
                    suite_flag = True

                if 'Technology' in m44.groupdict()['aname']:
                    license_flag = True
                    suite_flag = False

                continue

            # Suite License Information for Module:'esg'
            m45 = p45.match(line)
            if m45:
                module_dict = version_dict['version'].setdefault('module', {})
                suite_dict = module_dict.setdefault(m45.groupdict()['module'], {})

                continue

            # License UDI:
            m46_0 = p46_0.match(line)
            if m46_0:
                if 'license_udi' not in version_dict:
                    license_udi_dict = version_dict['version'].setdefault('license_udi', {})
                continue

            # *0        C3900-SPE150/K9       FOC16050QP6
            m46 = p46.match(line)
            if m46:
                group = m46.groupdict()
                license_udi_sub = license_udi_dict.setdefault('device_num', {}).\
                    setdefault(group['device_num'], {})
                license_udi_sub['pid'] = group['pid']
                license_udi_sub['sn'] = group['sn']
                continue

            # Image text-base: 0x40101040, data-base: 0x42D98000
            m = p47.match(line)
            if m:
                version_dict['version']['image'] = {}
                version_dict['version']['image']['text_base'] = m.groupdict()['text_base']
                version_dict['version']['image']['data_base'] = m.groupdict()['data_base']
                continue

            # 1 Virtual Ethernet/IEEE 802.3 interface(s)
            # 50 Gigabit Ethernet/IEEE 802.3 interface(s)
            m = p48.match(line)
            if m:
                group = m.groupdict()
                ethernet_type = '_'.join(group['ethernet_type'].lower().split())

                if 'interfaces' not in version_dict['version']:
                    version_dict['version']['interfaces'] = {}
                version_dict['version']['interfaces'][ethernet_type] = \
                    int(group['interface'])
                continue

            # Dagobah Revision 95, Swamp Revision 6
            m = p50.match(line)
            if m:
                groupdict = m.groupdict()
                version_dict['version']['revision'] = {}
                version_dict['version']['revision'][groupdict['group1']] = int(groupdict['group1_int'])
                version_dict['version']['revision'][groupdict['group2']] = int(groupdict['group2_int'])
                continue

            m = p63.match(line)
            if m:
                if 'switch_num' not in version_dict['version']:
                    active_dict.setdefault('system_fpga_version', m.groupdict()['system_fpga_version'])
                    continue
                version_dict['version']['switch_num'][switch_number]['system_fpga_version'] = m.groupdict()['system_fpga_version']
                continue

        # table2 for C3850
        tmp2 = genie.parsergen.oper_fill_tabular(right_justified=True,
                                                 header_fields=["Switch",
                                                                "Ports",
                                                                "Model             ",
                                                                'SW Version       ',
                                                                "SW Image              ",
                                                                "Mode   "],
                                                 label_fields=["switch_num",
                                                               "ports",
                                                               "model",
                                                               "sw_ver",
                                                               'sw_image',
                                                               'mode'],
                                                 index=[0, ],
                                                 table_terminal_pattern=r"(^\n|^\s*$)",
                                                 device_output=out,
                                                 device_os='iosxe')

        if not tmp2.entries:
            # table2 for IOS
            tmp2 = genie.parsergen.oper_fill_tabular(right_justified=True,
                                                     header_fields=["Switch",
                                                                    "Ports",
                                                                    "Model             ",
                                                                    'SW Version       ',
                                                                    "SW Image              "],
                                                     label_fields=["switch_num",
                                                                   "ports",
                                                                   "model",
                                                                   "sw_ver",
                                                                   'sw_image'],
                                                     index=[0, ],
                                                     table_terminal_pattern=r"(^\n|^\s*$)",
                                                     device_output=out,
                                                     device_os='ios')

        if tmp2.entries:
            res2 = tmp2
            for key in res2.entries.keys():
                if 'switch_num' not in version_dict['version']:
                    version_dict['version']['switch_num'] = {}
                if '*' in key:
                    p = re.compile(r'\**\ *(?P<new_key>\d)')
                    m = p.match(key)
                    switch_no = m.groupdict()['new_key']
                    if m:
                        if switch_no not in version_dict['version']['switch_num']:
                            version_dict['version']['switch_num'][switch_no] = {}
                        for k, v in res2.entries[key].items():
                            if 'switch_num' != k:
                                version_dict['version']['switch_num'][switch_no][k] = v

                        if 'uptime_this_cp' in locals():
                            version_dict['version']['switch_num'][switch_no]['uptime'] = uptime_this_cp

                        version_dict['version']['switch_num'][switch_no]['active'] = True
                        version_dict['version']['switch_num'][switch_no].\
                            update(active_dict) if active_dict else None
                else:
                    for k, v in res2.entries[key].items():
                        if key not in version_dict['version']['switch_num']:
                            version_dict['version']['switch_num'][key] = {}
                        if 'switch_num' != k:
                            version_dict['version']['switch_num'][key][k] = v
                    version_dict['version']['switch_num'][key]['active'] = False

        elif active_dict:
            # Insert active switch into first free switch number
            used_switch_nums = version_dict.get('version', {}).get('switch_num', {}).keys()
            used_switch_nums = [int(x) for x in used_switch_nums]

            for num in range(1, len(used_switch_nums) + 2):
                if num not in used_switch_nums:
                    active_switch = version_dict.setdefault('version', {}).\
                        setdefault('switch_num', {}).setdefault(str(num), {})
                    active_switch.update(active_dict)
                    break

        # Backward compatibility for license_level and license_type
        if len(version_dict['version'].get('license_package', '')) == 1:
            k = list(version_dict['version']['license_package'].keys())[0]
            lic_info = version_dict['version']['license_package'][k]
            version_dict['version'].setdefault('license_level', lic_info.get('license_level'))
            version_dict['version'].setdefault('license_type', lic_info.get('license_type'))
            version_dict['version'].setdefault('next_reload_license_level', lic_info.get('next_reload_license_level'))

        return version_dict


class DirSchema(MetaParser):
    """Schema for dir"""
    schema = {
        'dir': {
            'dir': str,
            Any(): {
                Optional('files'): {
                    Any(): {
                        Optional('index'): str,
                        Optional('permissions'): str,
                        'size': str,
                        Optional('last_modified_date'): str
                    }
                },
                Optional('bytes_total'): str,
                Optional('bytes_free'): str
            }
        }
    }


class Dir(DirSchema):
    """Parser for dir
    parser class - implements detail parsing mechanisms for cli output.
    """
    # *************************
    # schema - class variable
    #
    # Purpose is to make sure the parser always return the output
    # (nested dict) that has the same data structure across all supported
    # parsing mechanisms (cli(), yang(), xml()).
    cli_command = ['dir', 'dir {directory}']
    exclude = ['last_modified_date', 'bytes_free', 'files']

    def cli(self, directory='', output=None):
        """parsing mechanism: cli

        Function cli() defines the cli type output parsing mechanism which
        typically contains 3 steps: exe
        cuting, transforming, returning
        """
        if output is None:
            if directory:
                out = self.device.execute(
                    self.cli_command[1].format(directory=directory))
            else:
                out = self.device.execute(self.cli_command[0])
        else:
            out = output

        dir_dict = {}
        for line in out.splitlines():
            line = line.rstrip()

            # dir
            p1 = re.compile(
                r'^\s*[Dd]irectory +of +(?P<dir>.+)$')
            m = p1.match(line)
            if m:
                dir1 = m.groupdict()['dir']
                if 'dir' not in dir_dict:
                    dir_dict['dir'] = {}
                if dir1 not in dir_dict['dir']:
                    dir_dict['dir'][dir1] = {}
                    dir_dict['dir']['dir'] = dir1
                continue

            # filename, index, permissions, size and last_modified_date
            p2 = re.compile(
                r'\s*(?P<index>\d+) +(?P<permissions>\S+) +(?P<size>\d+) +(?P<last_modified_date>\S+ +\d+ +\d+ +\d+\:\d+\:\d+ +\S+) +(?P<filename>.+)$')
            m = p2.match(line)
            if m:
                filename = m.groupdict()['filename']
                if 'files' not in dir_dict['dir'][dir1]:
                    dir_dict['dir'][dir1]['files'] = {}
                if filename not in dir_dict['dir'][dir1]['files']:
                    dir_dict['dir'][dir1]['files'][filename] = {}
                dir_dict['dir'][dir1]['files'][filename]['index'] = m.groupdict()['index']
                dir_dict['dir'][dir1]['files'][filename]['permissions'] = m.groupdict()['permissions']
                dir_dict['dir'][dir1]['files'][filename]['size'] = m.groupdict()['size']
                dir_dict['dir'][dir1]['files'][filename]['last_modified_date'] = m.groupdict()['last_modified_date']
                continue

            # bytes_total and bytes_free
            p3 = re.compile(r'\s*(?P<bytes_total>\d+) +bytes +total +\((?P<bytes_free>\d+) +bytes +free\)')
            m = p3.match(line)
            if m:
                dir_dict['dir'][dir1]['bytes_total'] = m.groupdict()['bytes_total']
                dir_dict['dir'][dir1]['bytes_free'] = m.groupdict()['bytes_free']
                continue

        return dir_dict


class ShowRedundancySchema(MetaParser):
    """Schema for show redundancy """
    schema = {
        'red_sys_info': {
            'available_system_uptime': str,
            'switchovers_system_experienced': str,
            'standby_failures': str,
            'last_switchover_reason': str,
            'hw_mode': str,
            'conf_red_mode': str,
            'oper_red_mode': str,
            'maint_mode': str,
            'communications': str,
            Optional('communications_reason'): str,
        },
        'slot': {
            Any(): {
                'curr_sw_state': str,
                'uptime_in_curr_state': str,
                'image_ver': str,
                Optional('boot'): str,
                Optional('config_file'): str,
                Optional('bootldr'): str,
                Optional('config_register'): str,
            }
        }
    }


class ShowRedundancy(ShowRedundancySchema):
    """Parser for show redundancy
    parser class - implements detail parsing mechanisms for cli output.
    """
    # *************************
    # schema - class variable
    #
    # Purpose is to make sure the parser always return the output
    # (nested dict) that has the same data structure across all supported
    # parsing mechanisms (cli(), yang(), xml()).

    cli_command = 'show redundancy'
    exclude = ['available_system_uptime', 'uptime_in_curr_state']

    def cli(self, output=None):
        """parsing mechanism: cli

        Function cli() defines the cli type output parsing mechanism which
        typically contains 3 steps: exe
        cuting, transforming, returning
        """
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        redundancy_dict = {}
        for line in out.splitlines():
            line = line.rstrip()

            # available_system_uptime
            p1 = re.compile(r'\s*[Aa]vailable +[Ss]ystem +[Uu]ptime +\= +(?P<available_system_uptime>.+)$')
            m = p1.match(line)
            if m:
                redundancy_dict.setdefault('red_sys_info', {})
                redundancy_dict['red_sys_info']['available_system_uptime'] = \
                    m.groupdict()['available_system_uptime']
                continue

            # switchovers_system_experienced
            p2 = re.compile(r'\s*[Ss]witchovers +system +experienced +\= +(?P<switchovers_system_experienced>\d+)$')
            m = p2.match(line)
            if m:
                redundancy_dict['red_sys_info']['switchovers_system_experienced'] = \
                    m.groupdict()['switchovers_system_experienced']
                continue

            # standby_failures
            p3 = re.compile(r'\s*[Ss]tandby +failures +\= +(?P<standby_failures>\d+)$')
            m = p3.match(line)
            if m:
                redundancy_dict['red_sys_info']['standby_failures'] = \
                    m.groupdict()['standby_failures']
                continue

            # last_switchover_reason
            p4 = re.compile(r'^\s*[Ll]ast +[Ss]witchover +[Rr]eason +\= +(?P<last_switchover_reason>.+)$')
            m = p4.match(line)
            if m:
                redundancy_dict['red_sys_info']['last_switchover_reason'] = \
                    m.groupdict()['last_switchover_reason']
                continue

            # hw_mode
            p5 = re.compile(r'\s*[Hh]ardware +[Mm]ode +\= +(?P<hw_mode>\S+)$')
            m = p5.match(line)
            if m:
                redundancy_dict['red_sys_info']['hw_mode'] = \
                    m.groupdict()['hw_mode']
                continue

            # conf_red_mode
            p6 = re.compile(r'\s*[Cc]onfigured +[Rr]edundancy +[Mm]ode +\= +(?P<conf_red_mode>[\s\S]+)$')
            m = p6.match(line)
            if m:
                redundancy_dict['red_sys_info']['conf_red_mode'] = \
                    m.groupdict()['conf_red_mode']
                continue

            # oper_red_mode
            p7 = re.compile(r'\s*[Oo]perating +[Rr]edundancy +[Mm]ode +\= +(?P<oper_red_mode>.+)$')
            m = p7.match(line)
            if m:
                redundancy_dict['red_sys_info']['oper_red_mode'] = \
                    m.groupdict()['oper_red_mode']
                continue

            # maint_mode
            p7 = re.compile(r'\s*[Mm]aintenance +[Mm]ode +\= +(?P<maint_mode>\S+)$')
            m = p7.match(line)
            if m:
                redundancy_dict['red_sys_info']['maint_mode'] = \
                    m.groupdict()['maint_mode']
                continue

            # communications
            p8 = re.compile(r'^\s*[Cc]ommunications +\= +(?P<communications>\S+)$')
            m = p8.match(line)
            if m:
                redundancy_dict['red_sys_info']['communications'] = \
                    m.groupdict()['communications']

            # communications_reason
            p8 = re.compile(r'^\s*[Cc]ommunications +\= +(?P<communications>\S+)\s+[Rr]eason\: +(?P<communications_reason>.+)$')
            m = p8.match(line)
            if m:
                redundancy_dict['red_sys_info']['communications'] = \
                    m.groupdict()['communications']
                redundancy_dict['red_sys_info']['communications_reason'] = \
                    m.groupdict()['communications_reason']
                continue

            # slot number
            p9 = re.compile(r'^\s*\S+ +[Ll]ocation +\= +(?P<slot>.+)$')
            m = p9.match(line)
            if m:
                slot = m.groupdict()['slot']
                if 'slot' not in redundancy_dict:
                    redundancy_dict['slot'] = {}
                if slot not in redundancy_dict['slot']:
                    redundancy_dict['slot'][slot] = {}
                continue

            # curr_sw_state
            p10 = re.compile(r'^\s*[Cc]urrent +[Ss]oftware +[Ss]tate +\= +(?P<curr_sw_state>.+)$')
            m = p10.match(line)
            if m:
                if 'slot' in redundancy_dict:
                    redundancy_dict['slot'][slot]['curr_sw_state'] = \
                        m.groupdict()['curr_sw_state']
                continue

            # uptime_in_curr_state
            p11 = re.compile(r'^\s*[Uu]ptime +[Ii]n +[Cc]urrent +[Ss]tate +\= +(?P<uptime_in_curr_state>.+)$')
            m = p11.match(line)
            if m:
                if 'slot' in redundancy_dict:
                    redundancy_dict['slot'][slot]['uptime_in_curr_state'] = \
                        m.groupdict()['uptime_in_curr_state']
                continue

            # image_ver
            p12 = re.compile(r'^\s*[Ii]mage +[Vv]ersion +\= +(?P<image_ver>.+)$')
            m = p12.match(line)
            if m:
                if 'slot' in redundancy_dict:
                    redundancy_dict['slot'][slot]['image_ver'] = \
                        m.groupdict()['image_ver']
                continue

            # boot
            p13 = re.compile(r'^\s*BOOT +\= +(?P<boot>.+)$')
            m = p13.match(line)
            if m:
                if 'slot' in redundancy_dict:
                    redundancy_dict['slot'][slot]['boot'] = \
                        m.groupdict()['boot']
                continue

            # config_file
            p14 = re.compile(r'\s*CONFIG_FILE +\= +(?P<config_file>.?)$')
            m = p14.match(line)
            if m:
                if 'slot' in redundancy_dict:
                    redundancy_dict['slot'][slot]['config_file'] = \
                        m.groupdict()['config_file']
                continue

            # bootldr
            p15 = re.compile(r'\s*BOOTLDR +\= +(?P<bootldr>.?)$')
            m = p15.match(line)
            if m:
                if 'slot' in redundancy_dict:
                    redundancy_dict['slot'][slot]['bootldr'] = \
                        m.groupdict()['bootldr']
                continue

            # config_register
            p16 = re.compile(r'^\s*[Cc]onfiguration +[Rr]egister = (?P<config_register>.+)$')
            m = p16.match(line)
            if m:
                if 'slot' in redundancy_dict:
                    redundancy_dict['slot'][slot]['config_register'] = \
                        m.groupdict()['config_register']
                continue

        return redundancy_dict


class ShowRedundancyStatesSchema(MetaParser):
    """Schema for show redundancy states """
    schema = {
        'my_state': str,
        'peer_state': str,
        'mode': str,
        Optional('unit'): str,
        'unit_id': int,
        'redundancy_mode_operational': str,
        'redundancy_mode_configured': str,
        'redundancy_state': str,
        Optional('maintenance_mode'): str,
        'manual_swact': str,
        Optional('manual_swact_reason'): str,
        'communications': str,
        Optional('communications_reason'): str,
        'client_count': int,
        'client_notification_tmr_msec': int,
        'rf_debug_mask': str,
    }


class ShowRedundancyStates(ShowRedundancyStatesSchema):
    """ Parser for show redundancy states """

    cli_command = 'show redundancy states'

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        # initial variables
        ret_dict = {}

        # my state = 13 -ACTIVE
        p1 = re.compile(r'^my +state += +(?P<my_state>[\s\S]+)$')

        # peer state = 8  -STANDBY HOT
        p2 = re.compile(r'^peer +state += +(?P<peer_state>[\s\S]+)$')

        # Mode = Duplex
        p3 = re.compile(r'^Mode += +(?P<mode>[\w]+)$')

        # Unit = Primary
        p4 = re.compile(r'^Unit += +(?P<unit>[\w]+)$')

        # Unit ID = 48
        p5 = re.compile(r'^Unit +ID += +(?P<unit_id>[\d]+)$')

        # Redundancy Mode (Operational) = sso
        p6 = re.compile(r'^Redundancy +Mode +\(Operational\) += +'
                        '(?P<redundancy_mode_operational>[\s\S]+)$')

        # Redundancy Mode (Configured)  = sso
        p7 = re.compile(r'^Redundancy +Mode +\(Configured\) += +'
                        '(?P<redundancy_mode_configured>[\s\S]+)$')

        # Redundancy State              = sso
        p8 = re.compile(r'^Redundancy +State += +(?P<redundancy_state>[\s\S]+)$')

        # Maintenance Mode = Disabled
        p9 = re.compile(r'^Maintenance +Mode += +(?P<maintenance_mode>[\w]+)$')

        # Manual Swact = enabled
        # Manual Swact = disabled (system is simplex (no peer unit))
        p10 = re.compile(r'^Manual +Swact += +(?P<manual_swact>[\w]+)'
                         '( +\((?P<manual_swact_reason>.*)\))?$')

        # Communications = Up
        # Communications = Down      Reason: Simplex mode
        p11 = re.compile(r'^Communications += +(?P<communications>[\w]+)'
                         '( +Reason: +(?P<communications_reason>[\s\S]+))?$')

        # client count = 76
        p12 = re.compile(r'^client +count += +(?P<client_count>[\d]+)$')

        # client_notification_TMR = 30000 milliseconds
        p13 = re.compile(r'^client_notification_TMR += +'
                         '(?P<client_notification_tmr_msec>[\d]+) +milliseconds$')

        # RF debug mask = 0x0
        p14 = re.compile(r'^RF +debug +mask += +(?P<rf_debug_mask>[\w]+)$')

        for line in out.splitlines():
            line = line.strip()
            if not line:
                continue

            # my state = 13 -ACTIVE
            m = p1.match(line)
            if m:
                ret_dict['my_state'] = m.groupdict()['my_state']
                continue

            # peer state = 1  -DISABLED
            m = p2.match(line)
            if m:
                ret_dict['peer_state'] = m.groupdict()['peer_state']
                continue

            # Mode = Simplex
            m = p3.match(line)
            if m:
                ret_dict['mode'] = m.groupdict()['mode']
                continue

            # Unit = Primary
            m = p4.match(line)
            if m:
                ret_dict['unit'] = m.groupdict()['unit']
                continue

            # Unit ID = 48
            m = p5.match(line)
            if m:
                ret_dict['unit_id'] = int(m.groupdict()['unit_id'])
                continue

            # Redundancy Mode (Operational) = Non-redundant
            m = p6.match(line)
            if m:
                ret_dict['redundancy_mode_operational'] = \
                    m.groupdict()['redundancy_mode_operational']
                continue

            # Redundancy Mode (Configured)  = Non-redundant
            m = p7.match(line)
            if m:
                ret_dict['redundancy_mode_configured'] = \
                    m.groupdict()['redundancy_mode_configured']
                continue

            # Redundancy State              = sso
            m = p8.match(line)
            if m:
                ret_dict['redundancy_state'] = m.groupdict()[
                    'redundancy_state']
                continue

            # Maintenance Mode = Disabled
            m = p9.match(line)
            if m:
                ret_dict['maintenance_mode'] = m.groupdict()[
                    'maintenance_mode']
                continue

            # Manual Swact = enabled
            m = p10.match(line)
            if m:
                ret_dict['manual_swact'] = m.groupdict()['manual_swact']
                reason = m.groupdict()['manual_swact_reason']
                if reason:
                    ret_dict['manual_swact_reason'] = reason
                continue

            # Communications = Up
            m = p11.match(line)
            if m:
                ret_dict['communications'] = m.groupdict()['communications']
                reason = m.groupdict()['communications_reason']
                if reason:
                    ret_dict['communications_reason'] = reason
                continue

            # client count = 76
            m = p12.match(line)
            if m:
                ret_dict['client_count'] = int(m.groupdict()['client_count'])
                continue

            # client_notification_TMR = 30000 milliseconds
            m = p13.match(line)
            if m:
                ret_dict['client_notification_tmr_msec'] = int(
                    m.groupdict()['client_notification_tmr_msec'])
                continue

            # RF debug mask = 0x0
            m = p14.match(line)
            if m:
                ret_dict['rf_debug_mask'] = m.groupdict()['rf_debug_mask']
                continue

        return ret_dict


# =====================
# Schema for:
#   * 'show inventory'
# =====================
class ShowInventorySchema(MetaParser):

    ''' Schema for:
        * 'show inventory'
    '''

    schema = {
        Optional('main'):
            {Optional('swstack'): bool,
             Optional(Any()):
                {Any():
                    {Optional('name'): str,
                     Optional('descr'): str,
                     Optional('pid'): str,
                     Optional('vid'): str,
                     Optional('sn'): str,
                     },
                 },
             },
        Optional('slot'):
            {Any():
                {Optional('rp'):
                    {Any():
                        {Optional('name'): str,
                         Optional('descr'): str,
                         Optional('pid'): str,
                         Optional('vid'): str,
                         Optional('sn'): str,
                         Optional('swstack_power'): str,
                         Optional('swstack_power_sn'): str,
                         Optional('subslot'):
                            {Any():
                                {Any():
                                    {Optional('name'): str,
                                     Optional('descr'): str,
                                     Optional('pid'): str,
                                     Optional('vid'): str,
                                     Optional('sn'): str,
                                     },
                                 },
                             },
                         },
                     },
                 Optional('lc'):
                    {Any():
                        {Optional('name'): str,
                         Optional('descr'): str,
                         Optional('pid'): str,
                         Optional('vid'): str,
                         Optional('sn'): str,
                         Optional('swstack_power'): str,
                         Optional('swstack_power_sn'): str,
                         Optional('subslot'):
                            {Any():
                                {Any():
                                    {Optional('name'): str,
                                     Optional('descr'): str,
                                     Optional('pid'): str,
                                     Optional('vid'): str,
                                     Optional('sn'): str,
                                     },
                                 },
                             },
                         },
                     },
                 Optional('other'):
                    {Any():
                        {Optional('name'): str,
                         Optional('descr'): str,
                         Optional('pid'): str,
                         Optional('vid'): str,
                         Optional('sn'): str,
                         Optional('swstack_power'): str,
                         Optional('swstack_power_sn'): str,
                         Optional('subslot'):
                            {Any():
                                {Any():
                                    {Optional('name'): str,
                                     Optional('descr'): str,
                                     Optional('pid'): str,
                                     Optional('vid'): str,
                                     Optional('sn'): str,
                                     },
                                 },
                             },
                         },
                     },
                 },
             },
    }


# ====================
# Parser for:
#   * 'show inventory'
# ====================
class ShowInventory(ShowInventorySchema):

    ''' Parser for:
        * 'show inventory'
    '''

    cli_command = ['show inventory']

    def cli(self, output=None):

        if output is None:
            # Build command
            cmd = self.cli_command[0]
            # Execute command
            out = self.device.execute(cmd)
        else:
            out = output

        # Init vars
        ret_dict = {}
        name = descr = slot = subslot = pid = ''
        asr900_rp = False

        # NAME: "Switch 1", DESCR: "WS-C3850-24P-E"
        # NAME: "StackPort5/2", DESCR: "StackPort5/2"
        # NAME: "Switch 5 - Power Supply A", DESCR: "Switch 5 - Power Supply A"
        # NAME: "subslot 0/0 transceiver 2", DESCR: "GE T"
        # NAME: "NIM subslot 0/0", DESCR: "Front Panel 3 ports Gigabitethernet Module"
        # NAME: "Modem 0 on Cellular0/2/0", DESCR: "Sierra Wireless EM7455/EM7430"
        # NAME: "1", DESCR: "WS-C3560CX-12PC-S"
        p1 = re.compile(r'^NAME: +\"(?P<name>.*)\",'
                        r' +DESCR: +\"(?P<descr>.*)\"$')

        # Switch 1
        # module 0
        p1_1 = re.compile(r'^(Switch|[Mm]odule) +(?P<slot>(\S+))')

        # Power Supply Module 0
        # Power Supply Module 1
        p1_2 = re.compile(r'Power Supply Module')

        # SPA subslot 0/0
        # IM subslot 0/1
        # NIM subslot 0/0
        p1_3 = re.compile(r'^(SPA|IM|NIM|PVDM) +subslot +(?P<slot>(\d+))/(?P<subslot>(\d+))')

        # subslot 0/0 transceiver 0
        p1_4 = re.compile(r'^subslot +(?P<slot>(\d+))\/(?P<subslot>(.*))')

        # StackPort1/1
        p1_5 = re.compile(r'^StackPort(?P<slot>(\d+))/(?P<subslot>(\d+))$')

        # Fan Tray
        p1_6 = re.compile(r'^Fan +Tray|\d+$')

        # Modem 0 on Cellular0/2/0
        p1_7 = re.compile(r'^Modem +(?P<modem>\S+) +on +Cellular(?P<slot>\d+)\/(?P<subslot>.*)$')

        # Slot 2 Linecard
        # Slot 3 Supervisor
        p1_8 = re.compile(r'^Slot \d Linecard|Slot \d Supervisor$')

        # PID: ASR-920-24SZ-IM   , VID: V01  , SN: CAT1902V19M
        # PID: SFP-10G-LR        , VID: CSCO , SN: CD180456291
        # PID: A900-IMA3G-IMSG   , VID: V01  , SN: FOC2204PAP1
        # PID: SFP-GE-T          , VID: V02  , SN: MTC2139029X
        # PID: ISR4331-3x1GE     , VID: V01  , SN:
        # PID: ISR4331/K9        , VID:      , SN: FDO21520TGH
        # PID: ISR4331/K9        , VID:      , SN:
        # PID: , VID: 1.0  , SN: 1162722191
        # PID: WS-C3560CX-12PC-S , VID: V03  , SN: FOC2419L9KY
        p2 = re.compile(r'^PID: +(?P<pid>[\S\s]+)? *, +VID:(?: +(?P<vid>(\S+)))? *,'
                        r' +SN:(?: +(?P<sn>(\S+)))?$')
        for line in out.splitlines():
            line = line.strip()

            # NAME: "Switch 1", DESCR: "WS-C3850-24P-E"
            # NAME: "StackPort5/2", DESCR: "StackPort5/2"
            # NAME: "Switch 5 - Power Supply A", DESCR: "Switch 5 - Power Supply A"
            # NAME: "subslot 0/0 transceiver 2", DESCR: "GE T"
            # NAME: "NIM subslot 0/0", DESCR: "Front Panel 3 ports Gigabitethernet Module"
            # NAME: "Modem 0 on Cellular0/2/0", DESCR: "Sierra Wireless EM7455/EM7430"
            # NAME: "1", DESCR: "WS-C3560CX-12PC-S"
            m = p1.match(line)

            if m:
                group = m.groupdict()
                name = group['name'].strip()
                descr = group['descr'].strip()

                # ------------------------------------------------------------------
                # Define slot_dict
                # ------------------------------------------------------------------

                # Switch 1
                # module 0
                m1_1 = p1_1.match(name)
                if m1_1:
                    slot = m1_1.groupdict()['slot']
                    # Creat slot_dict
                    slot_dict = ret_dict.setdefault('slot', {}).setdefault(slot, {})

                # Power Supply Module 0
                m1_2 = p1_2.match(name)
                if m1_2:
                    slot = name.replace('Power Supply Module ', 'P')
                    # Creat slot_dict
                    slot_dict = ret_dict.setdefault('slot', {}).setdefault(slot, {})

                # ------------------------------------------------------------------
                # Define subslot
                # ------------------------------------------------------------------

                # SPA subslot 0/0
                # IM subslot 0/1
                # NIM subslot 0/0
                # subslot 0/0 transceiver 0
                # StackPort1/1
                # Modem 0 on Cellular0/2/0
                m = p1_3.match(name) or p1_4.match(name) or p1_5.match(name) or p1_7.match(name)
                if m:
                    group = m.groupdict()
                    slot = group['slot']
                    subslot = group['subslot']
                    # Creat slot_dict
                    slot_dict = ret_dict.setdefault('slot', {}).setdefault(slot, {})

                # Fan Tray
                m1_6 = p1_6.match(name)
                if m1_6:
                    slot = name.replace(' ', '_')
                    # Create slot_dict
                    slot_dict = ret_dict.setdefault('slot', {}).setdefault(slot, {})

                # Slot 2 Linecard
                # Slot 3 Supervisor
                m1_8 = p1_8.match(name)
                if m1_8:
                    slot = name.replace(' ', '_')
                    # Create slot_dict
                    slot_dict = ret_dict.setdefault('slot', {}).setdefault(slot, {})

                # go to next line
                continue

            # PID: ASR-920-24SZ-IM   , VID: V01  , SN: CAT1902V19M
            # PID: SFP-10G-LR        , VID: CSCO , SN: CD180456291
            # PID: A900-IMA3G-IMSG   , VID: V01  , SN: FOC2204PAP1
            # PID: SFP-GE-T          , VID: V02  , SN: MTC2139029X
            # PID: ISR4331-3x1GE     , VID: V01  , SN:
            # PID: ISR4331/K9        , VID:      , SN: FDO21520TGH
            # PID: ISR4331/K9        , VID:      , SN:
            # PID: EM7455/EM7430     , VID: 1.0  , SN: 355813070074072
            # PID: WS-C3560CX-12PC-S , VID: V03  , SN: FOC2419L9KY
            m = p2.match(line)
            if m:
                group = m.groupdict()
                if group.get('pid'):
                    pid = group['pid'].strip(' ')
                else:
                    pid = ''
                vid = group['vid'] or ''
                sn = group['sn'] or ''

                # NAME: "Chassis", DESCR: "Cisco ASR1006 Chassis"
                if 'Chassis' in name:
                    main_dict = ret_dict.setdefault('main', {}).\
                        setdefault('chassis', {}).\
                        setdefault(pid, {})
                    main_dict['name'] = name
                    main_dict['descr'] = descr
                    main_dict['pid'] = pid
                    main_dict['vid'] = vid
                    main_dict['sn'] = sn

                if ('IE' in pid) or ('17' in pid):
                    if ('Supervisor' in name):
                        main_dict = ret_dict.setdefault('main', {}).\
                            setdefault('supervisor', {}).\
                            setdefault(pid, {})
                        main_dict['name'] = name
                        main_dict['descr'] = descr
                        main_dict['pid'] = pid
                        main_dict['vid'] = vid
                        main_dict['sn'] = sn

                if "Expansion Module" in name:
                    main_dict = ret_dict.setdefault('main', {}).\
                        setdefault('expansion_module', {}).\
                        setdefault(pid, {})
                    main_dict['name'] = name
                    main_dict['descr'] = descr
                    main_dict['pid'] = pid
                    main_dict['vid'] = vid
                    main_dict['sn'] = sn


                if 'cpu' in name or 'usb' in name:
                    main_dict = ret_dict.setdefault('main', {}).\
                        setdefault(name, {}).\
                        setdefault(pid, {})
                    main_dict['name'] = name
                    main_dict['descr'] = descr
                    main_dict['pid'] = pid
                    main_dict['vid'] = vid
                    main_dict['sn'] = sn

                main_names = [
                    'Switch1',
                    'Switch2',
                    'GigabitEthernet',
                    'TwoGigabitEthernet',
                    'TenGigabitEthernet',
                    'HundredGigE',
                    'FourHundredGigE',
                    'FiftyGigE'
                ]

                for interface in main_names:
                    if interface in name:
                        main_dict = ret_dict.setdefault('main', {}).\
                            setdefault(name, {}).\
                            setdefault(pid, {})
                        main_dict['name'] = name
                        main_dict['descr'] = descr
                        main_dict['pid'] = pid
                        main_dict['vid'] = vid
                        main_dict['sn'] = sn

                # PID: STACK-T1-50CM     , VID: V01  , SN: LCC1921G250
                if 'STACK' in pid:
                    main_dict = ret_dict.setdefault('main', {})
                    main_dict['swstack'] = True

                if ('ASR-9') in pid and ('PWR' not in pid) and ('FAN' not in pid):
                    rp_dict = ret_dict.setdefault('slot', {}).\
                        setdefault('0', {}).\
                        setdefault('rp', {}).\
                        setdefault(pid, {})
                    rp_dict['name'] = name
                    rp_dict['descr'] = descr
                    rp_dict['pid'] = pid
                    rp_dict['vid'] = vid
                    rp_dict['sn'] = sn
                    asr900_rp = True

                # Ensure name, slot have been previously parsed
                if not name or not slot:
                    continue

                # PID: ASR1000-RP2       , VID: V02  , SN: JAE153408NJ
                # PID: ASR1000-RP2       , VID: V03  , SN: JAE1703094H
                # PID: WS-C3850-24P-E    , VID: V01  , SN: FCW1932D0LB
                if ('RP' in pid) or ('WS-C' in pid) or ('R' in name):
                    rp_dict = slot_dict.setdefault('rp', {}).\
                        setdefault(pid, {})
                    rp_dict['name'] = name
                    rp_dict['descr'] = descr
                    rp_dict['pid'] = pid
                    rp_dict['vid'] = vid
                    rp_dict['sn'] = sn

                # PID: ASR1000-SIP40     , VID: V02  , SN: JAE200609WP
                # PID: ISR4331/K9        , VID:      , SN: FDO21520TGH
                # PID: ASR1002-X         , VID: V07, SN: FOX1111P1M1
                # PID: ASR1002-HX        , VID:      , SN:
                elif (('SIP' in pid)  or ('-X' in pid) or \
                     ('-HX' in pid) or ('-LC' in pid) or ('module' in name and not ('module F' in name))) and \
                     ('subslot' not in name):

                    lc_dict = slot_dict.setdefault('lc', {}).\
                        setdefault(pid, {})
                    lc_dict['name'] = name
                    lc_dict['descr'] = descr
                    lc_dict['pid'] = pid
                    lc_dict['vid'] = vid
                    lc_dict['sn'] = sn

                # PID: SP7041-E          , VID: E    , SN: MTC164204VE
                # PID: SFP-GE-T          , VID: V02  , SN: MTC2139029X
                # PID: EM7455/EM7430     , VID: 1.0  , SN: 355813070074072
                elif subslot:
                    if ('STACK' in pid):
                        try:
                            rp_dict
                        except NameError:
                            stack_dict = slot_dict.setdefault('other', {}).\
                                setdefault(pid, {})
                            subslot_dict = stack_dict.setdefault('subslot', {}).\
                                setdefault(subslot, {}).\
                                setdefault(pid, {})
                        else:
                            subslot_dict = rp_dict.setdefault('subslot', {}).\
                                setdefault(subslot, {}).\
                                setdefault(pid, {})

                    elif asr900_rp:
                        subslot_dict = rp_dict.setdefault('subslot', {}).\
                            setdefault(subslot, {}).\
                            setdefault(pid, {})
                    else:
                        if 'lc' not in slot_dict:
                            lc_dict = slot_dict.setdefault('lc', {}). \
                                setdefault(pid, {})
                        subslot_dict = lc_dict.setdefault('subslot', {}).\
                            setdefault(subslot, {}).\
                            setdefault(pid, {})
                    subslot_dict['name'] = name
                    subslot_dict['descr'] = descr
                    subslot_dict['pid'] = pid
                    subslot_dict['vid'] = vid
                    subslot_dict['sn'] = sn

                # PID: ASR1006-PWR-AC    , VID: V01  , SN: ART1210Q049
                # PID: ASR1006-PWR-AC    , VID: V01  , SN: ART1210Q04C
                # PID: ASR-920-FAN-M     , VID: V01  , SN: CAT1903V028
                else:
                    other_dict = slot_dict.setdefault('other', {}).\
                        setdefault(pid, {})
                    other_dict['name'] = name
                    other_dict['descr'] = descr
                    other_dict['pid'] = pid
                    other_dict['vid'] = vid
                    other_dict['sn'] = sn

                # Reset to avoid overwrite
                name = descr = slot = subslot = ''
                continue

        return ret_dict


class ShowPlatformSchema(MetaParser):
    """Schema for show platform"""
    schema = {
        Optional('main'): {
            Optional('switch_mac_address'): str,
            Optional('mac_persistency_wait_time'): str,
            Optional('chassis'): str,
            Optional('swstack'): bool
        },
        'slot': {
            Any(): {
                Optional('rp'): {
                    Any(): {
                        Optional('sn'): str,
                        Optional('state'): str,
                        Optional('num_of_ports'): str,
                        Optional('mac_address'): str,
                        Optional('hw_ver'): str,
                        Optional('sw_ver'): str,
                        Optional('swstack_role'): str,
                        Optional('swstack_priority'): str,
                        Optional('ports'): str,
                        Optional('role'): str,
                        Optional('name'): str,
                        Optional('slot'): str,
                        Optional('priority'): str,
                        Optional('insert_time'): str,
                        Optional('fw_ver'): str,
                        Optional('cpld_ver'): str,
                    }
                },
                Optional('lc'): {
                    Any(): {
                        Optional('cpld_ver'): str,
                        Optional('fw_ver'): str,
                        Optional('insert_time'): str,
                        Optional('name'): str,
                        Optional('slot'): str,
                        Optional('state'): str,
                        Optional('subslot'): {
                            Any(): {
                                Any(): {
                                    Optional('insert_time'): str,
                                    Optional('name'): str,
                                    Optional('state'): str,
                                    Optional('subslot'): str,
                                }
                            }
                        }
                    }
                },
                Optional('other'): {
                    Any(): {
                        Optional('cpld_ver'): str,
                        Optional('fw_ver'): str,
                        Optional('insert_time'): str,
                        Optional('name'): str,
                        Optional('slot'): str,
                        Optional('state'): str,
                        Optional('subslot'): {
                            Any(): {
                                Any(): {
                                    Optional('insert_time'): str,
                                    Optional('name'): str,
                                    Optional('state'): str,
                                    Optional('subslot'): str,
                                }
                            }
                        }
                    }
                }
            }
        }
    }


class ShowPlatform(ShowPlatformSchema):
    """Parser for show platform
    parser class - implements detail parsing mechanisms for cli output.
    """
    # *************************
    # schema - class variable
    #
    # Purpose is to make sure the parser always return the output
    # (nested dict) that has the same data structure across all supported
    # parsing mechanisms (cli(), yang(), xml()).

    cli_command = 'show platform'
    exclude = ['insert_time']

    def cli(self, output=None):
        """parsing mechanism: cli

        Function cli() defines the cli type output parsing mechanism which
        typically contains 3 steps: exe
        cuting, transforming, returning
        """
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        platform_dict = {}
        sub_dict = {}

        # ----------      C3850    -------------

        # Switch/Stack Mac Address : 0057.d2ff.e71b - Local Mac Address
        p1 = re.compile(r'^[Ss]witch\/[Ss]tack +[Mm]ac +[Aa]ddress +\: +'
                        r'(?P<switch_mac_address>[\w\.]+) *(?P<local>[\w\s\-]+)?$')

        # Mac persistency wait time: Indefinite
        p2 = re.compile(r'^[Mm]ac +persistency +wait +time\: +(?P<mac_persistency_wait_time>[\w\.\:]+)$')

        # Switch  Ports    Model                Serial No.   MAC address     Hw Ver.       Sw Ver.
        # ------  -----   ---------             -----------  --------------  -------       --------
        #  1       32     WS-C3850-24P-E        FCW1947C0HH  0057.d2ff.e71b  V07           16.6.1
        #  1       32     C9200-24P             JAD2310213C  dc8c.37ff.ad21  V01           17.05.01
        #  1       32     C9200-24P             JAD2310213C  dc8c.37ff.ad21  V01           2021-03-03_18.
        p3 = re.compile(r'^(?P<switch>\d+) +(?P<ports>\d+) +'
                        r'(?P<model>[\w\-]+) +(?P<serial_no>\w+) +'
                        r'(?P<mac_address>[\w\.\:]+) +'
                        r'(?P<hw_ver>\w+) +(?P<sw_ver>[\s\S]+)$')

        #                                     Current
        # Switch#   Role        Priority      State
        # -------------------------------------------
        # *1       Active          3          Ready
        p4 = re.compile(r'^\*?(?P<switch>\d+) +(?P<role>\w+) +'
                        r'(?P<priority>\d+) +(?P<state>[\w\s]+)$')

        # ----------      ASR1K    -------------
        # Chassis type: ASR1006
        # Chassis type: ASR-903
        p5 = re.compile(r'^[Cc]hassis +type: +(?P<chassis>\S+)$')

        # Slot      Type                State                 Insert time (ago)
        # --------- ------------------- --------------------- -----------------
        # 0         ASR1000-SIP40       ok                    00:33:53
        #  0/0      SPA-1XCHSTM1/OC3    ok                    2d00h
        # F0                            ok, active            00:09:23
        # P1        Unknown             N/A                   never
        p6 = re.compile(r'^(?P<slot>[a-zA-Z0-9]+)(\/(?P<subslot>\d+))?( +(?P<name>[a-zA-Z0-9\-\_/+]+))? +(?P<state>(?!\d+|unknown)\w+(\, \w+)?(/\w+)?) +(?P<insert_time>[\w\.\:]+)$')

        # 4                             unknown               2d00h
        p6_1 = re.compile(r'^(?P<slot>\w+) +(?P<state>\w+(\, \w+)?) +(?P<insert_time>[\w\.\:]+)$')

        # Slot      CPLD Version        Firmware Version
        # --------- ------------------- ---------------------------------------
        # 0         00200800            16.2(1r)
        p7 = re.compile(r'^(?P<slot>\w+) +(?P<cpld_version>\d+|N\/A) +(?P<fireware_ver>[\w\.\(\)\/]+)$')

        for line in out.splitlines():
            line = line.strip()

            # Switch/Stack Mac Address : 0057.d2ff.e71b - Local Mac Address
            m = p1.match(line)
            if m:
                if 'main' not in platform_dict:
                    platform_dict['main'] = {}
                platform_dict['main']['switch_mac_address'] = m.groupdict()['switch_mac_address']
                platform_dict['main']['swstack'] = True
                continue

            # Mac persistency wait time: Indefinite
            m = p2.match(line)
            if m:
                if 'main' not in platform_dict:
                    platform_dict['main'] = {}
                platform_dict['main']['mac_persistency_wait_time'] = m.groupdict()['mac_persistency_wait_time'].lower()
                continue

            # Switch  Ports    Model                Serial No.   MAC address     Hw Ver.       Sw Ver.
            # ------  -----   ---------             -----------  --------------  -------       --------
            #  1       32     WS-C3850-24P-E        FCW1947C0HH  0057.d2ff.e71b  V07           16.6.1
            #  1       32     C9200-24P             JAD2310213C  dc8c.37ff.ad21  V01           17.05.01
            #  1       32     C9200-24P             JAD2310213C  dc8c.37ff.ad21  V01           2021-03-03_18.
            m = p3.match(line)
            if m:
                slot = m.groupdict()['switch']
                model = m.groupdict()['model']
                if 'slot' not in platform_dict:
                    platform_dict['slot'] = {}
                if slot not in platform_dict['slot']:
                    platform_dict['slot'][slot] = {}

                if ('WS-C' in model or 'C9500' in model or 'C9300' in model or 'C9200' in model or
                   'IE-32' in model or 'IE-33' in model or 'IE-34' in model or 'IE-93' in model or
                   'IE-31' in model or '1783' in model):
                    lc_type = 'rp'
                else:
                    lc_type = 'other'

                if lc_type not in platform_dict['slot'][slot]:
                    platform_dict['slot'][slot][lc_type] = {}
                if model not in platform_dict['slot'][slot][lc_type]:
                    platform_dict['slot'][slot][lc_type][model] = {}
                platform_dict['slot'][slot][lc_type][model]['hw_ver'] = m.groupdict()['hw_ver']
                platform_dict['slot'][slot][lc_type][model]['mac_address'] = m.groupdict()['mac_address']
                platform_dict['slot'][slot][lc_type][model]['name'] = model
                platform_dict['slot'][slot][lc_type][model]['ports'] = m.groupdict()['ports']
                platform_dict['slot'][slot][lc_type][model]['slot'] = slot
                platform_dict['slot'][slot][lc_type][model]['sn'] = m.groupdict()['serial_no']
                platform_dict['slot'][slot][lc_type][model]['sw_ver'] = m.groupdict()['sw_ver']
                continue

            #                                     Current
            # Switch#   Role        Priority      State
            # -------------------------------------------
            # *1       Active          3          Ready
            m = p4.match(line)
            if m:
                slot = m.groupdict()['switch']
                if 'slot' not in platform_dict:
                    continue
                if slot not in platform_dict['slot']:
                    continue

                for key, value in platform_dict['slot'][slot].items():
                    for key, last in value.items():
                        last['swstack_priority'] = m.groupdict()['priority']
                        last['swstack_role'] = m.groupdict()['role']
                        last['state'] = m.groupdict()['state']
                continue

            # Chassis type: ASR1006
            # Chassis type: ASR-903
            m = p5.match(line)
            if m:
                if 'main' not in platform_dict:
                    platform_dict['main'] = {}
                platform_dict['main']['chassis'] = m.groupdict()['chassis']
                continue

            # Slot      Type                State                 Insert time (ago)
            # --------- ------------------- --------------------- -----------------
            # 0         ASR1000-SIP40       ok                    00:33:53
            #  0/0      SPA-1XCHSTM1/OC3    ok                    2d00h
            # 0         C8200-1N-4T         ok                    00:32:26
            m = p6.match(line)
            if m:
                slot = m.groupdict()['slot']
                subslot = m.groupdict()['subslot']
                name = m.groupdict()['name']
                if name:

                    # subslot
                    if subslot:
                        try:
                            # no-slot-type output:
                            # Slot      Type                State                 Insert time (ago)

                            # --------- ------------------- --------------------- -----------------

                            # 0/2      A900-IMA8Z          ok                    1w4d

                            if 'slot' not in platform_dict:
                                platform_dict['slot'] = {}
                            if slot not in platform_dict['slot']:
                                platform_dict['slot'][slot] = {}
                            # if slot not in platform_dict['slot']:
                            #     continue

                            slot_items = platform_dict['slot'][slot].items()

                            # for no-slot-type output
                            if not slot_items:
                                if re.match(r'^ASR\d+-(\d+T\S+|SIP\d+|X)|ISR|C9|C82|C83', name):
                                    if 'R' in slot:
                                        lc_type = 'rp'
                                    elif re.match(r'^\d+', slot):
                                        lc_type = 'lc'
                                    else:
                                        lc_type = 'other'
                                elif re.match(r'^ASR\d+-RP\d+', name):
                                    lc_type = 'rp'
                                elif re.match(r'^CSR\d+V', name):
                                    if 'R' in slot:
                                        lc_type = 'rp'
                                    else:
                                        lc_type = 'other'
                                else:
                                    lc_type = 'other'

                                if lc_type not in platform_dict['slot'][slot]:
                                    platform_dict['slot'][slot][lc_type] = {}

                                if name not in platform_dict['slot'][slot][lc_type]:
                                    platform_dict['slot'][slot][lc_type][name] = {}
                                sub_dict = platform_dict['slot'][slot][lc_type][name]
                                sub_dict['slot'] = slot

                            # Add subslot
                            for key, value in slot_items:
                                for key, last in value.items():
                                    if 'subslot' not in last:
                                        last['subslot'] = {}
                                    if subslot not in last['subslot']:
                                        last['subslot'][subslot] = {}
                                    if name not in last['subslot'][subslot]:
                                        last['subslot'][subslot][name] = {}
                                    sub_dict = last['subslot'][subslot][name]
                            sub_dict['subslot'] = subslot

                        # KeyError: 'slot'
                        except Exception:
                            continue
                    else:
                        if 'slot' not in platform_dict:
                            platform_dict['slot'] = {}
                        if slot not in platform_dict['slot']:
                            platform_dict['slot'][slot] = {}
                        if re.match(r'^ASR\d+-(\d+T\S+|SIP\d+|X)|ISR|C9|C82|C83', name):
                            if 'R' in slot:
                                lc_type = 'rp'
                            elif re.match(r'^\d+', slot):
                                lc_type = 'lc'
                            else:
                                lc_type = 'other'
                        elif re.match(r'^ASR\d+-RP\d+', name):
                            lc_type = 'rp'
                        elif re.match(r'^CSR\d+V', name):
                            if 'R' in slot:
                                lc_type = 'rp'
                            else:
                                lc_type = 'other'
                        else:
                            lc_type = 'other'

                        if lc_type not in platform_dict['slot'][slot]:
                            platform_dict['slot'][slot][lc_type] = {}

                        if name not in platform_dict['slot'][slot][lc_type]:
                            platform_dict['slot'][slot][lc_type][name] = {}
                        sub_dict = platform_dict['slot'][slot][lc_type][name]
                        sub_dict['slot'] = slot

                    sub_dict['name'] = name
                    sub_dict['state'] = m.groupdict()['state'].strip()
                    sub_dict['insert_time'] = m.groupdict()['insert_time']
                    continue

            # Slot      CPLD Version        Firmware Version
            # --------- ------------------- ---------------------------------------
            # 0         00200800            16.2(1r)
            m = p7.match(line)
            if m:
                fw_ver = m.groupdict()['fireware_ver']
                cpld_ver = m.groupdict()['cpld_version']
                slot = m.groupdict()['slot']

                if 'slot' not in platform_dict:
                    continue
                if slot not in platform_dict['slot']:
                    continue

                for key, value in platform_dict['slot'][slot].items():
                    for key, last in value.items():
                        last['cpld_ver'] = m.groupdict()['cpld_version']
                        last['fw_ver'] = m.groupdict()['fireware_ver']
                continue

            # 4                             unknown               2d00h
            m = p6_1.match(line)
            if m:
                slot = m.groupdict()['slot']
                if 'slot' not in platform_dict:
                    platform_dict['slot'] = {}
                if slot not in platform_dict['slot']:
                    platform_dict['slot'][slot] = {}

                if 'other' not in platform_dict['slot'][slot]:
                    platform_dict['slot'][slot]['other'] = {}
                    platform_dict['slot'][slot]['other'][''] = {}
                platform_dict['slot'][slot]['other']['']['slot'] = slot
                platform_dict['slot'][slot]['other']['']['name'] = ''
                platform_dict['slot'][slot]['other']['']['state'] = m.groupdict()['state']
                platform_dict['slot'][slot]['other']['']['insert_time'] = m.groupdict()['insert_time']
                continue

        return platform_dict


class ShowBootSchema(MetaParser):
    """Schema for show boot"""

    schema = {
        Optional('current_boot_variable'): str,
        Optional('next_reload_boot_variable'): str,
        Optional('manual_boot'): bool,
        Optional('enable_break'): bool,
        Optional('boot_mode'): str,
        Optional('ipxe_timeout'): int,
        Optional('active'): {
            Optional('configuration_register'): str,
            Optional('boot_variable'): str,
            Optional('manual_boot'): bool,
        },
        Optional('standby'): {
            Optional('configuration_register'): str,
            Optional('boot_variable'): str,
            Optional('manual_boot'): bool,
        },
        Optional('boot_path_list'): str,
        Optional('config_file'): str,
        Optional('private_config_file'): str,
        Optional('enable_break'): bool,
        Optional('manual_boot'): bool,
        Optional('helper_path_list'): str,
        Optional('auto_upgrade'): bool,
        Optional('auto_upgrade_path'): str,
        Optional('boot_optimization'): bool,
        Optional('nvram_buffer_size'): int,
        Optional('timeout_config_download'): str,
        Optional('config_download_via_dhcp'): bool,
        Optional('next_boot'): bool,
        Optional('allow_dev_key'): bool,
        Optional('switches'): {
            Any(): {
                'boot_path_list': str,
                'config_file': str,
                'private_config_file': str,
                'enable_break': bool,
                'manual_boot': bool,
                Optional('helper_path_list'): str,
                'auto_upgrade': bool,
                Optional('auto_upgrade_path'): str,
                Optional('boot_optimization'): bool,
                Optional('nvram_buffer_size'): int,
                Optional('timeout_config_download'): str,
                Optional('config_download_via_dhcp'): bool,
                Optional('next_boot'): bool,
                Optional('allow_dev_key'): bool,
            },
        },
    }


class ShowBoot(ShowBootSchema):
    """Parser for show boot"""
    SW_MAPPING = {
        'BOOT path-list ': 'boot_path_list',
        'Config file': 'config_file',
        'Private Config file': 'private_config_file',
        'Enable Break': 'enable_break',
        'Manual Boot': 'manual_boot',
        'Allow Dev Key': 'allow_dev_key',
        'HELPER path-list': 'helper_path_list',
        'Auto upgrade': 'auto_upgrade',
        'Auto upgrade path': 'auto_upgrade_path',
        'Boot optimization': 'boot_optimization',
        'NVRAM/Config file buffer size': 'nvram_buffer_size',
        'Timeout for Config Download': 'timeout_config_download',
        'Config Download via DHCP': 'config_download_via_dhcp'
    }
    TRUE_FALSE = {
        'disable': False,
        'disabled': False,
        'no': False,
        'enable': True,
        'enabled': True,
        'yes': True
    }

    cli_command = 'show boot'

    def cli(self, output=None):

        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        boot_dict = {}
        boot_variable = None
        switch_number = 0

        # Current Boot Variables:
        p1 = re.compile(r'Current +Boot +Variables:$')

        # Boot Variables on next reload:
        p1_2 = re.compile(r'Boot +Variables +on +next +reload:$')

        # BOOT variable = bootflash:/asr1000rpx.bin,12;
        # BOOT variable = flash:cat3k_caa-universalk9.BLD_POLARIS_DEV_LATEST_20150907_031219.bin;
        #                 flash:cat3k_caa-universalk9.BLD_POLARIS_DEV_LATEST_20150828_174328.SSA.bin;flash:ISSUCleanGolden;
        # BOOT variable = tftp://10.1.144.25//auto/tftptest-blr/latest//cat9k_iosxe.BLD_V173_THROTTLE_LATEST_20200427_012602.SSA.bin
        # BOOT variable = tftp://10.1.144.25//auto/tftptest-blr/latest//cat9k_iosxe.BLD_V173_THROTTLE_LATEST_20200428_021754.SSA.bin;bootflash:/cat9k_iosxe.BLD_POLARIS_DEV_LATEST_20200429_051305.SSA_starfleet-1.bin;
        p1_1 = re.compile(r'^BOOT +variable +=( *(?P<var>\S+);?)?$')

        # Standby BOOT variable = bootflash:/asr1000rpx.bin,12;
        p2 = re.compile(r'^Standby +BOOT +variable +=( *(?P<var>\S+);)?$')

        # Configuration register is 0x2002
        # Configuration Register is 0x102
        p3 = re.compile(r'^Configuration +[r|R]egister +is +(?P<var>\w+)$')

        # Standby Configuration register is 0x2002
        p4 = re.compile(r'^Standby +Configuration +register'
                        ' +is +(?P<var>\w+)$')

        # Manual Boot = yes
        p5 = re.compile(r'^Manual +Boot += +(?P<var>\w+)$')

        # MANUAL_BOOT variable = no
        p5_1 = re.compile(r'(^MANUAL_BOOT +variable) += +(?P<var>\w+)$')

        # Standby MANUAL_BOOT variable = no
        p5_2 = re.compile(r'(^Standby +MANUAL_BOOT +variable) += +(?P<var>\w+)$')

        # Enable Break = yes
        p6 = re.compile(r'^Enable +Break += +(?P<var>\w+)$')

        # Boot Mode = DEVICE
        p7 = re.compile(r'^Boot +Mode += +(?P<var>\S+)$')

        # iPXE Timeout = 0
        p8 = re.compile(r'^iPXE +Timeout +=? +(?P<var>\w+)$')

        # BOOT path-list{      : flash:/c2960x-universalk9-mz.152-4.E8.bin
        # HELPER path-list    :
        p9 = re.compile(r'^(?P<key>BOOT|HELPER) +path\-list +\:(?: '
                        r'+(?P<value>[\w\:\/\-\.]+)?)$')

        # Config file         : flash:/config.text
        # Private Config file : flash:/private-config.text
        # Enable Break        : yes
        # Manual Boot         : no
        # Allow Dev Key         : yes
        # Auto upgrade        : no
        # Auto upgrade path   :
        p10 = re.compile(r'^(?P<key>[\w\s]+) +\: +(?P<value>[\w\:\/\-\.]+)$')

        # buffer size:   524288
        p11 = re.compile(r'buffer +size\: +(?P<value>\d+)$')

        # Download:    0 seconds
        p12 = re.compile(r'Download\: +(?P<value>\d+ +\w+)$')

        # via DHCP:       disabled (next boot: disabled)
        p13 = re.compile(r'via +DHCP\: +(?P<value>\w+) +\(next +boot\: '
                            r'+(?P<next_boot>\w+)\)$')

        # Switch 2
        # switch 3
        p14 = re.compile(r'^[Ss]witch +(?P<switch_number>\d+)$')

        # BOOT path-list      :
        p15 = re.compile(r'^(?P<key>BOOT) +path\-list +\:$')

        for line in out.splitlines():
            line = line.strip()

            # Current Boot Variables:
            m1 = p1.match(line)
            if m1:
                boot_variable = 'current'
                continue

            # Boot Variables on next reload:
            m1_2 = p1_2.match(line)
            if m1_2:
                boot_variable = 'next'
                continue

            # BOOT variable = bootflash:/asr1000rpx.bin,12;
            # BOOT variable = flash:cat3k_caa-universalk9.BLD_POLARIS_DEV_LATEST_20150907_031219.bin;
            #                 flash:cat3k_caa-universalk9.BLD_POLARIS_DEV_LATEST_20150828_174328.SSA.bin;flash:ISSUCleanGolden;
            # BOOT variable = tftp://10.1.144.25//auto/tftptest-blr/latest//cat9k_iosxe.BLD_V173_THROTTLE_LATEST_20200427_012602.SSA.bin
            # BOOT variable = tftp://10.1.144.25//auto/tftptest-blr/latest//cat9k_iosxe.BLD_V173_THROTTLE_LATEST_20200428_021754.SSA.bin;bootflash:/cat9k_iosxe.BLD_POLARIS_DEV_LATEST_20200429_051305.SSA_starfleet-1.bin;
            m1_1 = p1_1.match(line)
            if m1_1:
                boot = m1_1.groupdict()['var']
                if boot:
                    if boot_variable == 'current':
                        boot_dict['current_boot_variable'] = boot
                    elif boot_variable == 'next':
                        boot_dict['next_reload_boot_variable'] = boot
                    else:
                        if 'active' not in boot_dict:
                            boot_dict['active'] = {}
                        boot_dict['active']['boot_variable'] = boot
                continue

            # Standby BOOT variable = bootflash:/asr1000rpx.bin,12;
            m2 = p2.match(line)
            if m2:
                if m2.groupdict()['var']:
                    if 'standby' not in boot_dict:
                        boot_dict['standby'] = {}
                        boot_dict['standby']['boot_variable'] = m2.groupdict()['var']
                continue

            # Configuration register is 0x2002
            # Configuration Register is 0x102
            m3 = p3.match(line)
            if m3:
                if 'active' not in boot_dict:
                    boot_dict['active'] = {}
                boot_dict['active']['configuration_register'] = m3.groupdict()['var']
                continue

            # Standby Configuration register is 0x2002
            m4 = p4.match(line)
            if m4:
                if 'standby' not in boot_dict:
                    boot_dict['standby'] = {}
                boot_dict['standby']['configuration_register'] = m4.groupdict()['var']
                continue

            # Manual Boot = yes
            m5 = p5.match(line)
            if m5:
                boot_dict['manual_boot'] = True if \
                    m5.groupdict()['var'].lower() == 'yes' else\
                    False
                continue

            # MANUAL_BOOT variable = no
            m5_1 = p5_1.match(line)
            if m5_1:
                if 'active' not in boot_dict:
                    boot_dict['active'] = {}
                boot_dict['active']['manual_boot'] = True if \
                    m5_1.groupdict()['var'].lower() == 'yes' else\
                    False
                continue

            # Standby MANUAL_BOOT variable = no
            m5_2 = p5_2.match(line)
            if m5_2:
                if 'standby' not in boot_dict:
                    boot_dict['standby'] = {}
                boot_dict['standby']['manual_boot'] = True if \
                    m5_2.groupdict()['var'].lower() == 'yes' else\
                    False
                continue

            # Enable Break = yes
            m6 = p6.match(line)
            if m6:
                boot_dict['enable_break'] = True if \
                    m6.groupdict()['var'].lower() == 'yes' else\
                    False
                continue

            # Boot Mode = DEVICE
            m7 = p7.match(line)
            if m7:
                boot_dict['boot_mode'] = m7.groupdict()['var'].lower()
                continue

            # iPXE Timeout = 0
            m8 = p8.match(line)
            if m8:
                boot_dict['ipxe_timeout'] = int(m8.groupdict()['var'])
                continue

            # BOOT path-list      : flash:/c2960x-universalk9-mz.152-4.E8.bin
            # HELPER path-list    :
            m9 = p9.match(line)
            if m9:
                group = m9.groupdict()
                if 'BOOT' in group['key']:
                    sw_dict = boot_dict
                    if switch_number >= 2:
                        switches_dict = sw_dict.setdefault('switches', {})
                        index_dict = switches_dict.setdefault(
                            switch_number, {})
                        index_dict.update({'boot_path_list': m9.groupdict()['value']})
                    else:
                        index_dict = sw_dict
                        index_dict.update({'boot_path_list': m9.groupdict()['value']})

                elif 'HELPER' in group['key']:
                    index_dict.update({'helper_path_list': m9.groupdict()['value']})

                continue

            # Config file         : flash:/config.text
            # Private Config file : flash:/private-config.text
            # Enable Break        : yes
            # Manual Boot         : no
            # Allow Dev Key         : yes
            # Auto upgrade        : no
            # Auto upgrade path   :
            m10 = p10.match(line)
            if m10:
                group = m10.groupdict()

                key = self.SW_MAPPING.get(group['key'].strip())
                true_false = self.TRUE_FALSE.get(group['value'])

                if isinstance(true_false, bool):
                    index_dict[key] = true_false
                else:
                    index_dict[key] = group['value']

                continue

            # buffer size:   524288
            m11 = p11.match(line)
            if m11:
                index_dict.update({'nvram_buffer_size': int(m11.groupdict()['value'])})

                continue

            # Download:    0 seconds
            m12 = p12.match(line)
            if m12:
                index_dict.update({'timeout_config_download': m12.groupdict()['value']})

                continue

            # via DHCP:       disabled (next boot: disabled)
            m13 = p13.match(line)
            if m13:
                group = m13.groupdict()
                value = self.TRUE_FALSE.get(group['value'])
                next_boot = self.TRUE_FALSE.get(group['next_boot'])
                index_dict.update({'config_download_via_dhcp': value})
                index_dict.update({'next_boot': next_boot})

                continue

            # Switch 2
            # switch 3
            m14 = p14.match(line)
            if m14:
                switch_number = int(m14.groupdict()['switch_number'])

                continue

            # BOOT path-list      :
            m15 = p15.match(line)
            if m15:
                sw_dict = boot_dict
                index_dict = sw_dict

                continue

        return boot_dict


class ShowSwitchDetailSchema(MetaParser):
    """Schema for show switch detail"""
    schema = {
        'switch': {
            'mac_address': str,
            Optional('mac_persistency_wait_time'): str,
            'stack': {
                Any(): {
                    'role': str,
                    'mac_address': str,
                    'priority': str,
                    Optional('hw_ver'): str,
                    'state': str,
                    'ports': {
                        Any(): {
                            'stack_port_status': str,
                            'neighbors_num': Or(int, str)
                        },
                    }
                },
            }
        }
    }


class ShowSwitchDetail(ShowSwitchDetailSchema):
    """Parser for show switch detail."""

    cli_command = 'show switch detail'
    STACK_PORT_RANGE = ('1', '2')

    def cli(self, output=None):

        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # return empty when no output
        if not out:
            return ret_dict

        # initial regexp pattern

        # Switch/Stack Mac Address : 0057.d2ff.e71b - Local Mac Address
        p1 = re.compile(r'^[Ss]witch\/[Ss]tack +[Mm]ac +[Aa]ddress +\: +'
                        '(?P<switch_mac_address>[\w\.]+) *(?P<local>[\w\s\-]+)?$')

        # Mac persistency wait time: Indefinite
        p2 = re.compile(r'^[Mm]ac +persistency +wait +time\: +'
                        '(?P<mac_persistency_wait_time>[\w\.\:]+)$')

        #                                              H/W   Current
        # Switch#   Role    Mac Address     Priority Version  State
        # -----------------------------------------------------------
        # *1       Active   689c.e2ff.b9d9     3      V04     Ready
        #  2       Standby  689c.e2ff.b9d9     14             Ready
        #  3       Member   bbcc.fcff.7b00     15     0       V-Mismatch
        p3_0 = re.compile(r'^Switch#\s+Role\s+Mac\sAddress\s+Priority\s+Version\s+State$')

        p3_1 = re.compile(r'^\*?(?P<switch>\d+) +(?P<role>\w+) +'
                           '(?P<mac_address>[\w\.]+) +'
                           '(?P<priority>\d+) +'
                           '(?P<hw_ver>\w+)? +'
                           '(?P<state>[\w\s-]+)$')

        #          Stack Port Status             Neighbors
        # Switch#  Port 1     Port 2           Port 1   Port 2
        #   1         OK         OK               3        2
        #   1       DOWN       DOWN             None     None
        p4_0 = re.compile(r'^Switch#\s+Port\s1\s+Port\s2\s+Port\s1\s+Port\s2$')

        p4_1 = re.compile(r'^(?P<switch>\d+) +(?P<status1>\w+) +'
                           '(?P<status2>\w+) +'
                           '(?P<nbr_num_1>\w+) +'
                           '(?P<nbr_num_2>\w+)$')

        active_table = 0

        for line in out.splitlines():
            line = line.strip()

            # Switch/Stack Mac Address : 0057.d2ff.e71b - Local Mac Address
            m = p1.match(line)
            if m:
                ret_dict['mac_address'] = m.groupdict()['switch_mac_address']
                continue

            # Mac persistency wait time: Indefinite
            m = p2.match(line)
            if m:
                ret_dict['mac_persistency_wait_time'] = m.groupdict()['mac_persistency_wait_time'].lower()
                continue

            # In order to know which regex (p3_1 or p4_1) should be used, we use p3_0 and p4_0 to determine which table
            # is currently parsed.
            m = p3_0.match(line)
            if m:
                active_table = 1
                continue

            m = p4_0.match(line)
            if m:
                active_table = 2
                continue

            #                                              H/W   Current
            # Switch#   Role    Mac Address     Priority Version  State
            # -----------------------------------------------------------
            # *1       Active   689c.e2ff.b9d9     3      V04     Ready
            #  2       Standby  689c.e2ff.b9d9     14             Ready
            m = p3_1.match(line)
            if m and active_table == 1:
                group = m.groupdict()
                stack = group['switch']
                match_dict = {k: v.lower()for k, v in group.items() if k in ['role', 'state']}
                match_dict.update({k: v for k, v in group.items() if k in ['priority', 'mac_address', 'hw_ver'] and v})
                ret_dict.setdefault('stack', {}).setdefault(stack, {}).update(match_dict)
                continue

            #          Stack Port Status             Neighbors
            # Switch#  Port 1     Port 2           Port 1   Port 2
            # --------------------------------------------------------
            #   1         OK         OK               3        2
            #   1       DOWN       DOWN             None     None
            m = p4_1.match(line)
            if m and active_table == 2:
                group = m.groupdict()
                stack = group['switch']
                stack_ports = ret_dict.setdefault('stack', {}).setdefault(stack, {}).setdefault('ports', {})
                for port in self.STACK_PORT_RANGE:
                    port_dict = stack_ports.setdefault(port, {})
                    port_dict['stack_port_status'] = group['status{}'.format(port)].lower()
                    nbr_num = group['nbr_num_{}'.format(port)]
                    port_dict['neighbors_num'] = int(nbr_num) if nbr_num.isdigit() else nbr_num
                continue

        return {'switch': ret_dict} if ret_dict else {}



class ShowSwitchSchema(MetaParser):
    """Schema for show switch"""
    schema = {
        'switch': {
            'mac_address': str,
            Optional('mac_persistency_wait_time'): str,
            'stack': {
                Any(): {
                    'role': str,
                    'mac_address': str,
                    'priority': str,
                    Optional('hw_ver'): str,
                    'state': str
                },
            }
        }
    }


class ShowSwitch(ShowSwitchSchema, ShowSwitchDetail):
    """Parser for show switch."""
    cli_command = 'show switch'


# ===================================================
# Schema for
#   * 'show env all'
#   * 'show env fan'
#   * 'show env power'
#   * 'show env power all'
#   * 'show env rps
#   * 'show env stack'
#   * 'show env temperature'
#   * 'show env temperature status'
#   * 'show environment all'
# ===================================================
class ShowEnvironmentSchema(MetaParser):
    """Schema for show environment all"""
    schema = {
        'switch': {
            Any(): {
                Optional('fan'): {
                    Any(): {
                        'state': str,
                        Optional('direction'): str,
                    },
                },
                Optional('power_supply'): {
                    Any(): {
                        Optional('state'): str,
                        Optional('pid'): str,
                        Optional('serial_number'): str,
                        Optional('status'): str,
                        Optional('system_power'): str,
                        Optional('poe_power'): str,
                        Optional('watts'): str,
                        Optional('temperature'): str,
                        Optional('power_source'): str,
                        Optional('type'): str,
                        Optional('mode'): str
                    }
                },
                Optional('system_temperature_state'): str,
                Optional('inlet_temperature'): {
                    'value': Or(int,str),
                    'state': str,
                    'yellow_threshold': str,
                    'red_threshold': str
                },
                Optional('hotspot_temperature'): {
                    'value': str,
                    'state': str,
                    'yellow_threshold': str,
                    'red_threshold': str
                },
                Optional('asic_temperature'): {
                    'value': str,
                    'state': str,
                    'yellow_threshold': str,
                    'red_threshold': str
                },
                Optional('outlet_temperature'): {
                    'value': str,
                    'state': str,
                    'yellow_threshold': str,
                    'red_threshold': str
                },
                Optional('system_temperature'): {
                    'value': str,
                    'state': str,
                    'yellow_threshold': str,
                    'red_threshold': str
                },
                Optional('redundant_power_system'): {
                    str: {
                        'status': str,
                        Optional('serial_num'): str,
                        Optional('port_num'): str,
                    }
                }
            },
        }

    }


# ===================================================
# Superparser for
#   * 'show env all'
#   * 'show env fan'
#   * 'show env power'
#   * 'show env power all'
#   * 'show env rps
#   * 'show env stack'
#   * 'show env temperature'
#   * 'show env temperature status'
#   * 'show environment all'
# ===================================================
class ShowEnvironmentSuperParser(ShowEnvironmentSchema):
    """Parser for show environment all"""
    PS_MAPPING = {'A': '1', 'B': '2'}

    def cli(self, output):

        # initial return dictionary
        ret_dict = {}

        # SWITCH: 1
        p0 = re.compile(r'^SWITCH: +(?P<switch>\d+)$')

        # Switch 1 FAN 1 is OK
        p1 = re.compile(r'^Switch\s+(?P<switch>\d+)\s+FAN\s+(?P<fan>\d+)\s+is\s+(?P<state>[\w\s]+)$')

        # Switch 1 FAN 1 direction is Front to Back
        p1_1 = re.compile(r'^Switch\s+(?P<switch>\d+)\s+FAN +(?P<fan>\d+)\s'
                          r'+direction\s+is\s+(?P<direction>[\w\s]+)$')

        p1_2 = re.compile(r'^(?P<switch>\d+)\s+(?P<fan>\d+)\s+\d+\s+(?P<state>.*)')

        # FAN PS-1 is NOT PRESENT
        # FAN PS-2 is OK
        p2 = re.compile(r'^FAN\s+PS\-(?P<ps>\d+)\s+is\s+(?P<state>[\w\s]+)$')

        # Switch 1: SYSTEM TEMPERATURE is OK
        # SYSTEM TEMPERATURE is OK
        p3 = re.compile(r'^(Switch\s+(?P<switch>\d+):\s+)?SYSTEM\s+TEMPERATURE\s+is\s+(?P<state>[\w\s]+)$')

        # Inlet Temperature Value: 34 Degree Celsius
        # Hotspot Temperature Value: 45 Degree Celsius
        # ASIC Temperature Value: 36 Degree Celsius
        # System Temperature Value: 41 Degree Celsius
        # Temperature Value: 28 Degree Celsius
        p4 = re.compile(r'^((?P<type>\w+)\s+)?Temperature\s+Value:\s+(?P<temperature>\d+)\s+Degree\s+Celsius$')

        # System Temperature State: GREEN
        # Temperature State: GREEN
        p5 = re.compile(r'^(System\s+)?Temperature\s+State:\s+(?P<state>\w+)$')


        # Yellow Threshold : 66 Degree Celsius
        # Red Threshold    : 76 Degree Celsius
        p6 = re.compile(r'^(?P<color>\w+)\s+Threshold\s*:\s+(?P<temperature>\d+)\s+Degree\s+Celsius$')

        # POWER SUPPLY 1A TEMPERATURE: OK
        # POWER SUPPLY 1B TEMPERATURE: Not Present
        p7 = re.compile(r'^POWER\s+SUPPLY\s+(?P<switch>\d+)(?P<power_supply>A|B)\s+'
                        r'TEMPERATURE:\s+(?P<temperature>[\w\s]+)$')

        # 1A  PWR-C1-715WAC       DCB1844G1ZY  OK              Good     Good     715
        # 1A  PWR-C2-1025WAC      DCB1636C003  OK              Good     Good     250/775
        # 1B  Not Present
        p8 = re.compile(r'^(?P<sw>\d+)(?P<ps>\w+)\s*'
                        r'((?P<pid>[\w\-]+)\s+'
                        r'(?P<serial_number>\w+)\s+)?'
                        r'(?P<status>(\w+|Not\sPresent|No\s+Input\s+Power))\s*'
                        r'((?P<system_power>\w+)\s+'
                        r'(?P<poe_power>[\w\/]+)\s+'
                        r'(?P<watts>[\w\/]+))?$')

        # 1   Not Present     <>
        p9 = re.compile(r'^(?P<switch>\d+)\s+(?P<status>\w+|Not\s+Present)\s+'
                         r'(?P<rps_name>\w+|<>)(\s+(?P<rps_serial_num>\w+)\s+'
                         r'(?P<rps_port_num>\w+))?$')

        #Gi1/1/1        Type3          60(w)     Available
        p10 = re.compile(r'^(?P<power_source>[\w./]+)\s+(?P<type>\w+)\s+(?P<watts>\S+)\(w\)\s+(?P<mode>\S+)')

        #A.C. Input     Auxilliary     150(w)    Available
        p11 = re.compile(r'^(?P<power_source>A.C. Input|\S+)\s+(?P<type>\w+)\s+(?P<watts>\S+)\(w\)\s+(?P<mode>\S+)')

        #Built-In                      310(w)
        p12 = re.compile(r'^(?P<power_source>A.C. Input|\S+)\s+(?P<watts>\S+)\(w\)')

        # set default value for switch
        switch = 1

        for line in output.splitlines():
            line = line.strip()

            # SWITCH: 1
            m = p0.match(line)
            if m:
                switch = m.groupdict()['switch']
                root_dict = ret_dict.setdefault('switch', {}).setdefault(switch, {})
                continue

            # Switch 1 FAN 1 is OK
            m = p1.match(line)
            if m:
                group = m.groupdict()
                switch = group['switch']
                fan = group['fan']
                root_dict = ret_dict.setdefault('switch', {}).setdefault(switch, {})
                root_dict.setdefault('fan', {}).setdefault(fan, {}).setdefault('state', group['state'].lower())
                continue

            # Switch 1 FAN 1 direction is Front to Back
            m = p1_1.match(line)
            if m:
                group = m.groupdict()
                switch = group['switch']
                fan = group['fan']
                fan_dict = ret_dict.setdefault('switch', {}).setdefault(switch, {})\
                                   .setdefault('fan', {}).setdefault(fan, {})
                fan_dict.update({'direction': group['direction'].lower()})
                continue

            m = p1_2.match(line)
            if m:
                group = m.groupdict()
                switch = group['switch']
                fan = group['fan']
                root_dict = ret_dict.setdefault('switch', {}).setdefault(switch, {})
                root_dict.setdefault('fan', {}).setdefault(fan, {}).setdefault('state', group['state'].lower())
                continue

            # FAN PS-1 is OK
            # FAN PS-1 is NOT PRESENT
            m = p2.match(line)
            if m:
                group = m.groupdict()
                ps = group['ps']
                power_supply_dict = root_dict.setdefault('power_supply', {}).setdefault(ps, {})
                power_supply_dict.setdefault('state', group['state'].lower())
                continue

            # Switch 1: SYSTEM TEMPERATURE is OK
            # SYSTEM TEMPERATURE is OK
            m = p3.match(line)
            if m:
                group = m.groupdict()
                if group['switch']:
                    switch = group['switch']
                root_dict = ret_dict.setdefault('switch', {}).setdefault(switch, {})
                root_dict['system_temperature_state'] = group['state'].lower()
                continue

            # Inlet Temperature Value: 34 Degree Celsius
            # Hotspot Temperature Value: 45 Degree Celsius
            # ASIC Temperature Value: 36 Degree Celsius
            # System Temperature Value: 41 Degree Celsius
            # Temperature Value: 28 Degree Celsius
            m = p4.match(line)
            if m:
                group = m.groupdict()
                if group['type']:
                    temp_type = group['type'].lower() + '_temperature'
                else:
                    temp_type = 'system_temperature'
                root_dict = ret_dict.setdefault('switch', {}).setdefault(str(switch), {})
                temp_dict = root_dict.setdefault(temp_type, {})
                temp_dict['value'] = group['temperature']
                continue

            # Temperature State: GREEN
            m = p5.match(line)
            if m:
                try:
                    temp_dict['state'] = m.groupdict()['state'].lower()
                except UnboundLocalError:
                    root_dict = ret_dict.setdefault('switch', {}).setdefault(str(switch), {})
                    temp_dict = root_dict.setdefault("system_temperature", {})
                    temp_dict['state'] = m.groupdict()['state'].lower()
                continue

            # Yellow Threshold : 46 Degree Celsius
            # Red Threshold    : 56 Degree Celsius
            m = p6.match(line)
            if m:
                group = m.groupdict()
                color_type = group['color'].lower() + '_threshold'
                temp_dict[color_type] = group['temperature']
                continue

            # POWER SUPPLY 1A TEMPERATURE: OK
            # POWER SUPPLY 1B TEMPERATURE: Not Present
            m = p7.match(line)
            if m:
                switch = m.groupdict()['switch']
                power_supply = self.PS_MAPPING[m.groupdict()['power_supply']]
                root_dict = ret_dict.setdefault('switch', {}).setdefault(switch, {})
                power_supply_dict = root_dict.setdefault('power_supply', {}).setdefault(power_supply, {})
                power_supply_dict.setdefault('temperature', m.groupdict()['temperature'].lower())
                continue


            # SW  PID                 Serial#     Status           Sys Pwr  PoE Pwr  Watts
            # --  ------------------  ----------  ---------------  -------  -------  -----
            # 1A  PWR-C1-715WAC       DCB1844G1ZY  OK              Good     Good     715
            # 1A  PWR-C2-1025WAC      DCB1636C003  OK              Good     Good     250/775
            # 1B  Not Present
            m = p8.match(line)
            if m:
                group = m.groupdict()
                switch = group.pop('sw')
                ps = self.PS_MAPPING[group.pop('ps')]
                root_dict = ret_dict.setdefault('switch', {}).setdefault(switch, {})
                power_supply_dict = root_dict.setdefault('power_supply', {}).setdefault(ps, {})
                power_supply_dict.update({k: v for k, v in group.items() if k in ['pid', 'serial_number', 'watts'] and v})
                power_supply_dict.update({k: v.lower() for k, v in group.items()
                     if k in ['status', 'system_power', 'poe_power'] and v})
                continue

            # SW  Status          RPS Name          RPS Serial#  RPS Port#
            # --  -------------   ----------------  -----------  ---------
            # 1   Not Present     <>
            m = p9.match(line)
            if m:
                group = m.groupdict()
                switch = group['switch']
                rps_name = group['rps_name']
                root_dict = ret_dict.setdefault('switch', {}).setdefault(switch, {})
                redundant_power_system_dict = root_dict.setdefault('redundant_power_system', {}).setdefault(rps_name, {})
                redundant_power_system_dict['status'] = group['status'].lower()
                if group['rps_serial_num']:
                    redundant_power_system_dict['rps_serial_num'] = group['rps_serial_num']
                if group['rps_port_num']:
                    redundant_power_system_dict['rps_port_num'] = group['rps_port_num']
                continue

            #Gi1/1/1        Type3          60(w)     Available
            m = p10.match(line)

            if m:
                group = m.groupdict()
                intf = Common.convert_intf_name(group.pop('power_source'))
                root_dict = ret_dict.setdefault('switch', {}).setdefault(switch, {})
                power_supply_dict = root_dict.setdefault('power_supply', {}).setdefault(intf, {})
                power_supply_dict["power_source"] =  intf
                power_supply_dict.update({k: v for k, v in group.items()})
                continue

            #A.C. Input     Auxilliary     150(w)    Available
            m = p11.match(line)
            if m:
                group = m.groupdict()
                root_dict = ret_dict.setdefault('switch', {}).setdefault(switch, {})
                power_supply_dict = root_dict.setdefault('power_supply', {}).setdefault(group['power_source'], {})
                power_supply_dict.update({k: v for k, v in group.items()})
                continue

            #Built-In                      310(w)
            m = p12.match(line)
            if m:
                group = m.groupdict()
                root_dict = ret_dict.setdefault('switch', {}).setdefault(switch, {})
                power_supply_dict = root_dict.setdefault('power_supply', {}).setdefault(group['power_source'], {})
                power_supply_dict.update({k: v for k, v in group.items()})
                continue
        return ret_dict


# ===================================================
# Parser for 'show environment all'
# ===================================================
class ShowEnvironmentAll(ShowEnvironmentSuperParser):
    """Parser for show environment all'
    """

    cli_command = 'show environment all'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        return super().cli(output=output)


# ===================================================
# Parser for 'show env all'
# ===================================================
class ShowEnvAll(ShowEnvironmentSuperParser):
    """Parser for show env all'
    """

    cli_command = 'show env all'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        return super().cli(output=output)

# ===================================================
# Parser for 'show env fan'
# ===================================================
class ShowEnvFan(ShowEnvironmentSuperParser):
    """Parser for show env fan"""

    cli_command = 'show env fan'

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        return super().cli(output=out)


# ===================================================
# Parser for 'show env power'
# ===================================================
class ShowEnvPower(ShowEnvironmentSuperParser):
    """Parser for show env power"""

    cli_command = 'show env power'

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        return super().cli(output=out)


# ===================================================
# Parser for 'show env power all'
# ===================================================
class ShowEnvPowerAll(ShowEnvironmentSuperParser):
    """Parser for show env power all"""

    cli_command = 'show env power all'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        return super().cli(output=output)


# ===================================================
# Parser for 'show env rps'
# ===================================================
class ShowEnvRPS(ShowEnvironmentSuperParser):
    """Parser for show env rps"""

    cli_command = 'show env rps'

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        return super().cli(output=out)


# ===================================================
# Parser for 'show env stack'
# ===================================================
class ShowEnvStack(ShowEnvironmentSuperParser):
    """Parser for show env stack"""

    cli_command = 'show env stack'

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        return super().cli(output=out)


# ===================================================
# Parser for 'show env temperature'
# ===================================================
class ShowEnvTemperature(ShowEnvironmentSuperParser):
    """Parser for show env temperature"""

    cli_command = 'show env temperature'

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        return super().cli(output=out)


# ===================================================
# Parser for 'show env temperature status'
# ===================================================
class ShowEnvTemperatureStatus(ShowEnvironmentSuperParser):
    """Parser for show env temperature status"""

    cli_command = 'show env temperature status'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        return super().cli(output=output)


class ShowModuleSchema(MetaParser):
    """Schema for show module"""
    schema = {
        Optional('switch'): {
            Any(): {
                'port': str,
                'model': str,
                'serial_number': str,
                'mac_address': str,
                'hw_ver': str,
                'sw_ver': str
            },
        },
        Optional('module'):{
            int:{
                'ports':int,
                'card_type':str,
                'model':str,
                'serial':str,
                'mac_address':str,
                'hw':str,
                'fw':str,
                'sw':str,
                'status':str,
                Optional('redundancy_role'):str,
                Optional('operating_redundancy_mode'):str,
                Optional('configured_redundancy_mode'):str,
            },
        },
        Optional('number_of_mac_address'):int,
        Optional('chassis_mac_address_lower_range'):str,
        Optional('chassis_mac_address_upper_range'):str,
        Optional('switches'):{
            int:{
                Optional('module'):{
                    int:{
                        'ports':int,
                        'card_type':str,
                        'model':str,
                        'serial':str,
                        'mac_address':str,
                        'hw':str,
                        'fw':str,
                        'sw':str,
                        'status':str,
                        Optional('redundancy_role'):str,
                        Optional('operating_redundancy_mode'):str,
                        Optional('configured_redundancy_mode'):str
                    },
                },
            },
        },
        Optional('chassis'): {
            int:{
                'number_of_mac_address':int,
                'chassis_mac_address_lower_range':str,
                'chassis_mac_address_upper_range':str,
            },
        },
    }


class ShowModule(ShowModuleSchema):
    """Parser for show module"""

    cli_command = 'show module'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        # initial return dictionary
        ret_dict = {}
        switch_flag = False

        # initial regexp pattern
        p1 = re.compile(r'^(?P<switch>\d+) *'
                        '(?P<port>\w+) +'
                        '(?P<model>[\w\-]+) +'
                        '(?P<serial_number>\w+) +'
                        '(?P<mac_address>[\w\.]+) +'
                        '(?P<hw_ver>\w+) +'
                        '(?P<sw_ver>[\w\.]+)$')

        # Chassis Type: C9500X-28C8D

        # Mod Ports Card Type                                   Model          Serial No.
        # ---+-----+--------------------------------------+--------------+--------------
        # 1   38   Cisco Catalyst 9500X-28C8D Switch           C9500X-28C8D     FDO25030SLN

        p2=re.compile(r'^(?P<mod>\d+) *(?P<ports>\d+) +(?P<card_type>.*) +(?P<model>\S+) +(?P<serial>\S+)$')

        # Mod MAC addresses                    Hw   Fw           Sw                 Status
        # ---+--------------------------------+----+------------+------------------+--------
        # 1   F87A.4125.1400 to F87A.4125.147D 0.2  17.7.0.41     BLD_POLARIS_DEV_LA ok

        p3=re.compile(r'^(?P<mod>\d+) *(?P<mac_address>[\w\.]+) .*(?P<hw>\d+.?\d+?) +(?P<fw>\S+) +(?P<sw>\S+) +(?P<status>\S+)$')

        # Mod Redundancy Role     Operating Redundancy Mode Configured Redundancy Mode
        # ---+-------------------+-------------------------+---------------------------
        # 1   Active              non-redundant             Non-redundant

        p4=re.compile(r'^(?P<mod>\d+) *(?P<redundancy_role>\S+) *(?P<operating_redundancy_mode>\S+) *(?P<configured_redundancy_mode>\S+)$')

        # Chassis MAC address range: 512 addresses from f87a.4125.1400 to f87a.4125.15ff
        p5=re.compile(r'^Chassis MAC address range: (?P<number_of_mac_address>\d+) addresses from (?P<chassis_mac_address_lower_range>.*) to (?P<chassis_mac_address_upper_range>.*)$')

        # Switch Number 1
        p6 = re.compile(r'^Switch\s+Number\s+(?P<switch_number>\d+)$')

        # Chassis 1 MAC address range: 512 addresses from 40b5.c1ff.ee00 to 40b5.c1ff.efff
        p7=re.compile(r'^Chassis\s*(?P<chassis>\d+)\s*MAC address range: (?P<number_of_mac_address>\d+) addresses from (?P<chassis_mac_address_lower_range>.*) to (?P<chassis_mac_address_upper_range>.*)$')


        for line in output.splitlines():
            line = line.strip()

            # Switch  Ports    Model                Serial No.   MAC address     Hw Ver.       Sw Ver.
            # ------  -----   ---------             -----------  --------------  -------       --------
            #  1       56     WS-C3850-48P-E        FOC1902X062  689c.e2ff.b9d9  V04           16.9.1
            m = p1.match(line)
            if m:
                group = m.groupdict()
                switch = group.pop('switch')
                switch_dict = ret_dict.setdefault('switch', {}).setdefault(switch, {})
                switch_dict.update({k: v.lower() for k, v in group.items()})
                continue

            # Switch Number 1
            m = p6.match(line)
            if m:
                group = m.groupdict()
                switch_dict = ret_dict.setdefault('switches', {}).setdefault(int(group['switch_number']), {})
                switch_flag=True


            # Chassis Type: C9500X-28C8D

            # Mod Ports Card Type                                   Model          Serial No.
            # ---+-----+--------------------------------------+--------------+--------------
            # 1   38   Cisco Catalyst 9500X-28C8D Switch           C9500X-28C8D     FDO25030SLN
            m = p2.match(line)
            if m:
                group = m.groupdict()
                switch = group.pop('mod')
                if switch_flag:
                    switch_dict=switch_dict.setdefault('module', {}).setdefault(int(switch), {})
                else:
                    switch_dict = ret_dict.setdefault('module', {}).setdefault(int(switch), {})
                switch_dict.update({k: v.strip() for k, v in group.items()})
                switch_dict['ports']=int(group['ports'])
                continue

            # Mod MAC addresses                    Hw   Fw           Sw                 Status
            # ---+--------------------------------+----+------------+------------------+--------
            # 1   F87A.4125.1400 to F87A.4125.147D 0.2  17.7.0.41     BLD_POLARIS_DEV_LA ok

            m=p3.match(line)
            if m:
                group = m.groupdict()
                switch = group.pop('mod')
                if switch_flag:
                    pass
                else:
                    switch_dict = ret_dict.setdefault('module', {}).setdefault(int(switch), {})
                switch_dict.update({k: v.strip() for k, v in group.items()})
                continue

            # Mod Redundancy Role     Operating Redundancy Mode Configured Redundancy Mode
            # ---+-------------------+-------------------------+---------------------------
            # 1   Active              non-redundant             Non-redundant
            m=p4.match(line)
            if m:
                group = m.groupdict()
                switch = group.pop('mod')
                if switch_flag:
                    pass
                else:
                    switch_dict = ret_dict.setdefault('module', {}).setdefault(int(switch), {})
                switch_dict.update({k: v.lower().strip() for k, v in group.items()})
                continue

            #Chassis MAC address range: 512 addresses from f87a.4125.1400 to f87a.4125.15ff
            m=p5.match(line)
            if m:
                group=m.groupdict()
                ret_dict.update({k: v.lower().strip() for k, v in group.items()})
                ret_dict['number_of_mac_address'] = int(group['number_of_mac_address'])
                continue

            # Chassis MAC address range: 512 addresses from f87a.4125.1400 to f87a.4125.15ff
            m=p7.match(line)
            if m:
                group=m.groupdict()
                if switch_flag:
                    chassis_dict = ret_dict.setdefault('chassis', {}).setdefault(int(group['chassis']), {})
                    chassis_dict['number_of_mac_address'] = int(group['number_of_mac_address'])
                    chassis_dict['chassis_mac_address_lower_range'] = group['chassis_mac_address_lower_range']
                    chassis_dict['chassis_mac_address_upper_range'] = group['chassis_mac_address_upper_range']

                continue

        return ret_dict


class ShowPlatformSoftwareSlotActiveMonitorMemSchema(MetaParser):
    """Schema for show platform software process slot switch active R0 monitor | inc Mem :|Swap:"""
    schema = {
        'memory': {
            'total': int,
            'free': int,
            'used': int,
            'buff_cache': int
        },
        'swap': {
            'total': int,
            'free': int,
            'used': int,
            'available_memory': int
        }
    }


class ShowPlatformSoftwareSlotActiveMonitorMem(ShowPlatformSoftwareSlotActiveMonitorMemSchema):
    """Parser for show platform software process slot switch active R0 monitor | inc Mem :|Swap:"""

    cli_command = 'show platform software process slot switch active R0 monitor | inc Mem :|Swap:'

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # initial regexp pattern
        p1 = re.compile(r'^KiB +Mem *: +(?P<total>\d+) *total, +'
                        '(?P<free>\d+) *free, +(?P<used>\d+) *used, +'
                        '(?P<buff_cache>\d+) *buff\/cache$')

        p2 = re.compile(r'^KiB +Swap *: +(?P<total>\d+) *total, +'
                        '(?P<free>\d+) *free, +(?P<used>\d+) *used. +'
                        '(?P<available_memory>\d+) *avail +Mem$')

        for line in out.splitlines():
            line = line.strip()

            # KiB Mem :  4010000 total,    16756 free,  1531160 used,  2462084 buff/cache
            m = p1.match(line)
            if m:
                group = m.groupdict()
                name_dict = ret_dict.setdefault('memory', {})
                name_dict.update({k: int(v) for k, v in group.items()})
                continue

            # KiB Swap:        0 total,        0 free,        0 used.  1778776 avail Mem
            m = p2.match(line)
            if m:
                group = m.groupdict()
                name_dict = ret_dict.setdefault('swap', {})
                name_dict.update({k: int(v) for k, v in group.items()})
                continue
        return ret_dict


class ShowPlatformSoftwareStatusControlSchema(MetaParser):
    """Schema for show platform software status control-processor brief"""
    schema = {
        'slot': {
            Any(): {
                'load_average': {
                    'status': str,
                    '1_min': float,
                    '5_min': float,
                    '15_min': float,
                },
                'memory': {
                    'status': str,
                    'total': int,
                    'used': int,
                    'used_percentage': int,
                    'free': int,
                    'free_percentage': int,
                    'committed': int,
                    'committed_percentage': int,
                },
                'cpu': {
                    Any(): {
                        'user': float,
                        'system': float,
                        'nice_process': float,
                        'idle': float,
                        'irq': float,
                        'sirq': float,
                        'waiting': float
                    }
                }
            }
        }
    }


class ShowPlatformSoftwareStatusControl(ShowPlatformSoftwareStatusControlSchema):
    """Parser for show platform software status control-processor brief"""

    cli_command = 'show platform software status control-processor brief'
    exclude = ['idle', 'system', 'user', '1_min', '5_min',
               '15_min', 'free', 'used', 'sirq', 'waiting', 'committed']

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # initial regexp pattern
        p1 = re.compile(r'^(?P<slot>\S+) +(?P<status>\w+) +'
                        '(?P<min1>[\d\.]+) +(?P<min5>[\d\.]+) +(?P<min15>[\d\.]+)$')

        p2 = re.compile(r'^(?P<slot>\S+) +(?P<status>\w+) +'
                        '(?P<total>\d+) +(?P<used>\d+) +\((?P<used_percentage>[\d\s]+)\%\) +'
                        '(?P<free>\d+) +\((?P<free_percentage>[\d\s]+)\%\) +'
                        '(?P<committed>\d+) +\((?P<committed_percentage>[\d\s]+)\%\)$')

        p3 = re.compile(r'^((?P<slot>\S+) +)?(?P<cpu>\d+) +(?P<user>[\d\.]+) +(?P<system>[\d\.]+) +(?P<nice_process>[\d\.]+) +(?P<idle>[\d\.]+) +(?P<irq>[\d\.]+) +(?P<sirq>[\d\.]+) +(?P<waiting>[\d\.]+)$')

        for line in out.splitlines():
            line = line.strip()

            # Slot  Status  1-Min  5-Min 15-Min
            # 1-RP0 Healthy   0.26   0.35   0.33
            m = p1.match(line)
            if m:
                group = m.groupdict()
                slot = group.pop('slot').lower()
                load_dict = ret_dict.setdefault('slot', {}).setdefault(slot, {}).setdefault('load_average', {})
                load_dict['status'] = group['status'].lower()
                load_dict['1_min'] = float(group['min1'])
                load_dict['5_min'] = float(group['min5'])
                load_dict['15_min'] = float(group['min15'])
                continue

            # Slot  Status    Total     Used (Pct)     Free (Pct) Committed (Pct)
            # 1-RP0 Healthy  4010000  2553084 (64%)  1456916 (36%)   3536536 (88%)
            m = p2.match(line)
            if m:
                group = m.groupdict()
                slot = group.pop('slot').lower()
                mem_dict = ret_dict.setdefault('slot', {}).setdefault(slot, {}).setdefault('memory', {})
                mem_dict['status'] = group.pop('status').lower()
                mem_dict.update({k: int(v) for k, v in group.items()})
                continue

            #  Slot  CPU   User System   Nice   Idle    IRQ   SIRQ IOwait
            # 1-RP0    0   3.89   2.09   0.00  93.80   0.00   0.19   0.00
            #          1   5.70   1.00   0.00  93.20   0.00   0.10   0.00
            m = p3.match(line)
            if m:
                group = m.groupdict()
                if group['slot']:
                    slot = group.pop('slot').lower()
                else:
                    group.pop('slot')
                cpu = group.pop('cpu')
                cpu_dict = ret_dict.setdefault('slot', {}).setdefault(slot, {}).\
                    setdefault('cpu', {}).setdefault(cpu, {})
                cpu_dict.update({k: float(v) for k, v in group.items()})
                continue
        return ret_dict


class ShowProcessesCpuSortedSchema(MetaParser):
    """Schema for show processes cpu sorted
                  show processes cpu sorted <1min|5min|5sec>
                  show processes cpu sorted | include <WORD>
                  show processes cpu sorted | exclude <WORD>
                  show processes cpu sorted <1min|5min|5sec> | include <WORD>
                  show processes cpu sorted <1min|5min|5sec> | exclude <WORD>"""

    schema = {
        Optional('five_sec_cpu_interrupts'): int,
        Optional('five_sec_cpu_total'): int,
        Optional('one_min_cpu'): int,
        Optional('five_min_cpu'): int,
        Optional('zero_cpu_processes'): list,
        Optional('nonzero_cpu_processes'): list,
        Optional('sort'): {
            Any(): {
                'runtime': int,
                'invoked': int,
                'usecs': int,
                'five_sec_cpu': float,
                'one_min_cpu': float,
                'five_min_cpu': float,
                'tty': int,
                'pid': int,
                'process': str
            }
        }
    }


class ShowProcessesCpuSorted(ShowProcessesCpuSortedSchema):
    """Parser for show processes cpu sorted
                  show processes cpu sorted {sort_time}
                  show processes cpu sorted | include {key_word}
                  show processes cpu sorted | exclude {exclude}
                  show processes cpu sorted {sort_time} | include {key_word}
                  show processes cpu sorted {sort_time} | exclude {exclude}"""

    cli_command = [
        'show processes cpu sorted',
        'show processes cpu sorted {sort_time}',
        'show processes cpu sorted | include {key_word}',
        'show processes cpu sorted | exclude {exclude}',
        'show processes cpu sorted {sort_time} | include {key_word}',
        'show processes cpu sorted {sort_time} | exclude {exclude}'
    ]

    exclude = ['five_min_cpu', 'five_sec_cpu_total', 'nonzero_cpu_processes', 'zero_cpu_processes',
               'five_sec_cpu', 'invoked', 'one_min_cpu', 'runtime', 'usecs', 'pid', 'process', ]

    def cli(self, sort_time='', key_word='', exclude='', cmd='', output=None):

        assert sort_time in ['1min', '5min', '5sec', ''], "Not one from 1min 5min 5sec"
        if output is None:
            if not cmd:
                if sort_time and key_word:
                    cmd = self.cli_command[4].format(sort_time=sort_time, key_word=key_word)
                elif sort_time and exclude:
                    cmd = self.cli_command[5].format(sort_time=sort_time, exclude=exclude)
                elif exclude:
                    cmd = self.cli_command[3].format(exclude=exclude)
                elif key_word:
                    cmd = self.cli_command[2].format(key_word=key_word)
                elif sort_time:
                    cmd = self.cli_command[1].format(sort_time=sort_time)
                else:
                    cmd = self.cli_command[0]

            out = self.device.execute(cmd)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}
        zero_cpu_processes = []
        nonzero_cpu_processes = []
        index = 0

        # initial regexp pattern
        p1 = re.compile(r'^CPU +utilization +for +five +seconds: +'
                        '(?P<five_sec_cpu_total>\d+)\%\/(?P<five_sec_cpu_interrupts>\d+)\%;'
                        ' +one +minute: +(?P<one_min_cpu>\d+)\%;'
                        ' +five +minutes: +(?P<five_min_cpu>\d+)\%$')

        p2 = re.compile(r'^(?P<pid>\d+) +(?P<runtime>\d+) +(?P<invoked>\d+) +(?P<usecs>\d+) +'
                        '(?P<five_sec_cpu>[\d\.]+)\% +(?P<one_min_cpu>[\d\.]+)\% +'
                        '(?P<five_min_cpu>[\d\.]+)\% +(?P<tty>\d+) +'
                        '(?P<process>[\w\-\/\s]+)$')

        for line in out.splitlines():
            line = line.strip()

            # CPU utilization for five seconds: 5%/1%; one minute: 6%; five minutes: 6%
            m = p1.match(line)
            if m:
                ret_dict.update({k: int(v) for k, v in m.groupdict().items()})
                continue

            # PID Runtime(ms)     Invoked      uSecs   5Sec   1Min   5Min TTY Process
            # 539     6061647    89951558         67  0.31%  0.36%  0.38%   0 HSRP Common
            m = p2.match(line)
            if m:
                group = m.groupdict()
                index += 1
                sort_dict = ret_dict.setdefault('sort', {}).setdefault(index, {})
                sort_dict['process'] = group['process']
                sort_dict.update({k: int(v) for k, v in group.items()
                                  if k in ['runtime', 'invoked', 'usecs', 'tty', 'pid']})
                sort_dict.update({k: float(v) for k, v in group.items()
                                  if k in ['five_sec_cpu', 'one_min_cpu', 'five_min_cpu']})
                if float(group['five_sec_cpu']) or \
                   float(group['one_min_cpu']) or \
                   float(group['five_min_cpu']):
                    nonzero_cpu_processes.append(group['process'])
                else:
                    zero_cpu_processes.append(group['process'])
                continue

        ret_dict.setdefault('zero_cpu_processes',
                            zero_cpu_processes) if zero_cpu_processes else None
        ret_dict.setdefault('nonzero_cpu_processes',
                            nonzero_cpu_processes) if nonzero_cpu_processes else None
        return ret_dict


class ShowProcessesCpuPlatformSchema(MetaParser):
    """Schema for show processes cpu platform"""
    schema = {
        'cpu_utilization': {
            'cpu_util_five_secs': str,
            'cpu_util_one_min': str,
            'cpu_util_five_min': str,
            Optional('core'): {
                Any(): {
                    'core_cpu_util_five_secs': str,
                    'core_cpu_util_one_min': str,
                    'core_cpu_util_five_min': str,
                },
            }
        },
        'pid': {
            Any(): {
                'ppid': int,
                'five_sec': str,
                'one_min': str,
                'five_min': str,
                'status': str,
                'size': int,
                'name': str,
            },
        }
    }


class ShowProcessesCpuPlatform(ShowProcessesCpuPlatformSchema):
    """Parser for show processes cpu platform"""

    cli_command = 'show processes cpu platform'
    exclude = ['five_min_cpu', 'nonzero_cpu_processes', 'zero_cpu_processes', 'invoked',
               'runtime', 'usecs', 'five_sec_cpu', 'one_min_cpu']

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # initial regexp pattern

        # CPU utilization for five seconds: 43%, one minute: 44%, five minutes: 44%
        p1 = re.compile(r'^CPU +utilization +for +five +seconds: +(?P<cpu_util_five_secs>[\d\%]+),'
                        ' +one +minute: +(?P<cpu_util_one_min>[\d\%]+),'
                        ' +five +minutes: +(?P<cpu_util_five_min>[\d\%]+)$')

        # Core 0: CPU utilization for five seconds:  6%, one minute: 11%, five minutes: 11%
        p2 = re.compile(r'^(?P<core>[\w\s]+): +CPU +utilization +for'
                        ' +five +seconds: +(?P<core_cpu_util_five_secs>\d+\%+),'
                        ' +one +minute: +(?P<core_cpu_util_one_min>[\d+\%]+),'
                        ' +five +minutes: +(?P<core_cpu_util_five_min>[\d+\%]+)$')

        # 21188   21176    599%    600%    599%  R           478632  ucode_pkt_PPE0
        p3 = re.compile(r'^(?P<pid>\d+) +(?P<ppid>\d+)'
                        ' +(?P<five_sec>[\d\%]+) +(?P<one_min>[\d\%]+)'
                        ' +(?P<five_min>[\d\%]+) +(?P<status>[\w]+)'
                        ' +(?P<size>\d+) +(?P<name>.*)$')

        for line in out.splitlines():
            line = line.strip()

            # CPU utilization for five seconds:  2%, one minute:  5%, five minutes: 22%
            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict.setdefault('cpu_utilization', {})
                ret_dict['cpu_utilization'].update({k: str(v) for k, v in group.items()})
                continue

            # Core 0: CPU utilization for five seconds:  2%, one minute:  8%, five minutes: 18%
            m = p2.match(line)
            if m:
                group = m.groupdict()
                core = group.pop('core')
                if 'cpu_utilization' not in ret_dict:
                    ret_dict.setdefault('cpu_utilization', {})
                ret_dict['cpu_utilization'].setdefault('core', {}).setdefault(core, {})
                ret_dict['cpu_utilization']['core'][core].update({k: str(v) for k, v in group.items()})
                continue

            #    Pid    PPid    5Sec    1Min    5Min  Status        Size  Name
            # --------------------------------------------------------------------------------
            #      1       0      0%      0%      0%  S          1863680  init
            #      2       0      0%      0%      0%  S                0  kthreadd
            #      3       2      0%      0%      0%  S                0  migration/0
            m = p3.match(line)
            if m:
                group = m.groupdict()
                pid = group['pid']
                ret_dict.setdefault('pid', {}).setdefault(pid, {})
                ret_dict['pid'][pid]['ppid'] = int(group['ppid'])
                ret_dict['pid'][pid]['five_sec'] = group['five_sec']
                ret_dict['pid'][pid]['one_min'] = group['one_min']
                ret_dict['pid'][pid]['five_min'] = group['five_min']
                ret_dict['pid'][pid]['status'] = group['status']
                ret_dict['pid'][pid]['size'] = int(group['size'])
                ret_dict['pid'][pid]['name'] = group['name']
                continue

        return ret_dict


class ShowEnvironmentSchema(MetaParser):
    """Schema for show environment
                  show environment | include {include} """

    schema = {
        Optional('critical_larams'): int,
        Optional('major_alarms'): int,
        Optional('minor_alarms'): int,
        'slot': {
            Any(): {
                'sensor': {
                    Any(): {
                        'state': str,
                        'reading': str,
                        Optional('threshold'): {
                            'minor': int,
                            'major': int,
                            'critical': int,
                            'shutdown': int,
                            'celsius' : bool
                        },
                    },
                }
            },
        }
    }


class ShowEnvironment(ShowEnvironmentSchema):
    """Parser for show environment
                  show environment | include {include} """

    cli_command = ['show environment', 'show environment | include {include}']

    def cli(self, include='', output=None):
        if output is None:
            if include:
                cmd = self.cli_command[1].format(include=include)
            else:
                cmd = self.cli_command[0]
            out = self.device.execute(cmd)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # Number of Critical alarms:  0
        p1 = re.compile(r'^Number +of +Critical +alarms: +(?P<critic_larams>\d+)$')

        # Number of Major alarms:     0
        p2 = re.compile(r'^Number +of +Major +alarms: +(?P<maj_alarms>\d+)$')

        # Number of Minor alarms:     0
        p3 = re.compile(r'^Number +of +Minor +alarms: +(?P<min_alarms>\d+)$')

        # Slot    Sensor       Current State       Reading          Threshold(Minor,Major,Critical,Shutdown)
        # ----    ------       -------------       -------          ---------------------------------------
        #  F0    Temp: Pop Die    Normal           43 Celsius
        #  P6    Temp: FC PWM1    Fan Speed 60%    26 Celsius
        #  P0    Iin              Normal           1 A
        #  P0    Vin              Normal           101 V AC
        #  R0    Temp: SCBY AIR   Normal           45 Celsius
        #  R0    3570DB2 _0: VO   Normal          1201 mV
        #  R1    V2: VMD          Normal           991 mV
        #  R0          3570MB2_0: VOU  Normal          1000 mV            na
        #  R0          Temp: Outlet_A  Normal          34   Celsius       (55 ,60 ,65 ,75 )(Celsius)
        #  R0          Temp: UADP_0_4  Normal          45   Celsius       (105,110,120,124)(Celsius)
        p4 = re.compile(r'^(?P<slot>\S+) +(?P<sensor_name>.+?)\s+(?P<state>Normal|Fan +Speed +\d+%)\s+(?P<reading>\d+\s*\S+\s*?\S*?)(\s*?(?P<threshold>na|\([\d,\s]+\)(\(Celsius\))?))?$')

        for line in out.splitlines():
            line = line.strip()
            # Number of Critical alarms:  0
            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict['critical_larams'] = int(group['critic_larams'])
                continue

            # Number of Major alarms:     0
            m = p2.match(line)
            if m:
                group = m.groupdict()
                ret_dict['major_alarms'] = int(group['maj_alarms'])
                continue

            # Number of Minor alarms:     0
            m = p3.match(line)
            if m:
                group = m.groupdict()
                ret_dict['minor_alarms'] = int(group['min_alarms'])
                continue

            # Slot    Sensor       Current State       Reading          Threshold(Minor,Major,Critical,Shutdown)
            # ----    ------       -------------       -------          ---------------------------------------
            #  F0    Temp: Pop Die    Normal           43 Celsius
            #  P6    Temp: FC PWM1    Fan Speed 60%    26 Celsius
            #  P0    Iin              Normal           1 A
            #  P0    Vin              Normal           101 V AC
            #  R0    Temp: SCBY AIR   Normal           45 Celsius
            #  R0    3570DB2 _0: VO   Normal          1201 mV
            #  R1    V2: VMD          Normal           991 mV
            #  R0          3570MB2_0: VOU  Normal          1000 mV            na
            #  R0          Temp: Outlet_A  Normal          34   Celsius       (55 ,60 ,65 ,75 )(Celsius)
            #  R0          Temp: UADP_0_4  Normal          45   Celsius       (105,110,120,124)(Celsius)
            m = p4.match(line)
            if m:
                group = m.groupdict()
                sensor_name = group.pop('sensor_name')
                slot = group.pop('slot')

                threshold = group.pop('threshold') if group.get('threshold') else None
                if not threshold:
                    del group['threshold']

                fin_dict = ret_dict.setdefault('slot', {}).setdefault(slot, {}).\
                    setdefault('sensor', {}).setdefault(sensor_name, {})
                fin_dict.update({k: str(v) for k, v in group.items()})

                if threshold and threshold != 'na':

                    threshold_dict = fin_dict.setdefault('threshold', {})

                    if threshold.endswith('(Celsius)'):
                        threshold_dict['celsius'] = True
                        threshold = threshold[:-9]

                    threshold_names = ['minor', 'major','critical', 'shutdown']
                    for threshold_name, threshold_value in zip(threshold_names, threshold.strip('()').split(',')):
                        threshold_dict[threshold_name] = int(threshold_value.strip())


        return ret_dict



class ShowProcessesCpu(ShowProcessesCpuSorted):
    """Parser for show processes cpu
                  show processes cpu | include <WORD>"""

    cli_command = 'show processes cpu'

    def cli(self, key_word='', output=None):
        return(super().cli(key_word=key_word, output=output))


class ShowVersionRpSchema(MetaParser):
    """Schema for show version RP active [running|provisioned|installed]
                  show version RP standby [running|provisioned|installed]"""

    schema = {
        'rp': {
            Optional('active'): {
                'slot': {
                    Any(): {
                        'package': {
                            Any(): {
                                'version': str,
                                'status': str,
                                'file': str,
                                'built_time': str,
                                'built_by': str,
                                'file_sha1_checksum': str,
                            },
                        }
                    },
                }
            },
            Optional('standby'): {
                'slot': {
                    Any(): {
                        'package': {
                            Any(): {
                                'version': str,
                                'status': str,
                                'file': str,
                                'built_time': str,
                                'built_by': str,
                                'file_sha1_checksum': str,
                            },
                        }
                    },
                }
            }
        }
    }


class ShowVersionRp(ShowVersionRpSchema):
    """Parser for show version RP active [running|provisioned|installed]
                  show version RP standby [running|provisioned|installed]"""

    cli_command = ['show version RP {rp} {status}']
    exclude = ['total_enqs_bytes', 'total_enqs_packets']

    def cli(self, rp='active', status='running', output=None):

        if output is None:
            cmd = self.cli_command[0].format(rp=rp, status=status)
            out = self.device.execute(cmd)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}
        package_name = ''
        rp_slot = ''
        built_time = ''

        # Package: rpbase, version: 03.16.04a.S.155-3.S4a-ext, status: active
        # Package: Provisioning File, version: n/a, status: active
        p1 = re.compile(r'^Package: +(?P<package_name>[\w\d\s]+),'
                        ' +version: +(?P<version>[\w\d\.\-\/]+),'
                        ' +status: +(?P<status>[\w\/]+)$')

        #   File: consolidated:asr1000rp2-rpbase.03.16.04a.S.155-3.S4a-ext.pkg, on: RP0
        p2 = re.compile(r'^File: +consolidated:(?P<file>[\w\d\-\.]+),'
                        ' +on: +(?P<rp_slot>[\w\d\/]+)$')

        # Built: 2016-10-04_12.28, by: mcpre
        # Built: n/a, by: n/a
        p3 = re.compile(r'^Built: +(?P<built_time>[\w\d\:\.\_\/\-]+),'
                        ' +by: +(?P<built_by>[\w\d\/]+)$')

        #   File SHA1 checksum: 79e234871520fd480dc1128058160b4e2acee9f7
        p4 = re.compile(r'^File +SHA1 +checksum:'
                        ' +(?P<file_sha1_checksum>[\w\d]+)$')

        for line in out.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                package_name = group['package_name']
                version = group['version']
                status = group['status']
                continue

            m = p2.match(line)
            if m:
                group = m.groupdict()
                file = group['file']
                rp_slot = group['rp_slot']

                # Safer, return empty dictionary instead of an error
                if not package_name:
                    return ret_dict
                elif 'rp' not in ret_dict:
                    ret_dict.setdefault('rp', {})

                if rp not in ret_dict['rp']:
                    ret_dict['rp'].setdefault(rp, {})
                if 'slot' not in ret_dict['rp'][rp]:
                    ret_dict['rp'][rp].setdefault('slot', {})
                if rp_slot not in ret_dict['rp'][rp]['slot']:
                    ret_dict['rp'][rp]['slot'].setdefault(rp_slot, {})
                if 'package' not in ret_dict['rp'][rp]['slot'][rp_slot]:
                    ret_dict['rp'][rp]['slot'][rp_slot].setdefault('package', {})

                ret_dict['rp'][rp]['slot'][rp_slot]['package'].setdefault(package_name, {})
                ret_dict['rp'][rp]['slot'][rp_slot]['package'][package_name]['version'] = version
                ret_dict['rp'][rp]['slot'][rp_slot]['package'][package_name]['status'] = status
                ret_dict['rp'][rp]['slot'][rp_slot]['package'][package_name]['file'] = file
                continue

            m = p3.match(line)
            if m:
                # Safer, return empty dictionary instead of an error
                if not package_name or not rp_slot:
                    return ret_dict

                group = m.groupdict()
                built_time = group['built_time']

                ret_dict['rp'][rp]['slot'][rp_slot]['package'][package_name]['built_time'] = built_time
                ret_dict['rp'][rp]['slot'][rp_slot]['package'][package_name]['built_by'] = group['built_by']
                continue

            m = p4.match(line)
            if m:
                # Safer, return empty dictionary instead of an error
                if not package_name or not rp_slot:
                    return ret_dict
                group = m.groupdict()
                ret_dict['rp'][rp]['slot'][rp_slot]['package'][package_name]['file_sha1_checksum'] = group['file_sha1_checksum']
                continue

        return ret_dict


class ShowPlatformHardwareSchema(MetaParser):
    """Schema for show platform hardware qfp active infrastructure bqs queue output default all
        show platform hardware qfp active infrastructure bqs queue output default interface {interface}"""

    schema = {
        Any(): {
            'if_h': int,
            Optional('index'): {
                Any(): {
                    'queue_id': str,
                    'name': str,
                    'software_control_info': {
                        'cache_queue_id': str,
                        'wred': str,
                        Optional('qlimit_bytes'): int,
                        Optional('qlimit_pkts'): int,
                        'parent_sid': str,
                        'debug_name': str,
                        'sw_flags': str,
                        'sw_state': str,
                        'port_uidb': int,
                        'orig_min': int,
                        'min': int,
                        'min_qos': int,
                        'min_dflt': int,
                        'orig_max': int,
                        'max': int,
                        'max_qos': int,
                        'max_dflt': int,
                        'share': int,
                        'plevel': int,
                        'priority': int,
                        Optional('defer_obj_refcnt'): int,
                        Optional('cp_ppe_addr'): str,
                    },
                    'statistics': {
                        'tail_drops_bytes': int,
                        'tail_drops_packets': int,
                        'total_enqs_bytes': int,
                        'total_enqs_packets': int,
                        Optional('queue_depth_bytes'): int,
                        Optional('queue_depth_pkts'): int,
                        Optional('lic_throughput_oversub_drops_bytes'): int,
                        Optional('lic_throughput_oversub_drops_packets'): int,
                    }
                },
            }
        },
    }


class ShowPlatformHardware(ShowPlatformHardwareSchema):
    """Parser for show platform hardware qfp active infrastructure bqs queue output default all
        show platform hardware qfp active infrastructure bqs queue output default interface {interface}"""

    cli_command = ['show platform hardware qfp active infrastructure bqs queue output default all',
                   'show platform hardware qfp active infrastructure bqs queue output default interface {interface}']

    def cli(self, interface='', output=None):

        if output is None:
            if interface:
                cmd = self.cli_command[1].format(interface=interface)
            else:
                cmd = self.cli_command[0]
            out = self.device.execute(cmd)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # Interface: GigabitEthernet1/0/7 QFP: 0.0 if_h: 32 Num Queues/Schedules: 1
        # Interface: Loopback2 QFP: 0.0 if_h: 34 Num Queues/Schedules: 0
        # Interface: GigabitEthernet0/0/1.2 QFP: 0.0 if_h: 35 Num Queues/Schedules: 0
        # Interface: GigabitEthernet0/0/1.EFP2054 QFP: 0.0 if_h: 36 Num Queues/Schedules: 0
        # Interface: BG4048.10207e1 QFP: 0.0 if_h: 4079 Num Queues/Schedules: 0
        # Interface: VPLS-2944.10207e2 QFP: 0.0 if_h: 4080 Num Queues/Schedules:
        # Interface: internal0/0/recycle:0 QFP: 0.0 if_h: 1 Num Queues/Schedules: 0
        p1 = re.compile(r'^Interface: +(?P<intf_name>[\w\d\/\.\-\:]+)'
                        ' +QFP: +(?P<qfp>[\d\.]+)'
                        ' +if_h: +(?P<if_h>\d+)'
                        ' +Num Queues/Schedules: +(?P<num_queues>\d+)$')

        #     Index 0 (Queue ID:0xa6, Name: GigabitEthernet1/0/7)
        p2 = re.compile(r'^Index +(?P<index>\d+)'
                        ' +\(Queue +ID:(?P<queue_id>[\w\d]+),'
                        ' +Name: +(?P<interf_name>[\w\d\/\.\-\:]+)\)$')

        #       Software Control Info:
        #  PARQ Software Control Info:
        p3_1 = re.compile(r'^(PARQ +)?Software Control Info:$')

        #  (cache) queue id: 0x000000a6, wred: 0x88b16ac2, qlimit (bytes): 3281312
        #  (cache) queue id: 0x00000070, wred: 0xe73cfde0, qlimit (pkts ): 418
        p3_2 = re.compile(r'^\(cache\) +queue +id: +(?P<cache_queue_id>[\w\d]+),'
                          ' +wred: +(?P<wred>[\w\d]+),'
                          ' +qlimit +\((?P<type>bytes|pkts +)\): +(?P<qlimit>\d+)$')

        #       parent_sid: 0x284, debug_name: GigabitEthernet1/0/7
        p4 = re.compile(r'^parent_sid: +(?P<parent_sid>[\w\d]+),'
                        ' debug_name: +(?P<debug_name>[\w\d\/\.\-\:]+)$')

        #       sw_flags: 0x08000011, sw_state: 0x00000c01, port_uidb: 245728
        p5 = re.compile(r'^sw_flags: +(?P<sw_flags>[\w\d]+),'
                        ' +sw_state: +(?P<sw_state>[\w\d]+),'
                        ' +port_uidb: +(?P<port_uidb>\d+)$')

        #       orig_min  : 0                   ,      min: 105000000
        p6 = re.compile(r'^orig_min +: +(?P<orig_min>\d+) +,'
                        ' +min: +(?P<min>\d+)$')

        #       min_qos   : 0                   , min_dflt: 0
        p7 = re.compile(r'^min_qos +: +(?P<min_qos>\d+) +,'
                        ' +min_dflt: +(?P<min_dflt>\d+)$')

        #       orig_max  : 0                   ,      max: 0
        p8 = re.compile(r'^orig_max +: +(?P<orig_max>\d+) +,'
                        ' +max: +(?P<max>\d+)$')

        #       max_qos   : 0                   , max_dflt: 0
        p9 = re.compile(r'^max_qos +: +(?P<max_qos>\d+) +,'
                        ' +max_dflt: +(?P<max_dflt>\d+)$')

        #       share     : 1
        p10 = re.compile(r'^share +: +(?P<share>\d+)$')

        #       plevel    : 0, priority: 65535
        p11 = re.compile(r'^plevel +: +(?P<plevel>\d+),'
                         ' +priority: +(?P<priority>\d+)$')

        #       defer_obj_refcnt: 0
        #   defer_obj_refcnt: 0, cp_ppe_addr: 0x00000000
        p12 = re.compile(r'^defer_obj_refcnt: +(?P<defer_obj_refcnt>\d+)'
                         r'(, +cp_ppe_addr: +(?P<cp_ppe_addr>\w+))?$')

        #     Statistics:
        p13_1 = re.compile(r'^Statistics:$')

        #       tail drops  (bytes): 0                   ,          (packets): 0
        p13_2 = re.compile(r'^tail +drops +\(bytes\): +(?P<tail_drops_bytes>\d+) +,'
                           ' +\(packets\): +(?P<tail_drops_packets>\d+)$')

        #       total enqs  (bytes): 0                   ,          (packets): 0
        p14 = re.compile(r'^total +enqs +\(bytes\): +(?P<total_enqs_bytes>\d+) +,'
                         ' +\(packets\): +(?P<total_enqs_packets>\d+)$')

        #       queue_depth (bytes): 0
        #       queue_depth (pkts ): 0
        p15 = re.compile(r'^queue_depth +\((?P<type>bytes|pkts +)\): +(?P<queue_depth>\d+)$')

        #       licensed throughput oversubscription drops:
        #                   (bytes): 0                   ,          (packets): 0
        p16 = re.compile(r'^\(bytes\): +(?P<lic_throughput_oversub_drops_bytes>\d+) +,'
                         ' +\(packets\): +(?P<lic_throughput_oversub_drops_packets>\d+)$')

        for line in out.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                interface = group['intf_name']
                ret_dict.setdefault(interface, {})
                ret_dict[interface]['if_h'] = int(group['if_h'])
                continue

            m = p2.match(line)
            if m:
                group = m.groupdict()
                index = group['index']
                if 'index' not in ret_dict[interface]:
                    ret_dict[interface].setdefault('index', {})
                ret_dict[interface]['index'].setdefault(index, {})
                ret_dict[interface]['index'][index]['queue_id'] = \
                    group['queue_id']
                ret_dict[interface]['index'][index]['name'] = \
                    group['interf_name']
                continue

            m = p3_1.match(line)
            if m:
                ret_dict[interface]['index'][index].setdefault('software_control_info', {})
                continue

            m = p3_2.match(line)
            if m:
                group = m.groupdict()
                ret_dict[interface]['index'][index]['software_control_info']['cache_queue_id'] = group['cache_queue_id']
                ret_dict[interface]['index'][index]['software_control_info']['wred'] = group['wred']
                if group['type'].strip() == 'bytes':
                    ret_dict[interface]['index'][index]['software_control_info']['qlimit_bytes'] = int(group['qlimit'])
                else:
                    ret_dict[interface]['index'][index]['software_control_info']['qlimit_pkts'] = int(group['qlimit'])
                continue

            m = p4.match(line)
            if m:
                group = m.groupdict()
                ret_dict[interface]['index'][index]['software_control_info'].\
                    update({k: v for k, v in group.items()})
                continue

            m = p5.match(line)
            if m:
                group = m.groupdict()
                ret_dict[interface]['index'][index]['software_control_info']['sw_flags'] = group['sw_flags']
                ret_dict[interface]['index'][index]['software_control_info']['sw_state'] = group['sw_state']
                ret_dict[interface]['index'][index]['software_control_info']['port_uidb'] = int(group['port_uidb'])
                continue

            m = p6.match(line)
            if m:
                group = m.groupdict()
                ret_dict[interface]['index'][index]['software_control_info'].\
                    update({k: int(v) for k, v in group.items()})
                continue

            m = p7.match(line)
            if m:
                group = m.groupdict()
                ret_dict[interface]['index'][index]['software_control_info'].\
                    update({k: int(v) for k, v in group.items()})
                continue

            m = p8.match(line)
            if m:
                group = m.groupdict()
                ret_dict[interface]['index'][index]['software_control_info'].\
                    update({k: int(v) for k, v in group.items()})
                continue

            m = p9.match(line)
            if m:
                group = m.groupdict()
                ret_dict[interface]['index'][index]['software_control_info'].\
                    update({k: int(v) for k, v in group.items()})
                continue

            m = p10.match(line)
            if m:
                group = m.groupdict()
                ret_dict[interface]['index'][index]['software_control_info']['share'] = int(group['share'])
                continue

            m = p11.match(line)
            if m:
                group = m.groupdict()
                ret_dict[interface]['index'][index]['software_control_info'].\
                    update({k: int(v) for k, v in group.items()})
                continue

            m = p12.match(line)
            if m:
                group = m.groupdict()
                ret_dict[interface]['index'][index]['software_control_info']['defer_obj_refcnt'] = int(group['defer_obj_refcnt'])

                if group['cp_ppe_addr']:
                    ret_dict[interface]['index'][index]['software_control_info']['cp_ppe_addr'] = group['cp_ppe_addr']
                continue

            m = p13_1.match(line)
            if m:
                ret_dict[interface]['index'][index].setdefault('statistics', {})
                continue

            m = p13_2.match(line)
            if m:
                group = m.groupdict()
                ret_dict[interface]['index'][index]['statistics'].update({k: int(v) for k, v in group.items()})
                continue

            m = p14.match(line)
            if m:
                group = m.groupdict()
                ret_dict[interface]['index'][index]['statistics'].update({k: int(v) for k, v in group.items()})
                continue

            m = p15.match(line)
            if m:
                group = m.groupdict()
                if group['type'].strip() == 'bytes':
                    ret_dict[interface]['index'][index]['statistics']['queue_depth_bytes'] = int(group['queue_depth'])
                else:
                    ret_dict[interface]['index'][index]['statistics']['queue_depth_pkts'] = int(group['queue_depth'])
                continue

            m = p16.match(line)
            if m:
                group = m.groupdict()
                ret_dict[interface]['index'][index]['statistics'].update({k: int(v) for k, v in group.items()})
                continue

        return ret_dict


class ShowPlatformHardwarePlimSchema(MetaParser):
    """Schema for show platform hardware port <x/x/x> plim statistics
                  show platform hardware slot <x> plim statistics
                  show platform hardware slot <x> plim statistics internal
                  show platform hardware subslot <x/x> plim statistics"""

    schema = {
        Optional('port'): {
            Any(): {
                'received': {
                    'low_priority': {
                        'pkts': int,
                        'dropped_pkts': int,
                        'errored_pkts': int,
                        'bytes': int,
                        'dropped_bytes': int,
                        'errored_bytes': int,
                    },
                    'high_priority': {
                        'pkts': int,
                        'dropped_pkts': int,
                        'errored_pkts': int,
                        'bytes': int,
                        'dropped_bytes': int,
                        'errored_bytes': int,
                    }
                },
                'transmitted': {
                    'low_priority': {
                        'pkts': int,
                        'dropped_pkts': int,
                        'bytes': int,
                        'dropped_bytes': int,
                    },
                    'high_priority': {
                        'pkts': int,
                        'dropped_pkts': int,
                        'bytes': int,
                        'dropped_bytes': int,
                    }
                },
            },
        },
        Optional('slot'): {
            Any(): {
                'subslot': {
                    Any(): {
                        'name': str,
                        'status': str,
                        'received': {
                            Optional('pkts'): int,
                            Optional('ipc_pkts'): int,
                            Optional('bytes'): int,
                            Optional('ipc_bytes'): int,
                            Optional('ipc_err'): int,
                            Optional('spi4_interrupt_counters'): {
                                'out_of_frame': int,
                                'dip4_error': int,
                                'disabled': int,
                                'loss_of_sync': int,
                                'sequence_error': int,
                                'burst_error': int,
                                'eop_abort': int,
                                'packet_gap_error': int,
                                'control_word_error': int,
                            }
                        },
                        'transmitted': {
                            Optional('pkts'): int,
                            Optional('ipc_pkts'): int,
                            Optional('bytes'): int,
                            Optional('ipc_bytes'): int,
                            Optional('ipc_err'): int,
                            Optional('spi4_interrupt_counters'): {
                                'out_of_frame': int,
                                'frame_error': int,
                                'fifo_over_flow': int,
                                'dip2_error': int,
                            }
                        }
                    },
                }
            },
        }
    }


class ShowPlatformHardwarePlim(ShowPlatformHardwarePlimSchema):
    """Parser for show platform hardware port <x/x/x> plim statistics
                  show platform hardware slot <x> plim statistics
                  show platform hardware slot <x> plim statistics internal
                  show platform hardware subslot <x/x> plim statistics"""

    cli_command = ['show platform hardware port {port} plim statistics',
                   'show platform hardware slot {slot} plim statistics',
                   'show platform hardware slot {slot} plim statistics internal',
                   'show platform hardware subslot {subslot} plim statistics']

    def cli(self, port=None, slot=None, subslot=None, internal=False, output=None):

        if output is None:
            if port:
                cmd = self.cli_command[0].format(port=port)
            elif slot:
                if internal:
                    cmd = self.cli_command[2].format(slot=slot)
                else:
                    cmd = self.cli_command[1].format(slot=slot)
            elif subslot:
                cmd = self.cli_command[3].format(subslot=subslot)
            out = self.device.execute(cmd)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # Interface 0/0/0
        p1 = re.compile(r'^Interface +(?P<port>[\d\/]+)$')

        #   RX Low Priority
        #   RX High Priority
        p2 = re.compile(r'^RX +(?P<direction>\w+) +Priority$')

        #     RX Pkts      369         Bytes 27789
        p3 = re.compile(r'^RX +Pkts +(?P<rx_total_pkts>\d+) +Bytes +(?P<rx_total_bytes>\d+)$')

        #     RX Drop Pkts 0           Bytes 0
        p4 = re.compile(r'^RX +Drop +Pkts +(?P<rx_dropped_pkts>\d+) +Bytes +(?P<rx_dropped_bytes>\d+)$')

        #     RX Err  Pkts 0           Bytes 0
        p5 = re.compile(r'^RX +Err +Pkts +(?P<rx_errored_pkts>\d+) +Bytes +(?P<rx_errored_bytes>\d+)$')

        #   TX Low Priority
        #   TX High Priority
        p6 = re.compile(r'^TX +(?P<direction>\w+) +Priority$')

        #     TX Pkts      1265574622  Bytes 250735325722
        p7 = re.compile(r'^TX +Pkts +(?P<tx_total_pkts>\d+) +Bytes +(?P<tx_total_bytes>\d+)$')

        #     TX Drop Pkts 0           Bytes 0
        p8 = re.compile(r'^TX +Drop +Pkts +(?P<tx_dropped_pkts>\d+) +Bytes +(?P<tx_dropped_bytes>\d+)$')

        # 0/3, SPA-1XTENGE-XFP-V2, Online
        p9 = re.compile(r'^(?P<slot>\d+)/(?P<subslot>\d+),'
                        ' +(?P<name>[\w\d\-]+),'
                        ' +(?P<status>\w+)$')

        #   RX IPC Pkts 0           Bytes 0
        p10 = re.compile(r'^RX +IPC +Pkts +(?P<rx_ipc_pkts>\d+) +Bytes +(?P<rx_ipc_bytes>\d+)$')

        #   TX IPC Pkts 0           Bytes 0
        p11 = re.compile(r'^TX +IPC +Pkts +(?P<tx_ipc_pkts>\d+) +Bytes +(?P<tx_ipc_bytes>\d+)$')

        #   RX IPC Err 0
        p12 = re.compile(r'^RX +IPC +Err +(?P<rx_ipc_err>\d+)$')

        #   TX IPC Err 0
        p13 = re.compile(r'^TX +IPC +Err +(?P<tx_ipc_err>\d+)$')

        #   RX Spi4 Interrupt Counters
        #   TX Spi4 Interrupt Counters
        p14 = re.compile(r'^(?P<tx_rx>\w+) +Spi4 +Interrupt +Counters$')

        #     Out Of Frame 0
        p15 = re.compile(r'^Out +Of +Frame +(?P<out_of_frame>\d+)$')

        #     Dip4 Error 0
        p16 = re.compile(r'^Dip4 +Error +(?P<rx_dip4_error>\d+)$')

        #     Disabled 0
        p17 = re.compile(r'^Disabled +(?P<rx_disbaled>\d+)$')

        #     Loss Of Sync 0
        p18 = re.compile(r'^Loss +Of +Sync +(?P<rx_loss_of_sync>\d+)$')

        #     Sequence Error 0
        p19 = re.compile(r'^Sequence +Error +(?P<rx_sequence_error>\d+)$')

        #     Burst Error 0
        p20 = re.compile(r'^Burst +Error +(?P<rx_burst_error>\d+)$')

        #     EOP Abort 0
        p21 = re.compile(r'^EOP +Abort +(?P<rx_eop_abort>\d+)$')

        #     Packet Gap Error 0
        p22 = re.compile(r'^Packet +Gap +Error +(?P<rx_packet_gap_error>\d+)$')

        #     Control Word Error 0
        p23 = re.compile(r'^Control +Word +Error +(?P<rx_control_word_error>\d+)$')

        #     Frame Error 0
        p24 = re.compile(r'^Frame +Error +(?P<tx_frame_error>\d+)$')

        #     FIFO Over Flow 0
        p25 = re.compile(r'^FIFO +Over +Flow +(?P<tx_fifo_over_flow>\d+)$')

        #     Dip2 Error 0
        p26 = re.compile(r'^Dip2 +Error +(?P<tx_dip2_error>\d+)$')

        for line in out.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                port = group['port']
                ret_dict.setdefault('port', {}).setdefault(port, {})
                continue

            m = p2.match(line)
            if m:
                group = m.groupdict()
                direction = group['direction']
                if 'received' not in ret_dict['port'][port]:
                    ret_dict['port'][port].setdefault('received', {})
                if direction == 'Low':
                    low_high = 'low_priority'
                else:
                    low_high = 'high_priority'
                ret_dict['port'][port]['received'].setdefault(low_high, {})
                continue

            m = p3.match(line)
            if m:
                group = m.groupdict()
                if 'port' in ret_dict:
                    ret_dict['port'][port]['received'][low_high]['pkts'] = int(group['rx_total_pkts'])
                    ret_dict['port'][port]['received'][low_high]['bytes'] = int(group['rx_total_bytes'])
                else:
                    if 'received' not in ret_dict['slot'][slot]['subslot'][subslot]:
                        ret_dict['slot'][slot]['subslot'][subslot].\
                            setdefault('received', {})
                    ret_dict['slot'][slot]['subslot'][subslot]['received']['pkts'] = int(group['rx_total_pkts'])
                    ret_dict['slot'][slot]['subslot'][subslot]['received']['bytes'] = int(group['rx_total_bytes'])
                continue

            m = p4.match(line)
            if m:
                group = m.groupdict()
                ret_dict['port'][port]['received'][low_high]['dropped_pkts'] = int(group['rx_dropped_pkts'])
                ret_dict['port'][port]['received'][low_high]['dropped_bytes'] = int(group['rx_dropped_bytes'])
                continue

            m = p5.match(line)
            if m:
                group = m.groupdict()
                ret_dict['port'][port]['received'][low_high]['errored_pkts'] = int(group['rx_errored_pkts'])
                ret_dict['port'][port]['received'][low_high]['errored_bytes'] = int(group['rx_errored_bytes'])
                continue

            m = p6.match(line)
            if m:
                group = m.groupdict()
                direction = group['direction']
                if 'transmitted' not in ret_dict['port'][port]:
                    ret_dict['port'][port].setdefault('transmitted', {})
                if direction == 'Low':
                    low_high = 'low_priority'
                else:
                    low_high = 'high_priority'
                ret_dict['port'][port]['transmitted'].setdefault(low_high, {})
                continue

            m = p7.match(line)
            if m:
                group = m.groupdict()
                if 'port' in ret_dict:
                    ret_dict['port'][port]['transmitted'][low_high]['pkts'] = int(group['tx_total_pkts'])
                    ret_dict['port'][port]['transmitted'][low_high]['bytes'] = int(group['tx_total_bytes'])
                else:
                    if 'transmitted' not in ret_dict['slot'][slot]['subslot'][subslot]:
                        ret_dict['slot'][slot]['subslot'][subslot].setdefault('transmitted', {})
                    ret_dict['slot'][slot]['subslot'][subslot]['transmitted']['pkts'] = int(group['tx_total_pkts'])
                    ret_dict['slot'][slot]['subslot'][subslot]['transmitted']['bytes'] = int(group['tx_total_bytes'])
                continue

            m = p8.match(line)
            if m:
                group = m.groupdict()
                ret_dict['port'][port]['transmitted'][low_high]['dropped_pkts'] = int(group['tx_dropped_pkts'])
                ret_dict['port'][port]['transmitted'][low_high]['dropped_bytes'] = int(group['tx_dropped_bytes'])
                continue

            m = p9.match(line)
            if m:
                group = m.groupdict()
                slot = group['slot']
                subslot = group['subslot']
                ret_dict.setdefault('slot', {}).setdefault(slot, {})
                if 'subslot' not in ret_dict['slot'][slot]:
                    ret_dict['slot'][slot].setdefault('subslot', {})
                ret_dict['slot'][slot]['subslot'].setdefault(subslot, {})
                ret_dict['slot'][slot]['subslot'][subslot]['name'] = \
                    group['name']
                ret_dict['slot'][slot]['subslot'][subslot]['status'] = \
                    group['status']
                continue

            m = p10.match(line)
            if m:
                group = m.groupdict()
                if 'received' not in ret_dict['slot'][slot]['subslot'][subslot]:
                    ret_dict['slot'][slot]['subslot'][subslot].setdefault('received', {})
                ret_dict['slot'][slot]['subslot'][subslot]['received']['ipc_pkts'] = int(group['rx_ipc_pkts'])
                ret_dict['slot'][slot]['subslot'][subslot]['received']['ipc_bytes'] = int(group['rx_ipc_bytes'])
                continue

            m = p11.match(line)
            if m:
                group = m.groupdict()
                if 'transmitted' not in ret_dict['slot'][slot]['subslot'][subslot]:
                    ret_dict['slot'][slot]['subslot'][subslot].setdefault('transmitted', {})
                ret_dict['slot'][slot]['subslot'][subslot]['transmitted']['ipc_pkts'] = int(group['tx_ipc_pkts'])
                ret_dict['slot'][slot]['subslot'][subslot]['transmitted']['ipc_bytes'] = int(group['tx_ipc_bytes'])
                continue

            m = p12.match(line)
            if m:
                group = m.groupdict()
                ret_dict['slot'][slot]['subslot'][subslot].setdefault('received', {})
                ret_dict['slot'][slot]['subslot'][subslot]['received']['ipc_err'] = int(group['rx_ipc_err'])
                continue

            m = p13.match(line)
            if m:
                group = m.groupdict()
                ret_dict['slot'][slot]['subslot'][subslot].setdefault('transmitted', {})
                ret_dict['slot'][slot]['subslot'][subslot]['transmitted']['ipc_err'] = int(group['tx_ipc_err'])
                continue

            m = p14.match(line)
            if m:
                group = m.groupdict()
                tx_rx_direction = group['tx_rx']
                if tx_rx_direction == 'RX':
                    new_direction = 'received'
                else:
                    new_direction = 'transmitted'
                ret_dict['slot'][slot]['subslot'][subslot][new_direction].\
                    setdefault('spi4_interrupt_counters', {})
                continue

            m = p15.match(line)
            if m:
                group = m.groupdict()
                ret_dict['slot'][slot]['subslot'][subslot][new_direction]['spi4_interrupt_counters']['out_of_frame'] = int(group['out_of_frame'])
                continue

            m = p16.match(line)
            if m:
                group = m.groupdict()
                ret_dict['slot'][slot]['subslot'][subslot][new_direction]['spi4_interrupt_counters']['dip4_error'] = int(group['rx_dip4_error'])
                continue

            m = p17.match(line)
            if m:
                group = m.groupdict()
                ret_dict['slot'][slot]['subslot'][subslot][new_direction]['spi4_interrupt_counters']['disabled'] = int(group['rx_disbaled'])
                continue

            m = p18.match(line)
            if m:
                group = m.groupdict()
                ret_dict['slot'][slot]['subslot'][subslot][new_direction]['spi4_interrupt_counters']['loss_of_sync'] = int(group['rx_loss_of_sync'])
                continue

            m = p19.match(line)
            if m:
                group = m.groupdict()
                ret_dict['slot'][slot]['subslot'][subslot][new_direction]['spi4_interrupt_counters']['sequence_error'] = int(group['rx_sequence_error'])
                continue

            m = p20.match(line)
            if m:
                group = m.groupdict()
                ret_dict['slot'][slot]['subslot'][subslot][new_direction]['spi4_interrupt_counters']['burst_error'] = int(group['rx_burst_error'])
                continue

            m = p21.match(line)
            if m:
                group = m.groupdict()
                ret_dict['slot'][slot]['subslot'][subslot][new_direction]['spi4_interrupt_counters']['eop_abort'] = int(group['rx_eop_abort'])
                continue

            m = p22.match(line)
            if m:
                group = m.groupdict()
                ret_dict['slot'][slot]['subslot'][subslot][new_direction]['spi4_interrupt_counters']['packet_gap_error'] = int(group['rx_packet_gap_error'])
                continue

            m = p23.match(line)
            if m:
                group = m.groupdict()
                ret_dict['slot'][slot]['subslot'][subslot][new_direction]['spi4_interrupt_counters']['control_word_error'] = int(group['rx_control_word_error'])
                continue

            m = p24.match(line)
            if m:
                group = m.groupdict()
                ret_dict['slot'][slot]['subslot'][subslot][new_direction]['spi4_interrupt_counters']['frame_error'] = int(group['tx_frame_error'])
                continue

            m = p25.match(line)
            if m:
                group = m.groupdict()
                ret_dict['slot'][slot]['subslot'][subslot][new_direction]['spi4_interrupt_counters']['fifo_over_flow'] = int(group['tx_fifo_over_flow'])
                continue

            m = p26.match(line)
            if m:
                group = m.groupdict()
                ret_dict['slot'][slot]['subslot'][subslot][new_direction]['spi4_interrupt_counters']['dip2_error'] = int(group['tx_dip2_error'])
                continue

        return ret_dict


class ShowPlatformHardwareQfpBqsMappingSchema(MetaParser):
    """Schema for show platform hardware qfp active bqs <x> ipm mapping
                  show platform hardware qfp standby bqs <x> ipm mapping
                  show platform hardware qfp active bqs <x> opm mapping
                  show platform hardware qfp standby bqs <x> opm mapping"""

    schema = {
        'channel': {
            Any(): {
                Optional('interface'): str,
                'name': str,
                Optional('logical_channel'): int,
                Optional('drain_mode'): bool,
                Optional('port'): int,
                Optional('cfifo'): int,
            },
        }
    }


class ShowPlatformHardwareQfpBqsOpmMapping(ShowPlatformHardwareQfpBqsMappingSchema):
    """Parser for show platform hardware qfp active bqs <x> opm mapping
                  show platform hardware qfp standby bqs <x> opm mapping"""

    cli_command = 'show platform hardware qfp {status} bqs {slot} opm mapping'

    def cli(self, status, slot, output=None):

        if output is None:
            cmd = self.cli_command.format(status=status, slot=slot)
            out = self.device.execute(cmd)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # Chan     Name                          Interface      LogicalChannel
        #  0       CC0 Low                       SPI0            0
        # 24       Peer-FP Low                   SPI0           24
        # 26       Nitrox Low                    SPI0           26
        # 28       HT Pkt Low                    HT              0
        # 38       HighNormal                    GPM             7
        # 55*      Drain Low                     GPM             0
        # * - indicates the drain mode bit is set for this channel
        p1 = re.compile(r'^(?P<number>\d+)(?P<drained>\*)? +(?P<name>[\w\-\s]+)'
                        ' +(?P<interface>[\w\d]+) +(?P<logical_channel>\d+)$')

        # 32       Unmapped
        p2 = re.compile(r'^(?P<unmapped_number>\d+) +Unmapped$')

        for line in out.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                interface = group['interface']
                number = group['number']
                if group['drained']:
                    drained = True
                else:
                    drained = False
                if 'channel' not in ret_dict:
                    final_dict = ret_dict.setdefault('channel', {})
                final_dict = ret_dict['channel'].setdefault(number, {})
                final_dict.update({'interface': group['interface'].strip()})
                final_dict.update({'name': group['name'].strip()})
                final_dict.update({'logical_channel': int(group['logical_channel'])})
                final_dict.update({'drain_mode': drained})
                continue

            m = p2.match(line)
            if m:
                group = m.groupdict()
                unmapped_number = group['unmapped_number']
                if 'channel' not in ret_dict:
                    ret_dict.setdefault('channel', {})
                ret_dict['channel'].setdefault(unmapped_number, {})
                ret_dict['channel'][unmapped_number].update({'name': 'unmapped'})
                continue

        return ret_dict


class ShowPlatformHardwareQfpBqsIpmMapping(ShowPlatformHardwareQfpBqsMappingSchema):
    """Parser for show platform hardware qfp active bqs <x> ipm mapping
                  show platform hardware qfp standby bqs <x> ipm mapping"""

    cli_command = 'show platform hardware qfp {status} bqs {slot} ipm mapping'

    def cli(self, status, slot, output=None):

        if output is None:
            cmd = self.cli_command.format(status=status, slot=slot)
            out = self.device.execute(cmd)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # Chan   Name                Interface      Port     CFIFO
        #  1     CC3 Low             SPI0           0        1
        # 13     Peer-FP Low         SPI0          12        3
        # 15     Nitrox Low          SPI0          14        1
        # 17     HT Pkt Low          HT             0        1
        # 21     CC4 Low             SPI0          16        1
        p1 = re.compile(r'^(?P<number>\d+) +(?P<name>[\w\-\s]+)'
                        ' +(?P<interface>[\w\d]+) +(?P<port>\d+)'
                        ' +(?P<cfifo>\d+)$')

        # 32       Unmapped
        p2 = re.compile(r'^(?P<unmapped_number>\d+) +Unmapped$')

        for line in out.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                number = group['number']
                final_dict = ret_dict.setdefault(
                    'channel', {}).setdefault(number, {})
                final_dict.update({'interface': group['interface'].strip()})
                final_dict.update({'name': group['name'].strip()})
                final_dict.update({'port': int(group['port'])})
                final_dict.update({'cfifo': int(group['cfifo'])})
                continue

            m = p2.match(line)
            if m:
                group = m.groupdict()
                unmapped_number = group['unmapped_number']
                if 'channel' not in ret_dict:
                    ret_dict.setdefault('channel', {})
                ret_dict['channel'].setdefault(unmapped_number, {})
                ret_dict['channel'][unmapped_number].update({'name': 'unmapped'})
                continue

        return ret_dict


class ShowPlatformHardwareSerdesSchema(MetaParser):
    """Schema for show platform hardware slot <x> serdes statistics
                  show platform hardware slot <x> serdes statistics internal"""

    schema = {
        'link': {
            Any(): {
                Optional('from'): {
                    'pkts': {
                        Optional('total'): int,
                        Optional('high'): int,
                        Optional('low'): int,
                        Optional('dropped'): int,
                        Optional('errored'): int,
                        Optional('looped'): int,
                        Optional('bad'): int,
                    },
                    'bytes': {
                        Optional('total'): int,
                        Optional('high'): int,
                        Optional('low'): int,
                        Optional('dropped'): int,
                        Optional('errored'): int,
                        Optional('looped'): int,
                        Optional('bad'): int,
                    },
                    Optional('qstat_count'): int,
                    Optional('flow_ctrl_count'): int,
                },
                Optional('to'): {
                    'pkts': {
                        Optional('total'): int,
                        Optional('high'): int,
                        Optional('low'): int,
                        Optional('dropped'): int,
                        Optional('errored'): int,
                    },
                    Optional('bytes'): {
                        Optional('total'): int,
                        Optional('high'): int,
                        Optional('low'): int,
                        Optional('dropped'): int,
                        Optional('errored'): int,
                    }
                },
                Optional('local_tx_in_sync'): bool,
                Optional('local_rx_in_sync'): bool,
                Optional('remote_tx_in_sync'): bool,
                Optional('remote_rx_in_sync'): bool,
                Optional('errors'): {
                    'rx_process': int,
                    'rx_schedule': int,
                    'rx_statistics': int,
                    'rx_parity': int,
                    'tx_process': int,
                    'tx_schedule': int,
                    'tx_statistics': int,
                },
            },
        },
        Optional('serdes_exception_counts'): {
            Any(): {
                Optional('link'): {
                    Any(): {
                        'msgTypeError': int,
                        'msgEccError': int,
                        'chicoEvent': int,
                    },
                }
            },
        }
    }


class ShowPlatformHardwareSerdes(ShowPlatformHardwareSerdesSchema):
    """Parser for show platform hardware slot <x> serdes statistics"""

    cli_command = 'show platform hardware slot {slot} serdes statistics'

    def cli(self, slot, output=None):

        if output is None:
            cmd = self.cli_command.format(slot=slot)
            out = self.device.execute(cmd)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # From Slot 1-Link B
        p1 = re.compile(r'^From +Slot +(?P<link>[\w\d\-\s]+)$')

        #   Pkts  High: 0          Low: 0          Bad: 0          Dropped: 0
        p2 = re.compile(r'^Pkts +High: +(?P<high>\d+) +Low: +(?P<low>\d+)( +Bad: +(?P<bad>\d+) +Dropped: +(?P<dropped>\d+))?$')

        #   Bytes High: 0          Low: 0          Bad: 0          Dropped: 0
        p3 = re.compile(r'^Bytes +High: +(?P<high>\d+) +Low: +(?P<low>\d+) +Bad: +(?P<bad>\d+) +Dropped: +(?P<dropped>\d+)$')

        #   Pkts  Looped: 0          Error: 0
        p4 = re.compile(r'^Pkts +Looped: +(?P<looped>\d+) +Error: +(?P<errored>\d+)$')

        #   Bytes Looped 0
        p5 = re.compile(r'^Bytes +Looped +(?P<looped>\d+)$')

        #   Qstat count: 0          Flow ctrl count: 3501
        p6 = re.compile(r'^Qstat +count: +(?P<qstat_count>\d+) +Flow +ctrl +count: +(?P<flow_ctrl_count>\d+)$')

        for line in out.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                slot = group['link']
                from_dict = ret_dict.setdefault('link', {}).setdefault(slot, {}).setdefault('from', {})
                continue

            m = p2.match(line)
            if m:
                group = m.groupdict()
                if not group['bad']:
                    to_dict = ret_dict['link'][slot].setdefault('to', {}).setdefault('pkts', {})
                    to_dict.update({k: int(v) for k, v in group.items() if v})
                    continue

                pkts_dict = ret_dict['link'][slot]['from'].setdefault('pkts', {})
                pkts_dict.update({k: int(v) for k, v in group.items()})
                continue

            m = p3.match(line)
            if m:
                group = m.groupdict()
                bytes_dict = ret_dict['link'][slot]['from'].setdefault('bytes', {})
                bytes_dict.update({k: int(v) for k, v in group.items()})
                continue

            m = p4.match(line)
            if m:
                group = m.groupdict()
                pkts_dict.update({k: int(v) for k, v in group.items()})
                continue

            m = p5.match(line)
            if m:
                group = m.groupdict()
                bytes_dict.update({k: int(v) for k, v in group.items()})
                continue

            m = p6.match(line)
            if m:
                group = m.groupdict()
                from_dict.update({k: int(v) for k, v in group.items()})
                continue

        return ret_dict


class ShowPlatformHardwareSerdesInternal(ShowPlatformHardwareSerdesSchema):
    """Parser for show platform hardware slot <x> serdes statistics internal"""

    cli_command = 'show platform hardware slot {slot} serdes statistics internal'

    def cli(self, slot, output=None):

        if output is None:
            cmd = self.cli_command.format(slot=slot)
            out = self.device.execute(cmd)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # Network-Processor-0 Link:
        # RP/ESP Link:
        p1 = re.compile(r'^(?P<link>[\w\d\-\s/]+) +Link:$')

        #   Local TX in sync, Local RX in sync
        p2 = re.compile(r'^Local +TX +in +sync, +Local +RX +in +sync$')

        #   Remote TX in sync, Remote RX in sync
        p3 = re.compile(r'^Remote +TX +in +sync, +Remote +RX +in +sync$')

        #   To Network-Processor       Packets:    21763844  Bytes:  7343838083
        #   To Encryption Processor   Packets:           0  Bytes:           0
        #   To RP/ESP Packets: 1150522 Bytes: 166031138
        p4 = re.compile(r'^To +(?P<link_name_1>[\w\-\d\s/]+) +Packets: +(?P<to_packets>\d+) +Bytes: +(?P<to_bytes>\d+)$')

        #   From Network-Processor     Packets:    21259012  Bytes:  7397920802
        #   From RP/ESP Packets: 4364008 Bytes: 697982854
        p5 = re.compile(r'^From +(?P<link_name_2>[\w\-\d\s/]+) +Packets: +(?P<from_packets>\d+) +Bytes: +(?P<from_bytes>\d+)$')

        #     Drops                   Packets:           0  Bytes:           0
        p6 = re.compile(r'^Drops +Packets: +(?P<dropped_packets>\d+) +Bytes: +(?P<dropped_bytes>\d+)$')

        #     Errors                  Packets:           0  Bytes:           0
        p7 = re.compile(r'^Errors +Packets: +(?P<errored_packets>\d+) +Bytes: +(?P<errored_bytes>\d+)$')

        #     Errors:
        p8 = re.compile(r'^Errors:$')

        #     RX/TX process: 0/0, RX/TX schedule: 0/0
        p9 = re.compile(r'^RX/TX +process: +(?P<rx_process>\d+)/(?P<tx_process>\d+), +RX/TX +schedule: +(?P<rx_schedule>\d+)/(?P<tx_schedule>\d+)$')

        #     RX/TX statistics: 0/0, RX parity: 0
        p10 = re.compile(r'^RX/TX +statistics: +(?P<rx_statistics>\d+)/(?P<tx_statistics>\d+), +RX +parity: +(?P<rx_parity>\d+)$')

        # Serdes Exception Counts:
        p11 = re.compile(r'^Serdes +Exception +Counts:$')

        #   eqs/fc:
        #   idh-hi:
        #   spi link:
        p12 = re.compile(r'^(?P<link>[\w\d\-\s\/]+):$')

        #     link 0: msgTypeError: 5
        #     link 0: msgEccError: 5
        #     link 0: chicoEvent: 5
        #     link 1: msgTypeError: 1
        #     link 1: msgEccError: 1
        #     link 1: chicoEvent: 1
        #     link 2: msgTypeError: 3
        #     link 2: msgEccError: 3
        #     link 2: chicoEvent: 3
        p13 = re.compile(r'^link +(?P<link_number>\d+): +(?P<error_event>\w+): +(?P<count>\d+)$')

        for line in out.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                link = group['link']
                new_dict = ret_dict.setdefault('link', {}).setdefault(link, {})
                continue

            m = p2.match(line)
            if m:
                new_dict['local_tx_in_sync'] = True
                new_dict['local_rx_in_sync'] = True
                continue

            m = p3.match(line)
            if m:
                new_dict['remote_tx_in_sync'] = True
                new_dict['remote_rx_in_sync'] = True
                continue

            m = p4.match(line)
            if m:
                group = m.groupdict()
                to_not_from = True
                new_dict.setdefault('to', {}).setdefault('pkts', {})
                new_dict['to'].setdefault('bytes', {})
                new_dict['to']['pkts']['total'] = int(group['to_packets'])
                new_dict['to']['bytes']['total'] = int(group['to_bytes'])
                continue

            m = p5.match(line)
            if m:
                group = m.groupdict()
                to_not_from = False
                new_dict.setdefault('from', {}).setdefault('pkts', {})
                new_dict['from'].setdefault('bytes', {})
                new_dict['from']['pkts']['total'] = int(group['from_packets'])
                new_dict['from']['bytes']['total'] = int(group['from_bytes'])
                continue

            m = p6.match(line)
            if m:
                group = m.groupdict()
                if to_not_from:
                    new_dict['to']['pkts']['dropped'] = int(group['dropped_packets'])
                    new_dict['to']['bytes']['dropped'] = int(group['dropped_bytes'])
                else:
                    new_dict['from']['pkts']['dropped'] = int(group['dropped_packets'])
                    new_dict['from']['bytes']['dropped'] = int(group['dropped_bytes'])
                continue

            m = p7.match(line)
            if m:
                group = m.groupdict()
                if to_not_from:
                    new_dict['to']['pkts']['errored'] = int(group['errored_packets'])
                    new_dict['to']['bytes']['errored'] = int(group['errored_bytes'])
                else:
                    new_dict['from']['pkts']['errored'] = int(group['errored_packets'])
                    new_dict['from']['bytes']['errored'] = int(group['errored_bytes'])
                continue

            m = p8.match(line)
            if m:
                continue

            m = p9.match(line)
            if m:
                group = m.groupdict()
                new_dict.setdefault('errors', {})
                new_dict['errors'].update({k: int(v)
                                           for k, v in group.items()})
                continue

            m = p10.match(line)
            if m:
                group = m.groupdict()
                if 'errors' in ret_dict['link'][link]:
                    new_dict['errors'].update(
                        {k: int(v) for k, v in group.items()})
                continue

            m = p11.match(line)
            if m:
                serdes_exception_counts = True
                ret_dict.setdefault('serdes_exception_counts', {})
                continue

            m = p12.match(line)
            if m:
                group = m.groupdict()
                link = group['link']
                ret_dict['serdes_exception_counts'].setdefault(link, {})
                continue

            m = p13.match(line)
            if m:
                group = m.groupdict()
                link_number = group['link_number']
                error_event = group['error_event']
                ret_dict['serdes_exception_counts'][link].setdefault('link', {}).setdefault(link_number, {})
                ret_dict['serdes_exception_counts'][link]['link'][link_number][error_event] = int(group['count'])
                continue

        return ret_dict


class ShowPlatformPowerSchema(MetaParser):
    """Schema for show platform power"""
    schema = {
        'chassis': str,
        'total_load': int,
        'total_capacity': int,
        'load_capacity_percent': int,
        'power_capacity': int,
        'redundant_alc': int,
        'fan_alc': int,
        'fru_alc': int,
        'excess_power': int,
        'excess_capacity_percent': int,
        'redundancy_mode': str,
        'allocation_status': str,
        'slot': {
            Any(): {
                'type': str,
                'state': str,
                Optional('allocation'): float,
                Optional('capacity'): int,
                Optional('load'): int,
            },
        }
    }


class ShowPlatformPower(ShowPlatformPowerSchema):
    """Parser for show platform power"""
    cli_command = 'show platform power'

    def cli(self, output=None):

        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        ret_dict = {}

        # Chassis type: ASR1006-X
        p1 = re.compile(r'^\s*Chassis +type\: +(?P<chassis>[\w\-]+)')

        # Power Redundancy Mode: nplus1
        p2 = re.compile(r'^\s*Power +Redundancy +Mode\: +(?P<redundancy_mode>[\w]+)')

        # Power Allocation Status: Sufficient
        p3 = re.compile(r'^\s*Power +Allocation +Status\: +(?P<allocation_status>[\w]+)')

        # Slot      Type                State                 Allocation(W)
        # 0         ASR1000-SIP40       ok                    64
        #  0/0      SPA-8X1GE-V2        inserted              14
        #  0/1      SPA-1X10GE-L-V2     inserted              17.40
        p4 = re.compile(r'^\s*(?P<slot>[\w\/]+) +(?P<type>[\w-]+) '
                        '+(?P<state>\w+(?:\, \w+)?) +(?P<allocation>[\d.]+)$')

        # Slot      Type                State                 Capacity (W) Load (W)
        # P0        ASR1000X-AC-1100W   ok                    1100         132
        p5 = re.compile(r'^\s*(?P<slot>[\w\/]+) +(?P<type>[\w\-]+) '
                        '+(?P<state>\w+(?:\, \w+)?) +(?P<capacity>[\d.]+) +(?P<load>[\d.]+)')

        # Total load: 696 W, total capacity: 4400 W. Load / Capacity is 15%
        p6 = re.compile(r'^\s*Total +load\: +(?P<total_load>\d+) +W\, +total +capacity\: +(?P<total_capacity>\d+) +W\.'
                        ' +Load +\/ +Capacity +is +(?P<load_capacity_percent>\d+)\%$')

        # Power capacity:       4400 W
        p7 = re.compile(r'^\s*Power +capacity\: +(?P<power_capacity>\d+) +W$')

        # Redundant allocation: 0 W
        p8 = re.compile(r'^\s*Redundant +allocation\: +(?P<redundant_alc>\d+) +W$')

        # Fan allocation:       250 W
        p9 = re.compile(r'^\s*Fan +allocation\: +(?P<fan_alc>\d+) +W$')

        # FRU allocation:       949 W
        p10 = re.compile(r'^\s*FRU +allocation\: +(?P<fru_alc>\d+) +W$')

        # Excess Power in Reserve:   3201 W
        p11 = re.compile(r'^\s*Excess +Power +in +Reserve\: +(?P<excess_power>\d+) +W$')

        # Excess / (Capacity - Redundant) is 72%
        p12 = re.compile(r'^\s*Excess +\/ +\(Capacity - Redundant\) +is +(?P<excess_capacity_percent>\d+)\%$')

        for line in out.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                ret_dict['chassis'] = m.groupdict()['chassis']
                continue

            m = p2.match(line)
            if m:
                ret_dict['redundancy_mode'] = m.groupdict()['redundancy_mode']
                continue

            m = p3.match(line)
            if m:
                ret_dict['allocation_status'] = m.groupdict()['allocation_status']

            m = p4.match(line)
            if m:
                slot = m.groupdict()['slot']
                t = m.groupdict()['type']
                state = m.groupdict()['state']
                allocation = float(m.groupdict()['allocation'])
                slot_dict = ret_dict.setdefault('slot', {}).setdefault(slot, {})
                slot_dict.update({"type": t})
                slot_dict.update({"state": state})
                slot_dict.update({"allocation": allocation})
                continue

            m = p5.match(line)
            if m:
                slot = m.groupdict()['slot']
                t = m.groupdict()['type']
                state = m.groupdict()['state']
                capacity = int(m.groupdict()['capacity'])
                load = int(m.groupdict()['load'])
                slot_dict = ret_dict.setdefault('slot', {}).setdefault(slot, {})
                slot_dict.update({"type": t})
                slot_dict.update({"state": state})
                slot_dict.update({"capacity": capacity})
                slot_dict.update({"load": load})
                continue

            m = p6.match(line)
            if m:
                ret_dict['total_load'] = int(m.groupdict()['total_load'])
                ret_dict['total_capacity'] = int(m.groupdict()['total_capacity'])
                ret_dict['load_capacity_percent'] = int(m.groupdict()['load_capacity_percent'])
                continue

            m = p7.match(line)
            if m:
                ret_dict['power_capacity'] = int(m.groupdict()['power_capacity'])
                continue

            m = p8.match(line)
            if m:
                ret_dict['redundant_alc'] = int(m.groupdict()['redundant_alc'])
                continue

            m = p9.match(line)
            if m:
                ret_dict['fan_alc'] = int(m.groupdict()['fan_alc'])
                continue

            m = p10.match(line)
            if m:
                ret_dict['fru_alc'] = int(m.groupdict()['fru_alc'])
                continue

            m = p11.match(line)
            if m:
                ret_dict['excess_power'] = int(m.groupdict()['excess_power'])
                continue

            m = p12.match(line)
            if m:
                ret_dict['excess_capacity_percent'] = int(m.groupdict()['excess_capacity_percent'])
                continue

        return ret_dict


class ShowPlatformHardwareQfpBqsStatisticsChannelAllSchema(MetaParser):
    """Schema for show platform hardware qfp active bqs <x> ipm statistics channel all
                  show platform hardware qfp standby bqs <x> ipm statistics channel all
                  show platform hardware qfp active bqs <x> opm statistics channel all
                  show platform hardware qfp standby bqs <x> opm statistics channel all"""

    schema = {
        'channel': {
            Any(): {
                'goodpkts': str,
                'goodbytes': str,
                'badpkts': str,
                'badbytes': str,
                Optional('comment'): str,
            },
        }
    }


class ShowPlatformHardwareQfpBqsStatisticsChannelAll(ShowPlatformHardwareQfpBqsStatisticsChannelAllSchema):
    """Parser for show platform hardware qfp active bqs <x> ipm statistics channel all
                  show platform hardware qfp standby bqs <x> ipm statistics channel all
                  show platform hardware qfp active bqs <x> opm statistics channel all
                  show platform hardware qfp standby bqs <x> opm statistics channel all"""

    cli_command = 'show platform hardware qfp {status} bqs {slot} {iotype} statistics channel all'

    def cli(self, status='active', slot='0', iotype='ipm', output=None):

        if output is None:
            cmd = self.cli_command.format(
                status=status, slot=slot, iotype=iotype)
            out = self.device.execute(cmd)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # Chan   GoodPkts  GoodBytes    BadPkts   BadBytes
        # 1 - 0000000000 0000000000 0000000000 0000000000
        # 2 - 0000c40f64 016a5004b0 0000000000 0000000000
        p1 = re.compile(r'^(?P<channel>\d+) +- +(?P<goodpkts>\w+) +(?P<goodbytes>\w+) +(?P<badpkts>\w+) +(?P<badbytes>\w+)$')

        #  0-55: OPM Channels
        # 56-59: Metapacket/Recycle Pools 0-3
        #    60: Reassembled Packets Sent to QED
        p2 = re.compile(r'^(?P<channel>\d+)-?(?P<end_channel>\d+)?: +(?P<comment>.+)$')

        for line in out.splitlines():
            line = line.strip()
            m = p1.match(line)
            if m:
                group = m.groupdict()
                channel = int(group.pop('channel'))
                chan_dict = ret_dict.setdefault('channel', {}).setdefault(channel, {})
                chan_dict.update({k: v for k, v in group.items()})
                continue

            m = p2.match(line)
            if m:
                group = m.groupdict()
                channel = int(group['channel'])
                comment = group['comment']
                if group['end_channel']:
                    end_channel = int(group['end_channel'])
                    for i in range(channel, end_channel + 1):
                        ret_dict['channel'][i].update({'comment': comment})
                else:
                    ret_dict['channel'][channel].update({'comment': comment})

                continue

        return ret_dict


class ShowPlatformHardwareQfpBqsMappingSchema(MetaParser):
    """Schema for show platform hardware qfp active bqs <x> ipm mapping
                  show platform hardware qfp standby bqs <x> ipm mapping
                  show platform hardware qfp active bqs <x> opm mapping
                  show platform hardware qfp standby bqs <x> opm mapping"""

    schema = {
        'channel': {
            Any(): {
                Optional('interface'): str,
                'name': str,
                Optional('logical_channel'): int,
                Optional('drain_mode'): bool,
                Optional('port'): int,
                Optional('cfifo'): int,
            },
        }
    }


class ShowPlatformHardwareQfpBqsOpmMapping(ShowPlatformHardwareQfpBqsMappingSchema):
    """Parser for show platform hardware qfp active bqs <x> opm mapping
                  show platform hardware qfp standby bqs <x> opm mapping"""

    cli_command = 'show platform hardware qfp {status} bqs {slot} opm mapping'

    def cli(self, status, slot, output=None):

        if output is None:
            cmd = self.cli_command.format(status=status, slot=slot)
            out = self.device.execute(cmd)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # Chan     Name                          Interface      LogicalChannel
        #  0       CC0 Low                       SPI0            0
        # 24       Peer-FP Low                   SPI0           24
        # 26       Nitrox Low                    SPI0           26
        # 28       HT Pkt Low                    HT              0
        # 38       HighNormal                    GPM             7
        # 55*      Drain Low                     GPM             0
        # * - indicates the drain mode bit is set for this channel
        p1 = re.compile(r'^(?P<number>\d+)(?P<drained>\*)? +(?P<name>[\w\-\s]+)'
                        ' +(?P<interface>[\w\d]+) +(?P<logical_channel>\d+)$')

        # 32       Unmapped
        p2 = re.compile(r'^(?P<unmapped_number>\d+) +Unmapped$')

        for line in out.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                interface = group['interface']
                number = group['number']
                if group['drained']:
                    drained = True
                else:
                    drained = False
                if 'channel' not in ret_dict:
                    final_dict = ret_dict.setdefault('channel', {})
                final_dict = ret_dict['channel'].setdefault(number, {})
                final_dict.update({'interface': group['interface'].strip()})
                final_dict.update({'name': group['name'].strip()})
                final_dict.update({'logical_channel': int(group['logical_channel'])})
                final_dict.update({'drain_mode': drained})
                continue

            m = p2.match(line)
            if m:
                group = m.groupdict()
                unmapped_number = group['unmapped_number']
                if 'channel' not in ret_dict:
                    ret_dict.setdefault('channel', {})
                ret_dict['channel'].setdefault(unmapped_number, {})
                ret_dict['channel'][unmapped_number].update({'name': 'unmapped'})
                continue

        return ret_dict


class ShowPlatformHardwareQfpBqsIpmMapping(ShowPlatformHardwareQfpBqsMappingSchema):
    """Parser for show platform hardware qfp active bqs <x> ipm mapping
                  show platform hardware qfp standby bqs <x> ipm mapping"""

    cli_command = 'show platform hardware qfp {status} bqs {slot} ipm mapping'

    def cli(self, status, slot, output=None):

        if output is None:
            cmd = self.cli_command.format(status=status, slot=slot)
            out = self.device.execute(cmd)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # Chan   Name                Interface      Port     CFIFO
        #  1     CC3 Low             SPI0           0        1
        # 13     Peer-FP Low         SPI0          12        3
        # 15     Nitrox Low          SPI0          14        1
        # 17     HT Pkt Low          HT             0        1
        # 21     CC4 Low             SPI0          16        1
        p1 = re.compile(r'^(?P<number>\d+) +(?P<name>[\w\-\s]+)'
                        ' +(?P<interface>[\w\d]+) +(?P<port>\d+)'
                        ' +(?P<cfifo>\d+)$')

        # 32       Unmapped
        p2 = re.compile(r'^(?P<unmapped_number>\d+) +Unmapped$')

        for line in out.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                number = group['number']
                final_dict = ret_dict.setdefault('channel', {}).setdefault(number, {})
                final_dict.update({'interface': group['interface'].strip()})
                final_dict.update({'name': group['name'].strip()})
                final_dict.update({'port': int(group['port'])})
                final_dict.update({'cfifo': int(group['cfifo'])})
                continue

            m = p2.match(line)
            if m:
                group = m.groupdict()
                unmapped_number = group['unmapped_number']
                if 'channel' not in ret_dict:
                    ret_dict.setdefault('channel', {})
                ret_dict['channel'].setdefault(unmapped_number, {})
                ret_dict['channel'][unmapped_number].update({'name': 'unmapped'})
                continue

        return ret_dict


class ShowPlatformHardwareQfpInterfaceIfnameStatisticsSchema(MetaParser):
    """Schema for show platform hardware qfp active interface if-name <interface> statistics
                  show platform hardware qfp standby interface if-name <interface> statistics"""

    schema = {
        'qfp': {
            'active': {
                'interface': {
                    Any(): {
                        Optional('platform_handle'): int,
                        'receive_stats': {
                            Any(): {
                                'packets': int,
                                'octets': int,
                            },
                        },
                        'transmit_stats': {
                            Any(): {
                                'packets': int,
                                'octets': int,
                            },
                        },
                        'ingress_drop_stats': {
                            Optional(Any()): {
                                'packets': int,
                                'octets': int,
                            },
                        },
                        'egress_drop_stats': {
                            Optional(Any()): {
                                'packets': int,
                                'octets': int,
                            },
                        }
                    },
                }
            }
        }
    }


class ShowPlatformHardwareQfpInterfaceIfnameStatistics(ShowPlatformHardwareQfpInterfaceIfnameStatisticsSchema):
    """Parser for show platform hardware qfp active interface if-name <interface> statistics
                  show platform hardware qfp standby interface if-name <interface> statistics"""

    cli_command = 'show platform hardware qfp {status} interface if-name {interface} statistics'

    def cli(self, status, interface, output=None):

        if output is None:
            cmd = self.cli_command.format(status=status, interface=interface)
            out = self.device.execute(cmd)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}
        current_stats = None
        final_dict = {}

        # Platform Handle 7
        p1 = re.compile(r'^Platform +Handle +(?P<platform_handle>\d+)$')

        # Receive Stats                             Packets        Octets
        # Transmit Stats                            Packets        Octets
        # Input Drop Stats                          Packets        Octets
        # Output Drop Stats                         Packets        Octets
        p2 = re.compile(r'^(?P<transmit_receive>[\w\s]+) +Stats +Packets +Octets$')

        #   FragmentedIpv6                             0               0
        #   Other
        p3 = re.compile(r'^(?P<stats>[\w\d]+) +(?P<packets>[\w\d]+) +(?P<octets>[\w\d]+)$')

        for line in out.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                converted_interface = Common.convert_intf_name(interface)
                final_dict = ret_dict.setdefault('qfp', {}).setdefault(
                    'active', {}).setdefault('interface', {}).setdefault(converted_interface, {})
                final_dict['platform_handle'] = int(group['platform_handle'])
                continue

            m = p2.match(line)
            if m:
                if not final_dict:
                    converted_interface = Common.convert_intf_name(interface)
                    final_dict = ret_dict.setdefault('qfp', {}).setdefault(
                        'active', {}).setdefault('interface', {}).setdefault(converted_interface, {})

                group = m.groupdict()
                status = group['transmit_receive']
                if 'Receive' in status:
                    current_stats = 'receive_stats'
                elif 'Transmit' in status:
                    current_stats = 'transmit_stats'
                elif 'Input Drop' in status:
                    current_stats = 'ingress_drop_stats'
                else:
                    current_stats = 'egress_drop_stats'

                final_dict.setdefault(current_stats, {})
                continue

            m = p3.match(line)
            if m:
                group = m.groupdict()
                stats = group['stats']
                final_dict[current_stats].setdefault(stats, {})
                final_dict[current_stats][stats]['packets'] = int(group['packets'])
                final_dict[current_stats][stats]['octets'] = int(group['octets'])
                continue

        return ret_dict


class ShowPlatformHardwareQfpStatisticsDropSchema(MetaParser):
    """Schema for show platform hardware qfp active statistics drop
                  show platform hardware qfp standby statistics drop"""

    schema = {
        'global_drop_stats': {
            Any(): {
                'packets': int,
                'octets': int,
            },
        }
    }


class ShowPlatformHardwareQfpStatisticsDrop(ShowPlatformHardwareQfpStatisticsDropSchema):
    """Parser for show platform hardware qfp active statistics drop
                  show platform hardware qfp standby statistics drop"""

    cli_command = [
        'show platform hardware qfp {status} statistics drop | exclude {exclude}',
        'show platform hardware qfp {status} statistics drop']

    def cli(self, status='active', exclude=None, output=None):

        if output is None:
            if exclude:
                cmd = self.cli_command[0].format(status=status, exclude=exclude)
            else:
                cmd = self.cli_command[1].format(status=status)
            out = self.device.execute(cmd)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # Global Drop Stats                         Packets                  Octets
        # -------------------------------------------------------------------------
        # Ipv4NoAdj                                       7                     296
        # Ipv4NoRoute                                   181                    7964
        p1 = re.compile(r'^(?P<global_drop_stats>\w+) +(?P<packets>\d+) +(?P<octets>\d+)$')

        # Global Drop Stats                         Packets        Octets
        # ----------------------------------------------------------------
        #    The Global drop stats were all zero
        p2 = re.compile(r'The Global drop stats were all zero')

        for line in out.splitlines():
            line = line.strip()
            m = p1.match(line)
            # Ipv4NoRoute                                   181                    7964
            if m:
                group = m.groupdict()
                global_drop_stats = group.pop('global_drop_stats')
                stats_dict = ret_dict.setdefault('global_drop_stats', {}).setdefault(global_drop_stats, {})
                stats_dict.update({k: int(v) for k, v in group.items()})
                continue
            # The Global drop stats were all zero
            m = p2.match(line)
            if m:
                ret_dict.setdefault('global_drop_stats', {})
                ret_dict['global_drop_stats'] = {'NA': {'packets': 0, 'octets': 0}}

        return ret_dict

class ShowPlatformHardwareQfpStatisticsDropClear(ShowPlatformHardwareQfpStatisticsDropSchema):
    """
    Parser for
        show platform hardware qfp active statistics drop clear
        show platform hardware qfp standby statistics drop clear
    """

    cli_command = 'show platform hardware qfp {status} statistics drop clear'

    def cli(self, status, output=None):

        if output is None:
            cmd = self.cli_command.format(status=status)
            output = self.device.execute(cmd)

        ret_dict = {}

        # Ipv4NoRoute              181                 7964
        # Note: The command output contains multiple such rows
        #       with different row headers, so we parse the
        #       row header as well
        p1 = re.compile(r'^(?P<drop_reason>\w+)\s+(?P<packets>\d+)\s+(?P<octets>\d+)$')

        for line in output.splitlines():
            line = line.strip()

            # Ipv4NoRoute              181                 7964
            # Note: The command output contains multiple such rows
            #       with different row headers, so we parse the
            #       row header as well
            m = p1.match(line)
            if m:
                group = m.groupdict()
                drop_reason = group.pop('drop_reason')
                stats_dict = ret_dict.setdefault('global_drop_stats', {}).setdefault(drop_reason, {})
                stats_dict.update({k: int(v) for k, v in group.items()})
                continue

        return ret_dict


class ShowProcessesCpuHistorySchema(MetaParser):
    """Schema for show processes cpu history"""

    schema = {
        '60s': {
            Any(): {
                'maximum': int,
                Optional('average'): int,
            },
        },
        '60m': {
            Any(): {
                'maximum': int,
                Optional('average'): int,
            },
        },
        '72h': {
            Any(): {
                'maximum': int,
                Optional('average'): int,
            },
        },
    }


class ShowProcessesCpuHistory(ShowProcessesCpuHistorySchema):
    """Parser for show processes cpu history"""

    cli_command = 'show processes cpu history'
    exclude = ['maximum', 'average']

    def cli(self, output=None):

        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        #           888886666611111                    11111
        # 7777755555996510966664444466666333335555544444666667777777777
        p1 = re.compile(r'^ *\d+( +\d+)* *$')

        #          0    5    0    5    0    5    0    5    0    5    0
        p2 = re.compile(r'^ *0( +5 +0){5,6} *$')

        # 80     * **#*#**   * *       *
        # 70  *  * **#*#**   * *       *           *
        p3 = re.compile(r'^ *(?P<num>[\d]+)(?P<line>.*#.*$)')

        # CPU% per second (last 60 seconds)
        p4 = re.compile(r'^ *CPU%.*$')

        # initialize max list & average list & return dictionary
        max_list = []
        average_list = []
        ret_dict = {}

        for line in out.splitlines():
            strip_line = line[6:]
            m = p1.match(strip_line)
            if m:
                max_list.append(strip_line)
                continue

            m1 = p3.match(line)
            m2 = p4.match(line)
            if m1 or m2:
                average_list.append(line)
                continue

        # parser max value
        tmp = [''] * 72
        count = 0
        for line in max_list:
            m = p2.match(line)
            if not m:
                for i, v in enumerate(line):
                    if v == ' ':
                        pass
                    else:
                        tmp[i] += v
            else:
                if count == 0:
                    sub_dict = ret_dict.setdefault('60s', {})
                    for i in range(60):
                        sub_dict.setdefault(i + 1, {}).update({'maximum': int(tmp[i]) if tmp[i] != '' else 0})

                elif count == 1:
                    sub_dict = ret_dict.setdefault('60m', {})
                    for i in range(60):
                        sub_dict.setdefault(i + 1, {}).update({'maximum': int(tmp[i]) if tmp[i] != '' else 0})

                else:
                    sub_dict = ret_dict.setdefault('72h', {})
                    for i in range(72):
                        sub_dict.setdefault(i + 1, {}).update({'maximum': int(tmp[i]) if tmp[i] != '' else 0})
                tmp = [''] * 72
                count += 1

        # parser average value
        count = 0
        for line in average_list:
            m = p3.match(line)
            if count == 0:
                sub_dict = ret_dict.setdefault('60s', {})
            elif count == 1:
                sub_dict = ret_dict.setdefault('60m', {})
            else:
                sub_dict = ret_dict.setdefault('72h', {})

            if m:
                num = int(m.groupdict()['num'])
                line = m.groupdict()['line']
                for i, char in enumerate(line):
                    if char == '#':
                        t = sub_dict.setdefault(i, {})
                        if 'average' not in t:
                            t.update({'average': num})

            else:
                for value in sub_dict.values():
                    if 'average' not in value:
                        value.update({'average': 0})

                count += 1

        return ret_dict


class ShowProcessesMemorySchema(MetaParser):
    schema = {
        Optional('processor_pool'): {
            'total': int,
            'used': int,
            'free': int,
        },
        Optional('reserve_p_pool'): {
            'total': int,
            'used': int,
            'free': int,
        },
        Optional('lsmi_io_pool'): {
            'total': int,
            'used': int,
            'free': int,
        },
        Optional('pid'): {
            Any(): {
                'index': {
                    Any(): {
                        'pid': int,
                        'tty': int,
                        'allocated': int,
                        'freed': int,
                        'holding': int,
                        'getbufs': int,
                        'retbufs': int,
                        'process': str,
                    }
                }
            }
        }
    }


class ShowProcessesMemory(ShowProcessesMemorySchema):
    cli_command = [
        'show processes memory',
        'show processes memory | include {include}',
        'show processes memory | exclude {exclude}',
        'show processes memory | section {section}'
    ]

    def cli(self, include=None, exclude=None, section=None, output=None):

        ret_dict = {}
        pid_index = {}

        if not output:
            if include:
                cmd = self.cli_command[1].format(include=include)
            elif exclude:
                cmd = self.cli_command[2].format(exclude=exclude)
            elif section:
                cmd = self.cli_command[3].format(section=section)
            else:
                cmd = self.cli_command[0]
            out = self.device.execute(cmd)
        else:
            out = output

        # Processor Pool Total: 10147887840 Used:  485435960 Free: 9662451880
        p1 = re.compile(r'^Processor +Pool +Total: +(?P<total>\d+) +'
                        r'Used: +(?P<used>\d+) +Free: +(?P<free>\d+)$')

        # reserve P Pool Total:     102404 Used:         88 Free:     102316
        p2 = re.compile(r'^reserve +P +Pool +Total: +(?P<total>\d+) +'
                        r'Used: +(?P<used>\d+) +Free: +(?P<free>\d+)$')

        # lsmpi_io Pool Total:    6295128 Used:    6294296 Free:        832
        p3 = re.compile(r'^lsmpi_io +Pool +Total: +(?P<total>\d+) +'
                        r'Used: +(?P<used>\d+) +Free: +(?P<free>\d+)$')

        # 0   0  678985440  347855496  304892096        428    2134314 *Init*
        # 1   0    3415536     879912    2565568          0          0 Chunk Manager
        p4 = re.compile(r'^(?P<pid>\d+) +(?P<tty>\d+) +(?P<allocated>\d+) +'
                        r'(?P<freed>\d+) +(?P<holding>\d+) +(?P<getbufs>\d+) +'
                        r'(?P<retbufs>\d+) +(?P<process>[\S ]+)$')

        for line in out.splitlines():
            line = line.strip()

            # Processor Pool Total: 10147887840 Used:  485435960 Free: 9662451880
            m = p1.match(line)
            if m:
                group = m.groupdict()
                processor_pool_dict = ret_dict.setdefault('processor_pool', {})
                processor_pool_dict.update({k: int(v) for k, v in group.items() if v is not None})
                continue

            # reserve P Pool Total:     102404 Used:         88 Free:     102316
            m = p2.match(line)
            if m:
                group = m.groupdict()
                processor_pool_dict = ret_dict.setdefault('reserve_p_pool', {})
                processor_pool_dict.update({k: int(v) for k, v in group.items() if v is not None})
                continue

            # lsmpi_io Pool Total:    6295128 Used:    6294296 Free:        832
            m = p3.match(line)
            if m:
                group = m.groupdict()
                processor_pool_dict = ret_dict.setdefault('lsmi_io_pool', {})
                processor_pool_dict.update({k: int(v) for k, v in group.items() if v is not None})
                continue

            # 0   0  678985440  347855496  304892096        428    2134314 *Init*
            # 1   0    3415536     879912    2565568          0          0 Chunk Manager
            m = p4.match(line)
            if m:
                group = m.groupdict()
                pid = int(group['pid'])
                index = pid_index.get(pid, 0) + 1
                pid_dict = ret_dict.setdefault('pid', {}). \
                    setdefault(pid, {}). \
                    setdefault('index', {}). \
                    setdefault(index, {})
                pid_index.update({pid: index})
                pid_dict.update({k: int(v) if v.isdigit() else v for k, v in group.items() if v is not None})
                continue

        return ret_dict


class ShowPlatformSoftwareMemoryCallsiteSchema(MetaParser):
    """ Schema for show platform software memory <process> switch active <R0> alloc callsite brief """
    schema = {
        'tracekey': str,
        'callsites': {
            Any(): {
                'thread': int,
                'diff_byte': int,
                'diff_call': int
            }
        }
    }


class ShowPlatformSoftwareMemoryCallsite(ShowPlatformSoftwareMemoryCallsiteSchema):
    """ Parser for show platform software memory <process> switch active <R0> alloc callsite brief """

    cli_command = 'show platform software memory {process} switch active {slot} alloc callsite brief'

    def cli(self, process, slot, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(process=process, slot=slot))
        else:
            out = output

        # Init vars
        parsed_dict = {}
        if out:
            callsite_dict = parsed_dict.setdefault('callsites', {})

        # The current tracekey is   : 1#2315ece11e07bc883d89421df58e37b6
        p1 = re.compile(r'The +current +tracekey +is\s*: +(?P<tracekey>[#\d\w]*)')

        # callsite      thread    diff_byte               diff_call
        # ----------------------------------------------------------
        # 1617611779    31884     57424                   2
        p2 = re.compile(r'(?P<callsite>(\d+))\s+(?P<thread>(\d+))\s+(?P<diffbyte>(\d+))\s+(?P<diffcall>(\d+))')

        for line in out.splitlines():
            line = line.strip()

            # The current tracekey is   : 1#2315ece11e07bc883d89421df58e37b6
            m = p1.match(line)
            if m:
                group = m.groupdict()
                parsed_dict['tracekey'] = str(group['tracekey'])
                continue

            # callsite      thread    diff_byte               diff_call
            # ----------------------------------------------------------
            # 1617611779    31884     57424                   2
            m = p2.match(line)
            if m:
                group = m.groupdict()
                callsite = group['callsite']
                one_callsite_dict = callsite_dict.setdefault(callsite, {})
                one_callsite_dict['thread'] = int(group['thread'])
                one_callsite_dict['diff_byte'] = int(group['diffbyte'])
                one_callsite_dict['diff_call'] = int(group['diffcall'])
                continue

        return parsed_dict


class ShowPlatformSoftwareMemoryBacktraceSchema(MetaParser):
    """ Schema for show platform software memory <process> switch active <R0> alloc backtrace """
    schema = {
        'backtraces': {
            Any():
                {'allocs': int,
                 'frees': int,
                 'call_diff': int,
                 'callsite': str,
                 'thread_id': int}
        }

    }

class ShowPlatformSoftwareMemoryBacktrace(ShowPlatformSoftwareMemoryBacktraceSchema):
    """ Parser for show platform software memory <process> switch active <R0> alloc backtrace """

    cli_command = 'show platform software memory {process} switch active {slot} alloc backtrace'

    def cli(self, process, slot, output=None):
        if output is None:
            out = self.device.execute(
                self.cli_command.format(process=process, slot=slot))
        else:
            out = output

        # Init vars
        parsed_dict = {}
        if out:
            backtraces_dict = parsed_dict.setdefault('backtraces', {})

        # backtrace: 1#2315ece11e07bc883d89421df58e37b6   maroon:7F740DEDC000+61F6 tdllib:7F7474D05000+B2B46 ui:7F74770E4000+4639A ui:7F74770E4000+4718C cdlcore:7F7466A6B000+37C95 cdlcore:7F7466A6B000+37957 uipeer:7F747A7A8000+24F2A evutil:7F747864E000+7966 evutil:7F747864E000+7745
        p1 = re.compile(r'backtrace: (?P<backtrace>[\w#\d\s:+]+)$')

        #   callsite: 2150603778, thread_id: 31884
        p2 = re.compile(r'callsite: +(?P<callsite>\d+), +thread_id: +(?P<thread_id>\d+)')

        #   allocs: 1, frees: 0, call_diff: 1
        p3 = re.compile(r'allocs: +(?P<allocs>(\d+)), +frees: +(?P<frees>(\d+)), +call_diff: +(?P<call_diff>(\d+))')

        for line in out.splitlines():
            line = line.strip()

            # backtrace: 1#2315ece11e07bc883d89421df58e37b6   maroon:7F740DEDC000+61F6 tdllib:7F7474D05000+B2B46 ui:7F74770E4000+4639A ui:7F74770E4000+4718C cdlcore:7F7466A6B000+37C95 cdlcore:7F7466A6B000+37957 uipeer:7F747A7A8000+24F2A evutil:7F747864E000+7966 evutil:7F747864E000+7745
            m = p1.match(line)
            if m:
                group = m.groupdict()
                backtrace = str(group['backtrace'])
                one_backtrace_dict = backtraces_dict.setdefault(backtrace, {})
                continue

            #   callsite: 2150603778, thread_id: 31884
            m = p2.match(line)
            if m:
                group = m.groupdict()
                one_backtrace_dict['callsite'] = group['callsite']
                one_backtrace_dict['thread_id'] = int(group['thread_id'])
                continue

            #   allocs: 1, frees: 0, call_diff: 1
            m = p3.match(line)
            if m:
                group = m.groupdict()
                one_backtrace_dict['allocs'] = int(group['allocs'])
                one_backtrace_dict['frees'] = int(group['frees'])
                one_backtrace_dict['call_diff'] = int(group['call_diff'])
                continue

        return parsed_dict

# class RmSoftwareMemoryChassisActiveBacktrace(ShowPlatformSoftwareMemoryBacktrace):
#     """ Parser for rm platform software memory <process> chassis active <R0> alloc backtrace """

#     cli_command = 'rm software memory {process} chassis active {slot} alloc backtrace'

#     def cli(self, process, slot, output=None):
#         if output is None:
#             out = self.device.execute(
#                 self.cli_command.format(process=process, slot=slot))
#         else:
#             out = output

#         return super().cli(process=process, slot=slot, output=out)

class ShowProcessesMemorySortedSchema(MetaParser):
    schema = {
        'processor_pool': {
            'total': int,
            'used': int,
            'free': int,
        },
        'reserve_p_pool': {
            'total': int,
            'used': int,
            'free': int,
        },
        'lsmi_io_pool': {
            'total': int,
            'used': int,
            'free': int,
        },
        'per_process_memory': {
            Any(): {
                'pid': int,
                'tty': int,
                'allocated': int,
                'freed': int,
                'holding': int,
                'getbufs': int,
                'retbufs': int,
            }
        }
    }


class ShowProcessesMemorySorted(ShowProcessesMemorySortedSchema):
    cli_command = 'show processes memory sorted'

    def cli(self, include=None, sorted=None, output=None):

        ret_dict = {}
        pid_index = {}

        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        if out:
            per_process_memory_dict = ret_dict.setdefault('per_process_memory', OrderedDict())

        # Processor Pool Total: 10147887840 Used:  485435960 Free: 9662451880
        p1 = re.compile(r'^Processor +Pool +Total: +(?P<total>\d+) +'
                        r'Used: +(?P<used>\d+) +Free: +(?P<free>\d+)$')

        # reserve P Pool Total:     102404 Used:         88 Free:     102316
        p2 = re.compile(r'^reserve +P +Pool +Total: +(?P<total>\d+) +'
                        r'Used: +(?P<used>\d+) +Free: +(?P<free>\d+)$')

        # lsmpi_io Pool Total:    6295128 Used:    6294296 Free:        832
        p3 = re.compile(r'^lsmpi_io +Pool +Total: +(?P<total>\d+) +'
                        r'Used: +(?P<used>\d+) +Free: +(?P<free>\d+)$')

        # 0   0  678985440  347855496  304892096        428    2134314 *Init*
        # 1   0    3415536     879912    2565568          0          0 Chunk Manager
        p4 = re.compile(r'^(?P<pid>\d+) +(?P<tty>\d+) +(?P<allocated>\d+) +'
                        r'(?P<freed>\d+) +(?P<holding>\d+) +(?P<getbufs>\d+) +'
                        r'(?P<retbufs>\d+) +(?P<process>[\S ]+)$')

        for line in out.splitlines():
            line = line.strip()
            # Processor Pool Total: 10147887840 Used:  485435960 Free: 9662451880
            m = p1.match(line)
            if m:
                group = m.groupdict()
                processor_pool_dict = ret_dict.setdefault('processor_pool', {})
                processor_pool_dict.update({k: int(v) for k, v in group.items() if v is not None})
                continue

            # reserve P Pool Total:     102404 Used:         88 Free:     102316
            m = p2.match(line)
            if m:
                group = m.groupdict()
                processor_pool_dict = ret_dict.setdefault('reserve_p_pool', {})
                processor_pool_dict.update({k: int(v) for k, v in group.items() if v is not None})
                continue

            # lsmpi_io Pool Total:    6295128 Used:    6294296 Free:        832
            m = p3.match(line)
            if m:
                group = m.groupdict()
                processor_pool_dict = ret_dict.setdefault('lsmi_io_pool', {})
                processor_pool_dict.update({k: int(v) for k, v in group.items() if v is not None})
                continue

            # 0   0  678985440  347855496  304892096        428    2134314 *Init*
            # 1   0    3415536     879912    2565568          0          0 Chunk Manager
            m = p4.match(line)
            if m:
                group = m.groupdict()
                process_name = str(group['process'])
                one_process_dict = per_process_memory_dict.setdefault(process_name, {})
                one_process_dict['pid'] = int(group['pid'])
                one_process_dict['tty'] = int(group['tty'])
                one_process_dict['allocated'] = int(group['allocated'])
                one_process_dict['freed'] = int(group['freed'])
                one_process_dict['holding'] = int(group['holding'])
                one_process_dict['getbufs'] = int(group['getbufs'])
                one_process_dict['retbufs'] = int(group['retbufs'])
                continue

        return ret_dict

class ShowPlatformIntegritySchema(MetaParser):
    schema = {
        'platform': str,
        'boot': {
            Any(): {
                'version': str,
                'hash': str,
            },
            'loader': {
                'version': str,
                'hash': str,
            },
        },
        'os_version': str,
        'os_hashes': {
            Any(): str,
        },
        Optional('signature_version'): int,
        Optional('signature'): str,
    }

class ShowPlatformIntegrity(ShowPlatformIntegritySchema):
    # cli_command = 'show platform integrity'
    cli_command = [
        'show platform integrity',
        'show platform integrity sign nonce {nonce}',
        'show platform integrity {signature}'
    ]

    def cli(self, signature=None, nonce=None, output=None):
        if not output:
            if nonce:
                output = self.device.execute(self.cli_command[1].format(nonce=nonce))
            elif signature:
                output = self.device.execute(self.cli_command[2].format(signature=signature))
            else:
                output = self.device.execute(self.cli_command[0])

        ret_dict = {}

        # Platform: C9300-24U
        p1 = re.compile(r'^Platform: +(?P<platform>\S+)$')
        # Boot 0 Version: F01144R16.216e68ad62019-02-13
        p2 = re.compile(r'^Boot +(?P<boot>\d+) +Version: +(?P<version>\S+)$')
        # Boot 0 Hash: 523DD459C650AF0F5AB5396060605E412C1BE99AF51F4FA88AD26049612921FF
        p3 = re.compile(r'^Boot +(?P<boot>\d+) +Hash: +(?P<hash>\S+)$')
        # Boot Loader Version: System Bootstrap, Version 16.10.1r[FC2], DEVELOPMENT SOFTWARE
        p4 = re.compile(r'^Boot +Loader +Version: +(?P<boot_loader_version>[\S ]+)$')
        # Boot Loader Hash: 523DD459C650AF0F5AB5396060605E412C1BE99AF51F4FA88AD26049612921FF
        p5 = re.compile(r'^Boot +Loader +Hash: *(?P<hash>\S+)$')
        # 51CE6FB9AE606330810EBFFE99D71D56640FD48F780EDE0C19FB5A75E31EF2192A58A196D18B244ADF67D18BF6B3AA6A16229C66DCC03D8A900753760B252C57
        p6 = re.compile(r'^(?P<hash>\S+)$')
        # OS Version: 2019-07-11_16.25_mzafar
        p7 = re.compile(r'^OS +Version: +(?P<os_version>\S+)$')
        # OS Hashes:
        p8 = re.compile(r'^OS +Hashes:$')
        # PCR0: BB33E3FE338B82635B1BD3F1401CF442ACC9BB12A405A424FBE0A5776569884E
        p9 = re.compile(r'^(?P<hash_key>\S+): +(?P<hash_val>\S+)$')
        # cat9k_iosxe.2019-07-11_16.25_mzafar.SSA.bin:
        p10 = re.compile(r'^(?P<os_hash>\S+):$')
        # Signature version: 1
        p11 = re.compile(r'^Signature version: +(?P<signature_version>\S+)$')
        # Signature:
        p12 = re.compile(r'^Signature:$')

        for line in output.splitlines():
            line = line.strip()

            # Platform: C9300-24U
            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict.update({'platform': group['platform']})
                continue

            # Boot 0 Version: F01144R16.216e68ad62019-02-13
            m = p2.match(line)
            if m:
                group = m.groupdict()
                boot = int(group['boot'])
                version = group['version']
                boot_dict = ret_dict.setdefault('boot', {}). \
                    setdefault(boot, {})
                boot_dict.update({'version': version})
                continue

            # Boot 0 Hash: 523DD459C650AF0F5AB5396060605E412C1BE99AF51F4FA88AD26049612921FF
            m = p3.match(line)
            if m:
                group = m.groupdict()
                boot = int(group['boot'])
                hash_val = group['hash']
                boot_dict = ret_dict.setdefault('boot', {}). \
                    setdefault(boot, {})
                boot_dict.update({'hash': hash_val})
                continue

            # Boot Loader Version: System Bootstrap, Version 16.10.1r[FC2], DEVELOPMENT SOFTWARE
            m = p4.match(line)
            if m:
                group = m.groupdict()
                boot_loader_dict = ret_dict.setdefault('boot', {}). \
                    setdefault('loader', {})
                boot_loader_version = group['boot_loader_version']
                boot_loader_dict.update({'version': boot_loader_version})
                continue

            # Boot Loader Hash: 523DD459C650AF0F5AB5396060605E412C1BE99AF51F4FA88AD26049612921FF
            m = p5.match(line)
            if m:
                group = m.groupdict()
                hash_val = group['hash']
                hash_type = 'boot_loader'
                boot_loader_dict = ret_dict.setdefault('boot', {}). \
                    setdefault('loader', {})
                boot_loader_hash = ret_dict.get('boot_loader_hash', '')
                boot_loader_hash = '{}{}'.format(boot_loader_hash, hash_val)
                boot_loader_dict.update({'hash': boot_loader_hash})
                continue

            # OS Version: 2019-07-11_16.25_mzafar
            m = p7.match(line)
            if m:
                group = m.groupdict()
                os_version = group['os_version']
                ret_dict.update({'os_version': os_version})
                continue

            # OS Hashes:
            m = p8.match(line)
            if m:
                hash_type = 'os_hashes'
                continue

            # Signature:
            m = p12.match(line)
            if m:
                hash_type = 'signature'
                continue

            # PCR0: BB33E3FE338B82635B1BD3F1401CF442ACC9BB12A405A424FBE0A5776569884E
            m = p9.match(line)
            if m:
                group = m.groupdict()
                hash_type = 'os_hashes'
                group = m.groupdict()
                os_hash = group['hash_key']
                hash_val = group['hash_val']
                os_hash_dict = ret_dict.setdefault('os_hashes', {})
                os_hash_dict.update({os_hash: hash_val})
                continue

            # cat9k_iosxe.2019-07-11_16.25_mzafar.SSA.bin:
            m = p10.match(line)
            if m:
                hash_type = 'os_hashes'
                group = m.groupdict()
                os_hash = group['os_hash']
                os_hash_dict = ret_dict.setdefault('os_hashes', {})
                os_hash_dict.update({os_hash: ''})
                continue

            # Signature version: 1
            m = p11.match(line)
            if m:
                group = m.groupdict()
                ret_dict.update({'signature_version': int(group['signature_version'])})
                continue

            # 51CE6FB9AE606330810EBFFE99D71D56640FD48F780EDE0C19FB5A75E31EF2192A58A196D18B244ADF67D18BF6B3AA6A16229C66DCC03D8A900753760B252C57
            m = p6.match(line)
            if m:
                group = m.groupdict()
                hash_val = group['hash']
                if hash_type == 'boot_loader':
                    boot_loader_hash = boot_loader_dict.get('boot_loader_hash', '')
                    boot_loader_hash = '{}{}'.format(boot_loader_hash, hash_val)
                    boot_loader_dict.update({'hash': boot_loader_hash})
                elif hash_type == 'os_hash':
                    os_hash_val = os_hash_dict.get(os_hash, '')
                    os_hash_val = '{}{}'.format(os_hash_val, hash_val)
                    os_hash_dict.update({'os_hash': os_hash_val})
                elif hash_type == 'signature':
                    ret_dict.update({'signature': hash_val})
                continue

        return ret_dict

    def yang(self, nonce=None, output=None):
        if not output:
            # xpath is the same regardless of if nonce is passed or not
            output = self.device.get(filter=('xpath', '/boot-integrity-oper-data')).data_xml

        log.info(minidom.parseString(output).toprettyxml())

        root = ET.fromstring(output)
        boot_integrity_oper_data = Common.retrieve_xml_child(root=root, key='boot-integrity-oper-data')
        boot_integrity = Common.retrieve_xml_child(root=boot_integrity_oper_data, key='boot-integrity')
        ret_dict = {}
        boot_index = 0
        name = None
        for child in boot_integrity:
            if child.tag.endswith('platform'):
                ret_dict.update({'platform': child.text})
            elif child.tag.endswith('os-version'):
                ret_dict.update({'os_version': child.text})
            elif child.tag.endswith('boot-ver'):
                boot_dict = ret_dict.setdefault('boot', {}). \
                    setdefault(boot_index, {})
                boot_dict.update({'version': child.text})
                boot_index+=1
            elif child.tag.endswith('boot-hash'):
                boot_dict.update({'hash': child.text})
            elif child.tag.endswith('boot-loader-hash'):
                boot_loader_dict = ret_dict.setdefault('boot', {}). \
                    setdefault('loader', {})
                boot_loader_dict.update({'hash': child.text})
            elif child.tag.endswith('boot-loader-ver'):
                boot_loader_dict = ret_dict.setdefault('boot', {}). \
                    setdefault('loader', {})
                boot_loader_dict.update({'version': child.text})
            elif child.tag.endswith('package-signature') or child.tag.endswith('package-integrity'):
                for sub_child in child:
                    os_hashes = ret_dict.setdefault('os_hashes', {})
                    if sub_child.tag.endswith('name'):
                        name = sub_child.text
                    elif name and sub_child.tag.endswith('hash'):
                        os_hashes.update({name: sub_child.text})
                        name = None
            elif child.tag.endswith('pcr-register'):
                for sub_child in child:
                    os_hashes = ret_dict.setdefault('os_hashes', {})
                    if sub_child.tag.endswith('index'):
                        name = 'PCR{}'.format(sub_child.text)
                    elif name and sub_child.tag.endswith('pcr-content'):
                        os_hashes.update({name: sub_child.text})
                        name = None
            elif child.tag.endswith('sig-version'):
                ret_dict.update({'signature_version': int(child.text)})
            elif child.tag.endswith('signature'):
                ret_dict.update({'signature': child.text})
        return ret_dict


# =======================================================================
# Parser for 'show platform hardware qfp active feature appqoe stats all,
# show platform hardware qfp active feature appqoe stats service-node status up'
# =======================================================================
class ShowPlatformHardwareQfpActiveFeatureAppqoeSchema(MetaParser):
    schema = {
        'feature': {
            Any(): {
                'global': {
                    'ip_non_tcp_pkts': int,
                    'not_enabled': int,
                    'cft_handle_pkt': int,
                    'sdvt_divert_req_fail': int,
                    Optional('syn_policer_rate'): int,
                    Optional('sn_data_pkts_processed'): int,
                    Optional('appqoe_srv_chain_non_tcp_bypass'): int,
                    Optional('appqoe_srv_chain_frag_bypass'): int,
                    Optional('appqoe_cvla_alloc_failure'): int,
                    Optional('appqoe_srv_chain_sn_unhealthy_bypass'): int,
                    Optional('appqoe_srv_chain_tcp_mid_flow_bypass'): int,
                    Optional('appqoe_lb_without_dre') : int,
                    Optional('appqoe_alloc_empty_ht_entry'): int,
                    Optional('appqoe_bulk_upd_mem_bm_no_sng'): int,
                    Optional('appqoe_srv_chain_transit_dre_bypass'): int,
                    Optional('appqoe_sn_data_pkts_processed'): int,
                    Optional('appqoe_svc_on_appqoe_vpn_drop') : int,
                    'sdvt_global_stats': {
                        Optional('appnav_registration'): int,
                        Optional('control_decaps_could_not_find_flow_from_tuple'): int,
                        Optional('control_decaps_couldnt_find_sdvt_cft_fo'): int,
                        Optional('sdvt_decaps_couldnt_find_cft_instance_handle'): int,
                        Optional('exceeded_sdvt_syn_policer_limit'): int,
                        Optional('within_sdvt_syn_policer_limit'): int
                    }
                },
                Optional('sng'):{
                    Any():{
                        'sn_index': {
                            Any(): {
                                Optional('ip'): str,
                                Optional('oce_id'): int,
                                Optional('del'): int,
                                Optional('key'): str,
                                Optional('id'): int,
                                Optional('ver'): int,
                                Optional('status'): int,
                                Optional('type'): int,
                                Optional('sng'): int,
                                Optional('appnav_stats'): {
                                    Optional('to_sn'): {
                                        'packets': int,
                                        'bytes': int
                                    },
                                    Optional('from_sn'): {
                                        'packets': int,
                                        'bytes': int
                                    }
                                },
                                'sdvt_count_stats': {
                                    Optional('active_connections'): int,
                                    Optional('decaps'): int,
                                    Optional('encaps'): int,
                                    Optional('packets_unmarked_in_ingress'): int,
                                    Optional('expired_connections'): int,
                                    Optional('idle_timed_out_persistent_connections'): int,
                                    Optional('decap_messages'): {
                                        'processed_control_messages': int,
                                        'delete_requests_recieved': int,
                                        'deleted_protocol_decision': int,
                                        Optional('connections_passed_through_as_intermediate_node'): int,
                                        Optional('connections_dreopt_service_is_cleared'): int
                                    }
                                },
                                'sdvt_packet_stats': {
                                    Optional('divert'): {
                                        'packets': int,
                                        'bytes': int
                                    },
                                    Optional('reinject'): {
                                        'packets': int,
                                        'bytes': int
                                    }
                                },
                                Optional('sdvt_drop_cause_stats'): dict, # This is here because not enough info in output shared
                                Optional('sdvt_errors_stats'): dict, # This is here because not enough info in output shared
                            }
                        }
                    }
                },
                'sn_index': {
                    Any(): {
                        Optional('ip'): str,
                        Optional('oce_id'): int,
                        Optional('del'): int,
                        Optional('key'): str,
                        Optional('id'): int,
                        Optional('ver'): int,
                        Optional('status'): int,
                        Optional('type'): int,
                        Optional('sng'): int,
                        Optional('appnav_stats'): {
                            Optional('to_sn'): {
                                'packets': int,
                                'bytes': int
                            },
                            Optional('from_sn'): {
                                'packets': int,
                                'bytes': int
                            }
                        },
                        'sdvt_count_stats': {
                            Optional('active_connections'): int,
                            Optional('decaps'): int,
                            Optional('encaps'): int,
                            Optional('packets_unmarked_in_ingress'): int,
                            Optional('expired_connections'): int,
                            Optional('idle_timed_out_persistent_connections'): int,
                            Optional('non_syn_divert_requests') : int,
                            Optional('decap_messages'): {
                                'processed_control_messages': int,
                                'delete_requests_recieved': int,
                                'deleted_protocol_decision': int,
                                Optional('connections_passed_through_as_intermediate_node'): int,
                                Optional('connections_dreopt_service_is_cleared'): int
                            }
                        },
                        'sdvt_packet_stats': {
                            Optional('divert'): {
                                'packets': int,
                                'bytes': int
                            },
                            Optional('reinject'): {
                                'packets': int,
                                'bytes': int
                            }
                        },
                        Optional('sdvt_drop_cause_stats'): dict, # This is here because not enough info in output shared
                        Optional('sdvt_errors_stats'): dict, # This is here because not enough info in output shared
                    }
                }
            }
        }
    }

class ShowPlatformHardwareQfpActiveFeatureAppqoe(ShowPlatformHardwareQfpActiveFeatureAppqoeSchema):

    cli_command = ['show platform hardware qfp active feature appqoe stats', 'show platform hardware qfp active feature appqoe stats sng {sng} all']

    def cli(self, sng='', output=None):

        # if the user does not provide output to the parser
        # we need to get it from the device
        if not output:
            if sng:
                output = self.device.execute(self.cli_command[1].format(sng=sng))
            else:
                output = self.device.execute(self.cli_command[0])

        # APPQOE Feature Statistics:
        p1 = re.compile(r'^(?P<feature>\w+) +Feature +Statistics:$')

        # Global:
        p2 = re.compile(r'^Global:$')

        # SDVT Global stats:
        p3 = re.compile(r'^SDVT +Global +stats:$')

        # SN Index [0 (Green)]
        # SN Index [Default]
        p4 = re.compile(r'^SN +Index +\[(?P<index>[\s\S]+)\]$')

        # SNG: 3
        p4_1 = re.compile(r'^SNG: +(?P<sng_index>[\d]+)')

        # SDVT Count stats:
        # SDVT Packet stats:
        # SDVT Drop Cause stats:
        # SDVT Errors stats:
        p5 = re.compile(r'^(?P<sdvt_stats_type>SDVT +[\s\S]+ +stats):$')

        # decaps: Processed control messages from SN: 14200
        # decaps: delete requests received total: 14200
        # decaps: delete - protocol decision: 14200
        p6 = re.compile(r'^decaps: +(?P<decap_type>[\s\S]+): +(?P<value>\d+)$')

        # Divert packets/bytes: 743013/43313261
        # Reinject packets/bytes: 679010/503129551
        p7 = re.compile(r'^(?P<type>Divert|Reinject) +packets\/bytes: +(?P<packets>\d+)\/(?P<bytes>\d+)$')

        # ip-non-tcp-pkts: 0
        # not-enabled: 0
        # cft_handle_pkt:  0
        # sdvt_divert_req_fail:  0
        # syn_policer_rate: 800
        p8 = re.compile(r'^(?P<key>[\s\S]+): +(?P<value>\d+)$')

        # SN Index [0 (Green)], IP: 10.136.1.250, oce_id: 1243618816
        p9 = re.compile(r'^SN +Index +\[(?P<index>[\s\S]+)\], +IP: +(?P<ip>[\s\S]+), +oce_id: +(?P<oce_id>[\s\S]+)$')

        # SNG: 3 SN Index [0 (Green)], IP: 10.136.1.250, oce_id: 1243618816
        p9_1 = re.compile(r'^SNG: +(?P<sng_index>[\d]+) +SN +Index +\[(?P<index>[\s\S]+)\], +IP: +(?P<ip>[\s\S]+), +oce_id: +(?P<oce_id>[\s\S]+)$')

        # del 0, key 0x0301, id 1, ver 1, status 1, type 3, sng 0
        p10 = re.compile(r'^del +(?P<del>[\s\S]+), key +(?P<key>[\s\S]+), id +(?P<id>[\s\S]+), ver +(?P<ver>[\s\S]+), status +(?P<status>[\s\S]+), type +(?P<type>[\s\S]+), sng +(?P<sng>[\s\S]+)$')

        # APPNAV STATS: toSN 2662751642/2206742552009, fromSN 2715505607/2260448392656
        p11 = re.compile(r'^APPNAV STATS: +(?P<to_sn>[\S]+) +(?P<tosn_packets>[\d]+)\/(?P<tosn_bytes>\d+), +(?P<from_sn>[\S]+) +(?P<frmsn_packets>[\d]+)\/(?P<frmsn_bytes>\d+)$')

        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()

            # APPQOE Feature Statistics:
            m = p1.match(line)
            if m:
                groups = m.groupdict()
                feature_name = groups['feature'].lower()
                feature_dict = ret_dict.setdefault('feature', {}).setdefault(feature_name, {})

                last_dict_ptr = feature_dict
                continue

            # Global:
            m = p2.match(line)
            if m:
                global_dict = feature_dict.setdefault('global', {})

                last_dict_ptr = global_dict
                continue

            # SDVT Global stats:
            m = p3.match(line)
            if m:
                sdvt_global_dict = global_dict.setdefault('sdvt_global_stats', {})

                last_dict_ptr = sdvt_global_dict
                continue

            # SN Index [0 (Green)]
            # SN Index [Default]
            m = p4.match(line)
            if m:
                groups = m.groupdict()
                index_dict = feature_dict.setdefault('sn_index', {}).setdefault(groups['index'], {})

                last_dict_ptr = index_dict
                continue

            # SN Index [0 (Green)], IP: 10.136.1.250, oce_id: 1243618816
            m = p9.match(line)
            if m:
                groups = m.groupdict()
                index_dict = feature_dict.setdefault('sn_index', {}).setdefault(groups['index'], {})
                index_dict.update({'ip': groups['ip']})
                index_dict.update({'oce_id': int(groups['oce_id'])})
                last_dict_ptr = index_dict
                continue

            # SNG: 3 SN Index [0 (Green)], IP: 10.136.1.250, oce_id: 1243618816
            m = p9_1.match(line)
            if m:
                groups = m.groupdict()
                index_dict = feature_dict.setdefault('sng', {}).setdefault(groups['sng_index'], {}).setdefault('sn_index', {}).setdefault(groups['index'], {})
                index_dict.update({'ip': groups['ip']})
                index_dict.update({'oce_id': int(groups['oce_id'])})
                last_dict_ptr = index_dict
                continue

            # del 0, key 0x0301, id 1, ver 1, status 1, type 3, sng 0
            m = p10.match(line)
            if m:
                groups = m.groupdict()
                index_dict.update({'del': int(groups['del'])})
                index_dict.update({'key': groups['key']})
                index_dict.update({'id': int(groups['id'])})
                index_dict.update({'ver': int(groups['ver'])})
                index_dict.update({'status': int(groups['status'])})
                index_dict.update({'type': int(groups['type'])})
                index_dict.update({'sng': int(groups['sng'])})

                last_dict_ptr = index_dict
                continue

            # APPNAV STATS: toSN 2662751642/2206742552009, fromSN 2715505607/2260448392656
            m = p11.match(line)
            if m:
                groups = m.groupdict()
                appnav_stats_dict = index_dict.setdefault('appnav_stats', {})
                to_sn_dict = appnav_stats_dict.setdefault('to_sn', {})
                to_sn_dict.update({
                    'packets': int(groups['tosn_packets']),
                    'bytes': int(groups['tosn_bytes'])
                    })
                from_sn_dict = appnav_stats_dict.setdefault('from_sn', {})
                from_sn_dict.update({
                    'packets': int(groups['frmsn_packets']),
                    'bytes': int(groups['frmsn_bytes'])
                    })

                last_dict_ptr = index_dict
                continue

            # SDVT Count stats
            # SDVT Packet stats
            # SDVT Drop Cause stats
            # SDVT Errors stats
            m = p5.match(line)
            if m:
                groups = m.groupdict()
                sdvt_stats_type = groups['sdvt_stats_type'].replace(' ', '_').lower()
                sdvt_stats_type_dict = index_dict.setdefault(sdvt_stats_type, {})

                last_dict_ptr = sdvt_stats_type_dict
                continue

            # decaps: Processed control messages from SN: 14200
            # decaps: delete requests received total: 14200
            # decaps: delete - protocol decision: 14200
            m = p6.match(line)
            if m:
                groups = m.groupdict()
                decap_messages_dict = sdvt_stats_type_dict.setdefault('decap_messages', {})

                if 'control messages' in groups['decap_type']:
                    decap_messages_dict.update({'processed_control_messages': int(groups['value'])})

                elif 'delete requests' in groups['decap_type']:
                    decap_messages_dict.update({'delete_requests_recieved': int(groups['value'])})

                elif 'protocol decision' in groups['decap_type']:
                    decap_messages_dict.update({'deleted_protocol_decision': int(groups['value'])})

                last_dict_ptr = decap_messages_dict
                continue

            # Divert packets/bytes: 743013/43313261
            # Reinject packets/bytes: 679010/503129551
            m = p7.match(line)
            if m:
                groups = m.groupdict()

                if 'Divert' in groups['type']:
                    divert_reinject_dict = sdvt_stats_type_dict.setdefault('divert', {})
                elif 'Reinject' in groups['type']:
                    divert_reinject_dict = sdvt_stats_type_dict.setdefault('reinject', {})

                divert_reinject_dict.update({
                    'packets': int(groups['packets']),
                    'bytes': int(groups['bytes'])
                })

                last_dict_ptr = divert_reinject_dict
                continue

            # ip-non-tcp-pkts: 0
            # not-enabled: 0
            # cft_handle_pkt:  0
            # sdvt_divert_req_fail:  0
            # syn_policer_rate: 800
            m = p8.match(line)
            if m:
                groups = m.groupdict()
                key = groups['key'].replace('-', '_').replace(' ', '_').replace(':', '').lower()
                last_dict_ptr.update({key: int(groups['value'])})
                continue

        return ret_dict


class ShowPlatformTcamUtilizationSchema(MetaParser):
    """Schema for show platform hardware fed sw active fwd-asic resource tcam utilization """
    schema = {
        'asic': {
            Any(): {
                'table': {
                    Any(): {
                        'subtype': {
                            Any(): {
                                'dir': {
                                    Any(): {
                                        'max': str,
                                        'used': str,
                                        'used_percent': str,
                                        'v4': str,
                                        'v6': str,
                                        'mpls': str,
                                        'other': str,
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }


class ShowPlatformTcamUtilization(ShowPlatformTcamUtilizationSchema):
    """Parser for show platform hardware fed sw active fwd-asic resource tcam utilization """

    cli_command = ['show platform hardware fed {switch} active fwd-asic resource tcam utilization','show platform hardware fed active fwd-asic resource tcam utilization']

    def cli(self, output=None, switch=''):
        if output is None:
            if switch:
                cmd = self.cli_command[0].format(switch=switch)
            else:
                cmd = self.cli_command[1]
            output = self.device.execute(cmd)

        # initial return dictionary
        ret_dict = {}

        # initial regexp pattern
        # CAM Utilization for ASIC  [0]
        p1 = re.compile(r'CAM +Utilization +for +ASIC  +\[+(?P<asic>(\d+))\]$')

        #CTS Cell Matrix/VPN
        #Label                  EM           O       16384        0    0.00%        0        0        0        0
        #CTS Cell Matrix/VPN
        #Label                  TCAM         O        1024        1    0.10%        0        0        0        1
        # Mac Address Table      EM           I       16384       44    0.27%        0        0        0       44
        # Mac Address Table      TCAM         I        1024       21    2.05%        0        0        0       21
        p2 = re.compile(r'(?P<table>.*(\S+)) +(?P<subtype>\S+) +(?P<dir>\S+) +(?P<max>\d+) +(?P<used>\d+) +(?P<used_percent>\S+\%) +(?P<v4>\d+) +(?P<v6>\d+) +(?P<mpls>\d+) +(?P<other>\d+)$')


        for line in output.splitlines():
            line = line.strip()

            # CAM Utilization for ASIC  [0]
            m = p1.match(line)
            if m:
                group = m.groupdict()
                asic = group['asic']
                asic_dict = ret_dict.setdefault('asic', {}).setdefault(asic, {})
                continue

            #CTS Cell Matrix/VPN
            #Label                  EM           O       16384        0    0.00%        0        0        0        0
            #CTS Cell Matrix/VPN
            #Label                  TCAM         O        1024        1    0.10%        0        0        0        1
            # Mac Address Table      EM           I       16384       44    0.27%        0        0        0       44
            # Mac Address Table      TCAM         I        1024       21    2.05%        0        0        0       21
            m = p2.match(line)
            if m:
                group = m.groupdict()
                table_ = group.pop('table')
                if table_ == 'Label':
                    table_ = 'CTS Cell Matrix/VPN Label'
                subtype_ = group.pop('subtype')
                dir_ = group.pop('dir')
                dir_dict = asic_dict.setdefault('table', {}). \
                            setdefault(table_, {}). \
                            setdefault('subtype', {}). \
                            setdefault(subtype_, {}). \
                            setdefault('dir', {}). \
                            setdefault(dir_, {})
                dir_dict.update({k: v for k, v in group.items()})
                continue

        return ret_dict

class ShowPlatformHardwareQfpActiveDatapathUtilSumSchema(MetaParser):

    schema = {
        'cpp': {
            Any(): {
                Any(): {
                    'pps': {
                        '5_secs': int,
                        '1_min': int,
                        '5_min': int,
                        '60_min': int
                    },
                    'bps': {
                        '5_secs': int,
                        '1_min': int,
                        '5_min': int,
                        '60_min': int
                    }
                },
                'processing': {
                    'load_pct': {
                        '5_secs': int,
                        '1_min': int,
                        '5_min': int,
                        '60_min': int
                    }
                },
                Optional('crypto_io'): {
                    'crypto_load_pct': {
                        '5_secs': int,
                        '1_min': int,
                        '5_min': int,
                        '60_min': int
                    },
                    'rx_load_pct': {
                        '5_secs': int,
                        '1_min': int,
                        '5_min': int,
                        '60_min': int
                    },
                    'tx_load_pct': {
                        '5_secs': int,
                        '1_min': int,
                        '5_min': int,
                        '60_min': int
                    },
                    'idle_pct': {
                        '5_secs': int,
                        '1_min': int,
                        '5_min': int,
                        '60_min': int
                    }
                }
            }
        }
    }


class ShowPlatformHardwareQfpActiveDatapathUtilSum(ShowPlatformHardwareQfpActiveDatapathUtilSumSchema):

    cli_command = ['show platform hardware qfp active datapath utilization summary']

    def cli(self, output=None):

        # if the user does not provide output to the parser
        # we need to get it from the device
        if not output:
            output = self.device.execute(self.cli_command[0])

        #CPP 0:                     5 secs        1 min        5 min       60 min
        p1 = re.compile(r'^CPP (?P<cpp_num>\d)\: +(\d\s\S+) +(\d\s\S+) +(\d\s\S+) +(\d+\s\S+)$')
        #Crypto/IO
        p2 = re.compile(r'^Crypto/IO$')
        #Input:     Total (pps)            2            2            1            0
        p3 = re.compile(r'^(?P<dir>\w+)\: +\S+ \((?P<type>\S+)\) +(?P<value_5s>\d+) +(?P<value_1m>\d+) +(?P<value_5m>\d+) +(?P<value_60m>\d+)$')
        #(bps)         2928         1856         1056           88
        #Idle (pct)           43           35           35           75
        p4 = re.compile(r'^(Idle )?\((?P<type>bps|pct)\) +(?P<value_5s>\d+) +(?P<value_1m>\d+) +(?P<value_5m>\d+) +(?P<value_60m>\d+)$')

        ret_dict = {}
        for line in output.splitlines():
            line = line.strip()
            #   CPP 0:                     5 secs        1 min        5 min       60 min
            m = p1.match(line)
            if m:
                groups = m.groupdict()
                cpp_number = groups['cpp_num'].lower()
                feature_dict = ret_dict.setdefault('cpp', {}).setdefault(cpp_number, {})
                last_dict_ptr = feature_dict
                continue

            #Crypto/IO
            m = p2.match(line)
            if m:
                groups = m.groupdict()
                feature_dict = feature_dict.setdefault('crypto_io', {})
                last_dict_ptr = feature_dict
                continue

            #Input:     Total (pps)            2            2            1            0
            #Processing: Load (pct)            0            0            0            0
            m = p3.match(line)
            if m:
                groups = m.groupdict()
                if groups['dir'].strip() in ['Crypto','RX','TX','Idle']:
                    key = "{a}_load_{b}".format(a=groups['dir'].strip().lower(), b=groups['type'].strip().lower())
                    dir_dict = feature_dict.setdefault(key, {})
                    dir_dict.update({'5_secs': int(groups['value_5s'])})
                    dir_dict.update({'1_min': int(groups['value_1m'])})
                    dir_dict.update({'5_min': int(groups['value_5m'])})
                    dir_dict.update({'60_min': int(groups['value_60m'])})
                    last_dict_ptr = dir_dict
                    continue
                else:
                    dir_dict = feature_dict.setdefault(groups['dir'].lower(), {})
                    if 'pct' in groups['type']:
                        key = 'load_' + groups['type']
                    else:
                        key = groups['type']
                    type_dict = dir_dict.setdefault(key, {})
                    type_dict.update({'5_secs': int(groups['value_5s'])})
                    type_dict.update({'1_min': int(groups['value_1m'])})
                    type_dict.update({'5_min': int(groups['value_5m'])})
                    type_dict.update({'60_min': int(groups['value_60m'])})
                    last_dict_ptr = type_dict
                    continue

            #(bps)         2928         1856         1056           88
            #Idle (pct)           43           35           35           75
            m = p4.match(line)
            if m:
                groups = m.groupdict()
                if 'pct' in groups['type']:
                    key = "idle_{t}".format(t=groups['type'])
                    type_dict = feature_dict.setdefault(key, {})
                    type_dict.update({'5_secs': int(groups['value_5s'])})
                    type_dict.update({'1_min': int(groups['value_1m'])})
                    type_dict.update({'5_min': int(groups['value_5m'])})
                    type_dict.update({'60_min': int(groups['value_60m'])})
                    last_dict_ptr = type_dict
                else:
                    type_dict = dir_dict.setdefault(groups['type'], {})
                    type_dict.update({'5_secs': int(groups['value_5s'])})
                    type_dict.update({'1_min': int(groups['value_1m'])})
                    type_dict.update({'5_min': int(groups['value_5m'])})
                    type_dict.update({'60_min': int(groups['value_60m'])})
                    last_dict_ptr = type_dict
                    continue

        return ret_dict

# =======================================================================
# Schema for 'show platform hardware qfp active tcam resource-manager usage'
# =======================================================================
class ShowPlatformHardwareQfpActiveTcamResourceManagerUsageSchema(MetaParser):
     schema = {
                'qfp_tcam_usage_information': {
                    Any(): {
                        'name': str,
                        'number_of_cells_per_entry': int,
                        Optional('current_80_bit_entries_used'): int,
                        Optional('current_160_bits_entries_used'): int,
                        Optional('current_320_bits_entries_used'): int,
                        'current_used_cell_entries': int,
                        'current_free_cell_entries': int
                        },
                    'total_tcam_cell_usage_information': {
                        'name': str,
                        'total_number_of_regions': int,
                        'total_tcam_used_cell_entries': int,
                        'total_tcam_free_cell_entries': int,
                        'threshold_status': str
                        }
                    }
                }

# =======================================================================
# Parser for 'show platform hardware qfp active tcam resource-manager usage'
# =======================================================================
class ShowPlatformHardwareQfpActiveTcamResourceManagerUsage(ShowPlatformHardwareQfpActiveTcamResourceManagerUsageSchema):

    cli_command = ['show platform hardware qfp active tcam resource-manager usage']


    def cli(self, output=None):

        # if the user does not provide output to the parser
        # we need to get it from the device
        if not output:
            output = self.device.execute(self.cli_command[0])

        #QFP TCAM Usage Information
        p1 = re.compile(r'^(?P<key>QFP TCAM Usage Information)$')

        #80 Bit Region Information
        #Total TCAM Cell Usage Information
        p2 = re.compile(r'^(?P<num>\d+|Total TCAM)(?P<region>[\s\S]+)$')

        # Name                                : Leaf Region #1
        # Number of cells per entry           : 2
        # Current 160 bits entries used       : 19
        # Current used cell entries           : 38
        # Current free cell entries           : 4058
        p3 = re.compile(r'^(?P<key>[\s\S]+)\:(?P<value>[\s\S]+\S)$')


        ret_dict = {}
        for line in output.splitlines():
            line = line.strip()

            #QFP TCAM Usage Information
            m = p1.match(line)
            if m:
                groups = m.groupdict()
                key1 = groups['key'].replace(' ','_').lower()
                feature_dict = ret_dict.setdefault(key1, {})
                continue

            #80 Bit Region Information
            #Total TCAM Cell Usage Information
            m = p2.match(line)
            if m:
                groups = m.groupdict()
                reg = groups['region'].strip().replace(' ','_').lower()
                reg_name = groups['num'].replace(' ','_').lower() +'_'+reg
                region_hash = feature_dict.setdefault(reg_name, {})
                continue

            # Name                                : Leaf Region #1
            # Number of cells per entry           : 2
            # Current 160 bits entries used       : 19
            # Current used cell entries           : 38
            # Current free cell entries           : 4058
            m = p3.match(line)
            if m:
                groups = m.groupdict()
                name = groups['key'].strip().replace(' ','_').lower()
                val = groups['value'].strip()
                if name not in ['threshold_status', 'name']:
                    val = int(groups['value'])

                region_hash.update({name : val})
                continue


        return ret_dict

# =======================================================================
# Schema for 'show platform resources'
# =======================================================================
class ShowPlatformResourcesSchema(MetaParser):
    schema = {
        Optional('rp'): {
            Any():  {

            'state': str,
            'role': str,
            'control_processer': {
                'usage_perc': float,
                'max_perc': int,
                'warning_perc': int,
                'critical_perc': int,
                'state': str,
                'dram': {
                    'usage_mb': int,
                    'usage_perc': int,
                    'max_mb': int,
                    'warning_perc': int,
                    'critical_perc': int,
                    'state': str
                },
                Optional('bootflash'): {
                'usage_mb': int,
                'usage_perc': int,
                'max_mb': int,
                'warning_perc': int,
                'critical_perc': int,
                'state': str
                },
                Optional('harddisk'): {
                'usage_mb': int,
                'usage_perc': int,
                'max_mb': int,
                'warning_perc': int,
                'critical_perc': int,
                'state': str
                }
            }
            }
        },
        Optional('esp'): {
            Any(): {
                'state': str,
                'role': str,
                Optional('control_processer'): {
                    'usage_perc': float,
                    'max_perc': int,
                    'warning_perc': int,
                    'critical_perc': int,
                    'state': str,
                    'dram': {
                        'usage_mb': int,
                        'usage_perc': int,
                        'max_mb': int,
                        'warning_perc': int,
                        'critical_perc': int,
                        'state': str
                    }
                },
                'qfp': {
                    'state': str,
                    Optional('tcam'): {
                        'usage_cells': int,
                        'usage_perc': int,
                        'max_cells': int,
                        'warning_perc': int,
                        'critical_perc': int,
                        'state': 'H'
                    },
                    'dram': {
                        'usage_kb': int,
                        'usage_perc': int,
                        'max_kb': int,
                        'warning_perc': int,
                        'critical_perc': int,
                        'state': str
                    },
                    'iram': {
                        'usage_kb': int,
                        'usage_perc': int,
                        'max_kb': int,
                        'warning_perc': int,
                        'critical_perc': int,
                        'state': str
                    },
                    'cpu_utilization': {
                        'usage_perc': float,
                        'max_perc': int,
                        'warning_perc': int,
                        'state': str
                    },
                    Optional(Any()): {
                        'usage_kb': int,
                        'usage_perc': int,
                        'max_kb': int,
                        'warning_perc': int,
                        'critical_perc': int,
                        'state': str
                    }
                }
            }
        },
        Optional('sip'): {
            Any(): {
                'state': str,
                'control_processer': {
                    'usage_perc': float,
                    'max_perc': int,
                    'warning_perc': int,
                    'critical_perc': int,
                    'state': str,
                    'dram': {
                        'usage_mb': int,
                        'usage_perc': int,
                        'max_mb': int,
                        'warning_perc': int,
                        'critical_perc': int,
                        'state': str
                    }
                }
            }
        },
        Optional('control_processer'): {
                'usage_perc': float,
                'max_perc': int,
                'warning_perc': int,
                'critical_perc': int,
                'state': str,
                'dram': {
                    'usage_mb': int,
                    'usage_perc': int,
                    'max_mb': int,
                    'warning_perc': int,
                    'critical_perc': int,
                    'state': str
                },
                Optional('tmpfs'):{
                    'usage_mb': int,
                    'usage_perc': int,
                    'max_mb': int,
                    'warning_perc': int,
                    'critical_perc': int,
                    'state': str
                }
        }
    }

# =======================================================================
# Parser for 'show platform resources'
# =======================================================================
class ShowPlatformResources(ShowPlatformResourcesSchema):

    cli_command = ['show platform resources']


    def cli(self, output=None):

        # if the user does not provide output to the parser
        # we need to get it from the device
        if not output:
            output = self.device.execute(self.cli_command[0])


        #RP0 (ok, active)                                                                               H
        #RP1 (ok, standby)                                                                               H
        #ESP0(ok, active)                                                                               H
        #ESP1(ok, standby)                                                                               H
        p1 = re.compile(r'^(?P<type>RP|ESP)(?P<key>[0-9]) ?\((?P<status>\S+)\, +(?P<role>\S+)\) +(?P<state>\S)$')

        #SIP0                                                                                           H
        p2 = re.compile(r'^SIP(?P<key>[0-9]) +(?P<state>\S)$')

        # Control Processor       0.51%                 100%            80%             90%             H
        p3 = re.compile(r'^Control Processor +(?P<usage>(\d*\.?\d+))\S+ +(?P<max>\d+)\S+ +(?P<warning>\d+)\S+ +(?P<critical>\d+)\S+ +(?P<state>\S)$')

        #QFP                                                                                           H
        p4 = re.compile(r'^QFP +(?P<state>\S)$')

        #CPU Utilization        0.00%                 100%            90%             95%             H
        p5 = re.compile(r'^(?P<resource>[\S\s]+\S) +(?P<usage>(\d*\.?\d+))\S+ +(?P<max>\d+)\S+ +(?P<warning>\d+)\S+ +(?P<critical>\d+)\S+ +(?P<state>\S)$')

        # TCAM                   16cells(0%)           1048576cells    65%             85%             H
        # DRAM                   238906KB(5%)          4194304KB       85%             95%             H
        # IRAM                   13014KB(9%)           131072KB        85%             95%             H
        p6 = re.compile(r'^(?P<resource>[\s\S]+\S) +(?P<use_val>(\d*\.?\d+))(?P<type>\S+)\((?P<val>\d+)\%\) +(?P<max>\d+)(?P<max_type>\S+) +(?P<warning>\d+)\S+ +(?P<critical>\d+)\S+ +(?P<state>\S)$')


        ret_dict = {}
        feature_dict = ret_dict
        for line in output.splitlines():
            line = line.strip()

            #RP1 (ok, standby)                                                                               H
            #ESP0 (ok, active)                                                                               H
            m = p1.match(line)

            if m:
                groups = m.groupdict()
                type_ = groups['type'].lower()

                feature_dict = ret_dict.setdefault(type_, {}).setdefault(groups['key'], {})

                feature_dict.update(({'state': (groups['state'])}))
                feature_dict.update(({'role': (groups['role'])}))

                last_dict_ptr1 = feature_dict
                continue

            #SIP0                                                                                           H
            m = p2.match(line)
            if m:
                groups = m.groupdict()
                feature_dict = ret_dict.setdefault('sip', {}).setdefault(groups['key'], {})
                feature_dict.update(({'state': (groups['state'])}))
                last_dict_ptr1 = feature_dict
                continue

            # Control Processor       0.51%                 100%            80%             90%             H
            m = p3.match(line)
            if m:
                groups = m.groupdict()
                feature_dict = feature_dict.setdefault('control_processer', {})
                feature_dict.update({'usage_perc': float(groups['usage'])})
                feature_dict.update({'max_perc': int(groups['max'])})
                feature_dict.update({'warning_perc': int(groups['warning'])})
                feature_dict.update({'critical_perc': int(groups['critical'])})
                feature_dict.update({'state': (groups['state'])})
                last_dict_ptr = feature_dict
                continue

            #QFP                                                                                           H
            m = p4.match(line)
            if m:
                groups = m.groupdict()
                feature_dict = last_dict_ptr1
                feature_dict = feature_dict.setdefault('qfp', {})
                feature_dict.update({'state': (groups['state'])})
                last_dict_ptr = feature_dict
                continue

            #CPU Utilization        0.00%                 100%            90%             95%             H
            m = p6.match(line)
            if m:
                groups = m.groupdict()
                feature_dict = last_dict_ptr
                res1 = groups['resource'].replace(' ','_').replace('(','').replace(')','').lower()
                feature_dict = feature_dict.setdefault(res1,{})
                feature_dict.update({'usage_' + groups['type'].lower(): int(groups['use_val'])})
                feature_dict.update({'usage_perc': int(groups['val'])})
                feature_dict.update({'max_' + groups['max_type'].lower(): int(groups['max'])})
                feature_dict.update({'warning_perc': int(groups['warning'])})
                feature_dict.update({'critical_perc': int(groups['critical'])})
                feature_dict.update({'state': (groups['state'])})
                continue

            #TCAM                   16cells(0%)           1048576cells    65%             85%             H
            # DRAM                   238906KB(5%)          4194304KB       85%             95%             H
            # IRAM                   13014KB(9%)           131072KB        85%             95%             H
            m = p5.match(line)
            if m:
                groups = m.groupdict()
                feature_dict = last_dict_ptr
                res1 = groups['resource'].replace(' ','_').replace('(','').replace(')','').lower()
                feature_dict = feature_dict.setdefault(res1,{})
                feature_dict.update({'usage_perc': float(groups['usage'])})
                feature_dict.update({'max_perc': int(groups['max'])})
                feature_dict.update({'warning_perc': int(groups['warning'])})
                feature_dict.update({'state': (groups['state'])})
                continue

        return(ret_dict)


class ShowPlatformSoftwareYangManagementProcessSchema(MetaParser):
    '''schema for
        * show platform software yang-management process
    '''

    schema = {
        str: str
    }

class ShowPlatformSoftwareYangManagementProcess(ShowPlatformSoftwareYangManagementProcessSchema):
    '''parser for
        * show platform software yang-management process
    '''

    cli_command = "show platform software yang-management process"

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        # confd            : Running
        # pubd             : Running
        # gnmib            : Not Running
        p1 = re.compile(r'^(?P<key>\S+) *: +(?P<data>(Running|Not +Running))$')

        ret_dict = dict()

        for line in out.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict.update({
                    group['key']: group['data']
                })
                continue

        return ret_dict


class ShowPlatformSoftwareYangManagementProcessMonitorSchema(MetaParser):
    '''schema for
        * show platform software yang-management process monitor
    '''

    schema = {
        'pid': {
            int: {
                'command': str,
                'state': str,
                'vsz': int,
                'rss': int,
                'cpu': float,
                'mem': float,
                'elapsed': str,
            }
        }
    }

class ShowPlatformSoftwareYangManagementProcessMonitor(ShowPlatformSoftwareYangManagementProcessMonitorSchema):
    '''parser for
        * show platform software yang-management process monitor
    '''

    cli_command = "show platform software yang-management process monitor"

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        # dmiauthd          551 S 376940 49600  0.0  0.6    21:44:33
        # ncsshd           1503 S 301344 17592  0.0  0.2    21:44:32
        p1 = re.compile(r'^(?P<command>\S+) +(?P<pid>\d+) +(?P<s>\S+) +(?P<vsz>\d+) +'
                        r'(?P<rss>\d+) +(?P<cpu>\S+) +(?P<mem>\S+) +(?P<elapsed>\S+)$')

        ret_dict = dict()

        for line in out.splitlines():
            line = line.strip()

            # dmiauthd          551 S 376940 49600  0.0  0.6    21:44:33
            # ncsshd           1503 S 301344 17592  0.0  0.2    21:44:32
            m = p1.match(line)
            if m:
                group = m.groupdict()
                commands = ret_dict.setdefault('pid', {})
                command = commands.setdefault(int(group['pid']), {})
                command.update({
                    'command': group['command'],
                    'state': group['s'],
                    'vsz': int(group['vsz']),
                    'rss': int(group['rss']),
                    'cpu': float(group['cpu']),
                    'mem': float(group['mem']),
                    'elapsed': group['elapsed'],
                })
                continue

        return ret_dict


class ShowPlatformSoftwareYangManagementProcessStateSchema(MetaParser):
    '''schema for
        * show platform software yang-management process state
    '''

    schema = {
        'confd-status': str,
        'processes': {
            str: {
                'status': str,
                'state': str,
                },
            }
        }

class ShowPlatformSoftwareYangManagementProcessState(ShowPlatformSoftwareYangManagementProcessStateSchema):
    '''parser for
        * show platform software yang-management process state
    '''

    cli_command = "show platform software yang-management process state"

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        # Confd Status: Started
        # Confd Status: Not Running
        p1 = re.compile(r'^Confd +Status: +(?P<status>.+)$')

        # pubd                 Running             Active
        # gnmib                Not Running         Not Applicable
        # ndbmand              Not Running         Down
        # pubd                 Running             Reset
        p2 = re.compile(r'^(?P<process>\S+) +(?P<status>(Running|Not +Running)) +'
                        r'(?P<state>(Active|Not +Active|Not +Applicable|Down|Reset|Init|Failed|Invalid))$')

        ret_dict = dict()

        for line in out.splitlines():
            line = line.strip()

            # Confd Status: Started
            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict['confd-status'] = group['status']
                continue

            # pubd                 Running             Active
            # gnmib                Not Running         Not Applicable
            # ndbmand              Not Running         Down
            m = p2.match(line)
            if m:
                group = m.groupdict()
                commands = ret_dict.setdefault('processes', {})
                command = commands.setdefault(group['process'], {})
                command.update({
                    'status': group['status'],
                    'state': group['state'],
                })
                continue

        return ret_dict

class ShowPlatformSoftwareMemoryRpActiveSchema(MetaParser):
    """ Schema for
        * show platform software memory mdt-pubd RP active
    """
    schema = {
        'module': {
            Any(): {
                'allocated': int,
                'requested': int,
                'overhead': int,
                Optional('allocations'): int,
                Optional('failed'): int,
                Optional('frees'): int,
            }
        }
    }

class ShowPlatformSoftwareMemoryRpActive(ShowPlatformSoftwareMemoryRpActiveSchema):
    """ Parser for
        * show platform software memory mdt-pubd RP active
    """

    cli_command = 'show platform software memory {process} RP active'

    def cli(self, process, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(process=process))
        else:
            out = output

        ret_dict = {}

        # Module: process
        p1 = re.compile(r'Module: +(?P<module>[\S\s]+)$')

        # allocated: 16695, requested: 16647, overhead: 48
        p2 = re.compile(r'allocated: +(?P<allocated>\d+), +requested: +'
            r'(?P<requested>\d+), +overhead: +(?P<overhead>\d+)$')

        # Allocations: 3, failed: 0, frees: 0
        p3 = re.compile(r'Allocations: +(?P<allocations>\d+), +failed: +'
            r'(?P<failed>\d+), +frees: +(?P<frees>\d+)$')

        for line in out.splitlines():
            line = line.strip()

            # Module: process
            m = p1.match(line)
            if m:
                group = m.groupdict()
                module = group.get('module')
                module_dict = ret_dict.setdefault('module', {}). \
                    setdefault(module, {})
                continue

            # allocated: 16695, requested: 16647, overhead: 48
            m = p2.match(line)
            if m:
                group = m.groupdict()
                module_dict.update({k:int(v) for k, v in group.items() if v is not None})
                continue

            # Allocations: 3, failed: 0, frees: 0
            m = p3.match(line)
            if m:
                group = m.groupdict()
                module_dict.update({k:int(v) for k, v in group.items() if v is not None})
                continue

        return ret_dict

class ShowPlatformSoftwareMemorySwitchActive(ShowPlatformSoftwareMemoryRpActive):
    """ Parser for
        * show platform software memory mdt-pubd switch active <R0>
    """

    cli_command = 'show platform software memory {process} switch active {slot}'

    def cli(self, process, slot, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(
                process=process,
                slot=slot))
        else:
            out = output

        return super().cli(process=process, output=out)

class ShowPlatformSoftwareMemoryChassisActive(ShowPlatformSoftwareMemoryRpActive):
    """ Parser for
        * show platform software memory mdt-pubd chassis active <R0>
    """

    cli_command = 'show platform software memory {process} chassis active {slot}'

    def cli(self, process, slot, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(
                process=process,
                slot=slot))
        else:
            out = output

        return super().cli(process=process, output=out)

class ShowPlatformSoftwareMemoryRpActiveBriefSchema(MetaParser):
    """ Schema for
        * show platform software memory mdt-pubd RP active brief
    """
    schema = {
        'module': {
            Any(): {
                'allocated': int,
                'requested': int,
                'allocs': int,
                'frees': int,
            }
        }
    }

class ShowPlatformSoftwareMemoryRpActiveBrief(ShowPlatformSoftwareMemoryRpActiveBriefSchema):
    """ Parser for
        * show platform software memory mdt-pubd RP active brief
    """

    cli_command = 'show platform software memory {process} RP active brief'

    def cli(self, process, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(process=process))
        else:
            out = output

        ret_dict = {}

        # Summary                 420136        364136        3706          206
        p1 = re.compile(r'^(?P<module>\S+) +(?P<allocated>\d+) +'
            r'(?P<requested>\d+) +(?P<allocs>\d+) +(?P<frees>\d+)$')

        for line in out.splitlines():
            line = line.strip()

            # Summary                 420136        364136        3706          206
            m = p1.match(line)
            if m:
                group = m.groupdict()
                module = group.pop('module')
                module_dict = ret_dict.setdefault('module', {}). \
                    setdefault(module, {})
                module_dict.update({k:int(v) for k, v in group.items() if v is not None})
                continue

        return ret_dict

class ShowPlatformSoftwareMemorySwitchActiveBrief(ShowPlatformSoftwareMemoryRpActiveBrief):
    """ Parser for
        * show platform software memory mdt-pubd switch active R0 brief
    """

    cli_command = 'show platform software memory {process} switch active {slot} brief'

    def cli(self, process, slot, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(
                process=process,
                slot=slot))
        else:
            out = output

        return super().cli(process=process, output=out)

class ShowPlatformSoftwareMemoryChassisActiveBrief(ShowPlatformSoftwareMemoryRpActiveBrief):
    """ Parser for
        * show platform software memory mdt-pubd chassis active R0 brief
    """

    cli_command = 'show platform software memory {process} chassis active {slot} brief'

    def cli(self, process, slot, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(
                process=process,
                slot=slot))
        else:
            out = output

        return super().cli(process=process, output=out)

class ShowPlatformSoftwareMemoryRpActiveAllocCallsiteSchema(MetaParser):
    """ Schema for
        * show platform software memory mdt-pubd RP active alloc callsite
    """
    schema = {
        'callsite': {
            Any(): {
                'thread_id': int,
                'allocs': int,
                'frees': int,
                'alloc_bytes': int,
                'free_bytes': int,
                'call_diff': int,
                'byte_diff': int
            }
        }
    }

class ShowPlatformSoftwareMemoryRpActiveAllocCallsite(ShowPlatformSoftwareMemoryRpActiveAllocCallsiteSchema):
    """ Parser for
        * show platform software memory mdt-pubd RP active alloc callsite
    """

    cli_command = 'show platform software memory {process} RP active alloc callsite'

    def cli(self, process, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(process=process))
        else:
            out = output

        ret_dict = {}

        # callsite: 1355696130, thread_id: 24813
        p1 = re.compile(r'^callsite: +(?P<callsite>\d+), +thread_id: +(?P<thread_id>\d+)$')

        # allocs: 138151, frees: 138141, alloc_bytes: 15466123, free_bytes: 15464846, call_diff: 10, byte_diff: 1277
        p2 = re.compile(r'^allocs: +(?P<allocs>\d+), +frees: +(?P<frees>\d+), +'
            r'alloc_bytes: +(?P<alloc_bytes>\d+), +free_bytes: +(?P<free_bytes>\d+), +'
            r'call_diff: +(?P<call_diff>\d+), +byte_diff: +(?P<byte_diff>\d+)$')

        for line in out.splitlines():
            line = line.strip()

            # callsite: 1355696130, thread_id: 24813
            m = p1.match(line)
            if m:
                group = m.groupdict()
                callsite = group.get('callsite')
                thread_id = group.get('thread_id')
                thread_dict = ret_dict.setdefault('callsite', {}). \
                    setdefault(callsite, {})
                thread_dict.update({'thread_id': int(thread_id)})
                continue

            # allocs: 138151, frees: 138141, alloc_bytes: 15466123, free_bytes: 15464846, call_diff: 10, byte_diff: 1277
            m = p2.match(line)
            if m:
                group = m.groupdict()
                thread_dict.update({k:int(v) for k, v in group.items() if v is not None})
                continue

        return ret_dict

class ShowPlatformSoftwareMemorySwitchActiveAllocCallsite(ShowPlatformSoftwareMemoryRpActiveAllocCallsite):
    """ Parser for
        * show platform software memory mdt-pubd switch active <R0> alloc callsite
    """

    cli_command = 'show platform software memory {process} switch active {slot} alloc callsite'

    def cli(self, process, slot, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(
                process=process,
                slot=slot))
        else:
            out = output

        return super().cli(process=process, output=out)

class ShowPlatformSoftwareMemoryRpActiveAllocCallsiteBriefSchema(MetaParser):
    """ Schema for
        * show platform software memory mdt-pubd RP active alloc callsite
    """
    schema = {
        'tracekey': str,
        'callsite': {
            Any(): {
                'thread_id': int,
                'diff_byte': int,
                'diff_call': int,
            }
        }
    }

class ShowPlatformSoftwareMemoryRpActiveAllocCallsiteBrief(ShowPlatformSoftwareMemoryRpActiveAllocCallsiteBriefSchema):
    """ Parser for
        * show platform software memory mdt-pubd RP active alloc callsite brief
    """

    cli_command = 'show platform software memory {process} RP active alloc callsite brief'

    def cli(self, process, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(process=process))
        else:
            out = output

        ret_dict = {}

        # callsite: 1355696130, thread_id: 24813
        p1 = re.compile(r'^The +current +tracekey +is +: +(?P<tracekey>\S+)$')

        # allocs: 138151, frees: 138141, alloc_bytes: 15466123, free_bytes: 15464846, call_diff: 10, byte_diff: 1277
        p2 = re.compile(r'^(?P<callsite>\d+) +(?P<thread_id>\d+) +(?P<diff_byte>\d+) +(?P<diff_call>\d+)$')

        for line in out.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict.update({'tracekey': group['tracekey']})
                continue

            # callsite: 1355696130, thread_id: 24813
            m = p2.match(line)
            if m:
                group = m.groupdict()
                callsite = group.pop('callsite')
                thread_id = group.pop('thread_id')
                thread_dict = ret_dict.setdefault('callsite', {}). \
                    setdefault(callsite, {})
                thread_dict.update({'thread_id': int(thread_id)})
                thread_dict.update({k:int(v) for k, v in group.items() if v is not None})
                continue

        return ret_dict

class ShowPlatformSoftwareMemoryRpActiveAllocTypeSchema(MetaParser):
    """ Schema for
        * show platform software memory mdt-pubd RP active alloc type component
    """
    schema = {
        Optional('module'): {
            Any(): {
                'allocated': int,
                'requested': int,
                'overhead': int,
                'allocations': int,
                'null_allocations': int,
                'frees': int,
            }
        },
        Optional('type'): {
            Any(): {
                'allocated': int,
                'requested': int,
                'overhead': int,
                'allocations': int,
                'null_allocations': int,
                'frees': int,
            }
        },
    }

class ShowPlatformSoftwareMemoryRpActiveAllocType(ShowPlatformSoftwareMemoryRpActiveAllocTypeSchema):
    """ Parser for
        * show platform software memory mdt-pubd RP active alloc type component
        * show platform software memory mdt-pubd RP active alloc type data
    """

    cli_command = 'show platform software memory {process} RP active alloc type {alloc_type}'

    def cli(self, process, alloc_type, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(
                process=process,
                alloc_type=alloc_type))
        else:
            out = output

        ret_dict = {}

        # Module: process
        p1 = re.compile(r'Module: +(?P<module>[\S\s]+)$')

        # Type: process
        p1_1 = re.compile(r'Type: +(?P<type>[\S\s]+)$')

        # allocated: 16695, requested: 16647, overhead: 48
        p2 = re.compile(r'Allocated: +(?P<allocated>\d+), +'
            r'Requested: +(?P<requested>\d+), +Overhead: +(?P<overhead>\d+)$')

        # Allocations: 3, failed: 0, frees: 0
        p3 = re.compile(r'Allocations: +(?P<allocations>\d+), +Null +Allocations: +'
            r'(?P<null_allocations>\d+), +Frees: +(?P<frees>\d+)$')

        for line in out.splitlines():
            line = line.strip()

            # Module: process
            m = p1.match(line)
            if m:
                group = m.groupdict()
                module = group.get('module')
                module_dict = ret_dict.setdefault('module', {}). \
                    setdefault(module, {})
                continue

            # type: process
            m = p1_1.match(line)
            if m:
                group = m.groupdict()
                module = group.get('type')
                module_dict = ret_dict.setdefault('type', {}). \
                    setdefault(module, {})
                continue

            # allocated: 16695, requested: 16647, overhead: 48
            m = p2.match(line)
            if m:
                group = m.groupdict()
                module_dict.update({k:int(v) for k, v in group.items() if v is not None})
                continue

            # Allocations: 3, failed: 0, frees: 0
            m = p3.match(line)
            if m:
                group = m.groupdict()
                module_dict.update({k:int(v) for k, v in group.items() if v is not None})
                continue

        return ret_dict

class ShowPlatformSoftwareMemorySwitchActiveAllocType(ShowPlatformSoftwareMemoryRpActiveAllocType):
    """ Parser for
        * show platform software memory mdt-pubd switch active <R0> alloc type component
    """

    cli_command = 'show platform software memory {process} switch active {slot} alloc type {alloc_type}'

    def cli(self, process, slot, alloc_type, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(
                process=process,
                slot=slot,
                alloc_type=alloc_type))
        else:
            out = output

        return super().cli(process=process, output=out, alloc_type=alloc_type)

class ShowPlatformSoftwareMemoryRpActiveAllocTypeBriefSchema(MetaParser):
    """ Schema for
        * show platform software memory mdt-pubd RP active alloc type component brief
    """
    schema = {
        'type': {
            Any(): {
                'allocated': int,
                'requested': int,
                'allocations': int,
                'frees': int,
            }
        }
    }

class ShowPlatformSoftwareMemoryRpActiveAllocTypeBrief(ShowPlatformSoftwareMemoryRpActiveAllocTypeBriefSchema):
    """ Parser for
        * show platform software memory mdt-pubd RP active alloc type component brief
    """

    cli_command = 'show platform software memory {process} RP active alloc type {alloc_type} brief'

    def cli(self, process, alloc_type, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(
                process=process,
                alloc_type=alloc_type))
        else:
            out = output

        ret_dict = {}

        # Summary                 4989412       4501988       150851        142147
        p1 = re.compile(r'(?P<type>\S+) +(?P<allocated>\d+) +'
            r'(?P<requested>\d+) +(?P<allocations>\d+) +(?P<frees>\d+)$')

        for line in out.splitlines():
            line = line.strip()

            # Summary                 4989412       4501988       150851        142147
            m = p1.match(line)
            if m:
                group = m.groupdict()
                module = group.pop('type')
                module_dict = ret_dict.setdefault('type', {}). \
                    setdefault(module, {})
                module_dict.update({k:int(v) for k, v in group.items() if v is not None})
                continue

        return ret_dict

class ShowPlatformSoftwareMemorySwitchActiveAllocTypeBrief(ShowPlatformSoftwareMemoryRpActiveAllocTypeBrief):
    """ Parser for
        * show platform software memory mdt-pubd switch active <R0> alloc type component brief
    """

    cli_command = 'show platform software memory {process} switch active {slot} alloc type {alloc_type} brief'

    def cli(self, process, slot, alloc_type, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(
                process=process,
                slot=slot,
                alloc_type=alloc_type))
        else:
            out = output

        return super().cli(process=process, alloc_type=alloc_type, output=out)


class ShowPlatformSoftwareIomdMacsecInterfaceBriefSchema(MetaParser):
    """ Schema for
        * show platform software iomd 1/0 macsec interface {interface} brief
    """
    schema = {
        Optional('tx-sc'): {
            Any(): {
                'sub-interface': str,
                'sc-idx': str,
                'pre-cur-an': str,
                'sci': str,
                'sa-vp-rule-idx': str,
                'cipher': str
            }
        },
        Optional('rx-sc'): {
            Any(): {
                'sub-interface': str,
                'sc-idx': str,
                'pre-cur-an': str,
                'sci': str,
                'sa-vp-rule-idx': str,
                'cipher': str
            }
        }
    }


class ShowPlatformSoftwareIomdMacsecInterfaceBrief(ShowPlatformSoftwareIomdMacsecInterfaceBriefSchema):
    """ Parser for
        * show platform software iomd 1/0 macsec interface {interface} brief
    """

    cli_command = 'show platform software iomd 1/0 macsec interface {interface} brief'

    def cli(self, interface, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(
                interface=interface))
        else:
            out = output

        ret_dict = {}
        #Tx SC
        p1 = re.compile(r'(.*)Tx SC')

        #Rx SC
        p2 = re.compile(r'(.*)Rx SC')

        #3/11  |   0    |     3/0    | f87a41252702008b | 50331759/ 2/ 1  |     GCM_AES_128 |
        p3 = re.compile(r'(?P<if>\d+\/\d+) +\|'
                        ' +(?P<sc_idx>\d+) +\|'
                        ' +(?P<pre_cur_an>\d+\/\d+) +\|'
                        ' +(?P<sci>\S+) +\|'
                        ' +(?P<idx>\d+\/ \d+\/ \d+) +\|'
                        ' +(?P<cipher>\S+) +\|'
                        )

        sess_tx=0
        sess_rx=0
        for line in out.splitlines():
            line = line.strip()
            m1 = p1.match(line)
            if m1:
                sc = 'tx'
                tx_sc = ret_dict.setdefault('tx-sc', {})
            m2 = p2.match(line)
            if m2:
                sc = 'rx'
                rx_sc = ret_dict.setdefault('rx-sc', {})
            m3 = p3.match(line)
            if m3:
                group = m3.groupdict()
                if sc == 'tx':
                    sess_tx+=1
                    sc_tx_dict = tx_sc.setdefault(sess_tx, {})
                    sc_tx_dict['sub-interface'] = group['if']
                    sc_tx_dict['sc-idx'] = group['sc_idx']
                    sc_tx_dict['pre-cur-an'] = group['pre_cur_an']
                    sc_tx_dict['sci'] = group['sci']
                    sc_tx_dict['sa-vp-rule-idx'] = group['idx']
                    sc_tx_dict['cipher'] = group['cipher']
                elif sc == 'rx':
                    sess_rx+=1
                    sc_rx_dict = rx_sc.setdefault(sess_rx, {})
                    sc_rx_dict['sub-interface'] = group['if']
                    sc_rx_dict['sc-idx'] = group['sc_idx']
                    sc_rx_dict['pre-cur-an'] = group['pre_cur_an']
                    sc_rx_dict['sci'] = group['sci']
                    sc_rx_dict['sa-vp-rule-idx'] = group['idx']
                    sc_rx_dict['cipher'] = group['cipher']
        return ret_dict


class ShowPlatformSoftwareIomdMacsecInterfaceDetailSchema(MetaParser):
    """ Schema for
        * show platform software iomd 1/0 macsec interface {interface} detail
    """
    schema = {
        Optional('subport-11-tx'): {
                'bypass': str,
                'cipher': str,
                'conf-offset': str,
                'cur-an': str,
                'delay-protection': str,
                'encrypt': str,
                'end-station': str,
                'hashkey-len': str,
                'key-len': str,
                'next-pn': str,
                'prev-an': str,
                'rule-index': str,
                'sa-index': str,
                'scb': str,
                'sci': str,
                'vlan': str,
                'vport-index': str
        },
        Optional('subport-12-tx'): {
                'bypass': str,
                'cipher': str,
                'conf-offset': str,
                'cur-an': str,
                'delay-protection': str,
                'encrypt': str,
                'end-station': str,
                'hashkey-len': str,
                'key-len': str,
                'next-pn': str,
                'prev-an': str,
                'rule-index': str,
                'sa-index': str,
                'scb': str,
                'sci': str,
                'vlan': str,
                'vport-index': str
        },
        Optional('subport-11-rx'): {
                   'bypass': str,
                   'cipher': str,
                   'conf-offset': str,
                   'cur-an': str,
                   'decrypt-frames': str,
                   'hashkey-len': str,
                   'key-len': str,
                   'next-pn': str,
                   'prev-an': str,
                   'replay-protect': str,
                   'replay-window-size': str,
                   'rule-index': str,
                   'sa-index': str,
                   'sci': str,
                   'validate-frames': str,
                   'vport-index': str
       },
        Optional('subport-12-rx'): {
                   'bypass': str,
                   'cipher': str,
                   'conf-offset': str,
                   'cur-an': str,
                   'decrypt-frames': str,
                   'hashkey-len': str,
                   'key-len': str,
                   'next-pn': str,
                   'prev-an': str,
                   'replay-protect': str,
                   'replay-window-size': str,
                   'rule-index': str,
                   'sa-index': str,
                   'sci': str,
                   'validate-frames': str,
                   'vport-index': str
       }}



class ShowPlatformSoftwareIomdMacsecInterfaceDetail(ShowPlatformSoftwareIomdMacsecInterfaceDetailSchema):
    """ Parser for
        * show platform software iomd 1/0 macsec interface {interface} detail
    """

    cli_command = 'show platform software iomd 1/0 macsec interface {interface} detail'

    def cli(self, interface, output=None):

        if output is None:
            out = self.device.execute(self.cli_command.format(
                interface=interface))
        else:
            out = output

        ret_dict = {}

        #Port:3, Subport:11, Tx SC index:0
        p1 = re.compile(r'Port\:\d+\, Subport\:(.*)\, Tx SC index')

        #Port:3, Subport:11, Rx SC index:0
        p2 = re.compile(r'Port\:\d+\, Subport\:(.*)\, Rx SC index')

        #Prev AN: 3, Cur AN: 0
        p3 = re.compile(r'Prev AN\: (?P<prev_an>\d+)\, +'
                        'Cur AN\: (?P<cur_an>\d+)')

        #SA index: 50331759, vport index: 2, rule index: 1
        p4 = re.compile(r'SA index\: (?P<sa_index>\d+)\, +'
                        'vport index\: (?P<vport_index>\d+)\, +'
                        'rule index\: (?P<rule_index>\d+)')

        #key_len: 16
        p5 = re.compile(r'^key_len\: (?P<key_len>\d+)$')

        #hashkey_len: 16
        p6 = re.compile(r'^hashkey_len\: (?P<hashkey_len>\d+)$')

        #bypass: 0
        p7 = re.compile(r'^bypass\: (?P<bypass>\d+)$')

        #nextPn: 1
        p8 = re.compile(r'^nextPn\: (?P<nextPn>\d+)$')

        #conf_offset: 0
        p9 = re.compile(r'^conf_offset\: (?P<conf_offset>\d+)$')

        #encrypt: 1
        p10 = re.compile(r'^encrypt\: (?P<encrypt>\d+)$')

        #vlan: 1
        p11 = re.compile(r'^vlan\: (?P<vlan>\d+)$')

        #end_station: 0
        p12 = re.compile(r'^end_station\: (?P<end_station>\d+)$')

        #scb: 0
        p13 = re.compile(r'^scb\: (?P<scb>\d+)$')

        #cipher: GCM_AES_128
        p14 = re.compile(r'^cipher\: (?P<cipher>\S+)$')

        #Delay protection: 0
        p15 = re.compile(r'^Delay protection\: (?P<delay_protection>\d+)$')

        #replay_protect: 1
        p16 = re.compile(r'^replay_protect\: (?P<replay_protect>\d+)$')

        #replay_window_size: 0
        p17 = re.compile(r'^replay_window_size\: (?P<replay_window_size>\d+)$')

        #decrypt_frames: 1
        p18 = re.compile(r'^decrypt_frames\: (?P<decrypt_frames>\d+)$')

        #validate_frames: 1
        p19 = re.compile(r'^validate_frames\: (?P<validate_frames>\d+)$')

        #sci:ecce1346f902008c
        p20 = re.compile(r'^sci\:(?P<sci>\S+)$')

        for line in out.splitlines():
            line = line.strip()
            m1 = p1.match(line)
            if m1:
                sc = 'tx'
                subport_tx = m1.group(1)
                subport_tx_dict = ret_dict.setdefault('subport-{}-tx'.format(subport_tx), {})
            m2 = p2.match(line)
            if m2:
                sc = 'rx'
                subport_rx = m2.group(1)
                subport_rx_dict = ret_dict.setdefault('subport-{}-rx'.format(subport_rx), {})
            m3 = p3.match(line)
            if m3:
                group = m3.groupdict()
                if sc == 'tx':
                    subport_tx_dict['prev-an'] = group['prev_an']
                    subport_tx_dict['cur-an'] = group['cur_an']
                elif sc == 'rx':
                    subport_rx_dict['prev-an'] = group['prev_an']
                    subport_rx_dict['cur-an'] = group['cur_an']
            m4 = p4.match(line)
            if m4:
                group = m4.groupdict()
                if sc == 'tx':
                    subport_tx_dict['sa-index'] = group['sa_index']
                    subport_tx_dict['vport-index'] = group['vport_index']
                    subport_tx_dict['rule-index'] = group['rule_index']
                elif sc == 'rx':
                    subport_rx_dict['sa-index'] = group['sa_index']
                    subport_rx_dict['vport-index'] = group['vport_index']
                    subport_rx_dict['rule-index'] = group['rule_index']
            m5 = p5.match(line)
            if m5:
                group = m5.groupdict()
                if sc == 'tx':
                    subport_tx_dict['key-len'] = group['key_len']
                elif sc == 'rx':
                    subport_rx_dict['key-len'] = group['key_len']
            m6 = p6.match(line)
            if m6:
                group = m6.groupdict()
                if sc == 'tx':
                    subport_tx_dict['hashkey-len'] = group['hashkey_len']
                elif sc == 'rx':
                    subport_rx_dict['hashkey-len'] = group['hashkey_len']
            m7 = p7.match(line)
            if m7:
                group = m7.groupdict()
                if sc == 'tx':
                    subport_tx_dict['bypass'] = group['bypass']
                elif sc == 'rx':
                    subport_rx_dict['bypass'] = group['bypass']
            m8 = p8.match(line)
            if m8:
                group = m8.groupdict()
                if sc == 'tx':
                    subport_tx_dict['next-pn'] = group['nextPn']
                elif sc == 'rx':
                    subport_rx_dict['next-pn'] = group['nextPn']
            m9 = p9.match(line)
            if m9:
                group = m9.groupdict()
                if sc == 'tx':
                   subport_tx_dict['conf-offset'] = group['conf_offset']
                elif sc == 'rx':
                   subport_rx_dict['conf-offset'] = group['conf_offset']
            m10 = p10.match(line)
            if m10:
                group = m10.groupdict()
                if sc == 'tx':
                    subport_tx_dict['encrypt'] = group['encrypt']
                elif sc == 'rx':
                    subport_rx_dict['encrypt'] = group['encrypt']
            m11 = p11.match(line)
            if m11:
                group = m11.groupdict()
                if sc == 'tx':
                    subport_tx_dict['vlan'] = group['vlan']
                elif sc == 'rx':
                    subport_rx_dict['vlan'] = group['vlan']
            m12 = p12.match(line)
            if m12:
                group = m12.groupdict()
                if sc == 'tx':
                    subport_tx_dict['end-station'] = group['end_station']
                elif sc == 'rx':
                    subport_rx_dict['end-station'] = group['end_station']
            m13 = p13.match(line)
            if m13:
                group = m13.groupdict()
                if sc == 'tx':
                    subport_tx_dict['scb'] = group['scb']
                elif sc == 'rx':
                    subport_rx_dict['scb'] = group['scb']
            m14 = p14.match(line)
            if m14:
                group = m14.groupdict()
                if sc == 'tx':
                    subport_tx_dict['cipher'] = group['cipher']
                elif sc == 'rx':
                    subport_rx_dict['cipher'] = group['cipher']
            m15 = p15.match(line)
            if m15:
                group = m15.groupdict()
                if sc == 'tx':
                    subport_tx_dict['delay-protection'] = group['delay_protection']
                elif sc == 'rx':
                    subport_rx_dict['delay-protection'] = group['delay_protection']
            m16 = p16.match(line)
            if m16:
                group = m16.groupdict()
                if sc == 'tx':
                    subport_tx_dict['replay-protect'] = group['replay_protect']
                elif sc == 'rx':
                    subport_rx_dict['replay-protect'] = group['replay_protect']
            m17 = p17.match(line)
            if m17:
                group = m17.groupdict()
                if sc == 'tx':
                    subport_tx_dict['replay-window-size'] = group['replay_window_size']
                elif sc == 'rx':
                    subport_rx_dict['replay-window-size'] = group['replay_window_size']
            m18 = p18.match(line)
            if m18:
                group = m18.groupdict()
                if sc == 'tx':
                     subport_tx_dict['decrypt-frames'] = group['decrypt_frames']
                elif sc == 'rx':
                     subport_rx_dict['decrypt-frames'] = group['decrypt_frames']
            m19 = p19.match(line)
            if m19:
                group = m19.groupdict()
                if sc == 'tx':
                    subport_tx_dict['validate-frames'] = group['validate_frames']
                elif sc == 'rx':
                    subport_rx_dict['validate-frames'] = group['validate_frames']
            m20 = p20.match(line)
            if m20:
                group = m20.groupdict()
                if sc == 'tx':
                    subport_tx_dict['sci'] = group['sci']
                elif sc == 'rx':
                    subport_rx_dict['sci'] = group['sci']

        return ret_dict


class ShowPlatformSoftwareFedactiveFnfEtAnalyticsFlowsSchema(MetaParser):
    """ Schema for
        * show platform software fed active fnf et-analytics-flows
    """
    schema = {
            'current-eta-records': int,
            'excess-packets-received': int,
            'excess-syn-received': int,
            'total-eta-fnf': int,
            'total-eta-idp': int,
            'total-eta-records': int,
            'total-eta-splt': int,
            'total-packets-out-of-order': int,
            'total-packets-received': int,
            'total-packets-retransmitted': int
            }


class ShowPlatformSoftwareFedactiveFnfEtAnalyticsFlows(ShowPlatformSoftwareFedactiveFnfEtAnalyticsFlowsSchema):
    """ Parser for
        * show platform software fed active fnf et-analytics-flows
    """

    cli_command = 'show platform software fed active fnf et-analytics-flows'

    def cli(self, output=None):

        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        ret_dict = {}

        #Total packets received     : 80
        p1 = re.compile(r'Total +packets +received +: +(?P<total_pkts>\d+)')

        #Excess packets received    : 60
        p2 = re.compile(r'Excess +packets +received +: +(?P<excess_pkts>\d+)')

        #Excess syn received        : 0
        p3 = re.compile(r'Excess +syn +received +: +(?P<excess_syn>\d+)')

        #Total eta records added    : 4
        p4 = re.compile(r'Total +eta +records +added +: +(?P<tot_eta>\d+)')

        #Current eta records        : 0
        p5 = re.compile(r'Current +eta +records +: +(?P<cur_eta>\d+)')

        #Total eta splt exported    : 2
        p6 = re.compile(r'Total +eta +splt +exported +: +(?P<eta_splt>\d+)')

        #Total eta IDP exported     : 2
        p7 = re.compile(r'Total +eta +IDP +exported +: +(?P<eta_idp>\d+)')

        #Total eta-fnf records      : 2
        p8 = re.compile(r'Total +eta\-fnf +records +: +(?P<eta_fnf>\d+)')

        #Total retransmitted pkts   : 0
        p9 = re.compile(r'Total +retransmitted +pkts +: +(?P<retr_pkts>\d+)')

        #Total out of order pkts    : 0
        p10 = re.compile(r'Total +out +of +order +pkts +: +(?P<order_pkts>\d+)')


        for line in out.splitlines():
            line = line.strip()

            #Total packets received     : 80
            m1 = p1.match(line)
            if m1:
                group = m1.groupdict()
                ret_dict["total-packets-received"] = int(group["total_pkts"])

            #Excess packets received    : 60
            m2 = p2.match(line)
            if m2:
                group = m2.groupdict()
                ret_dict["excess-packets-received"] = int(group["excess_pkts"])

            #Excess syn received        : 0
            m3 = p3.match(line)
            if m3:
                group = m3.groupdict()
                ret_dict["excess-syn-received"] = int(group["excess_syn"])

            #Total eta records added    : 4
            m4 = p4.match(line)
            if m4:
                group = m4.groupdict()
                ret_dict["total-eta-records"] = int(group["tot_eta"])

            #Current eta records        : 0
            m5 = p5.match(line)
            if m5:
                group = m5.groupdict()
                ret_dict["current-eta-records"] = int(group["cur_eta"])

            #Total eta splt exported    : 2
            m6 = p6.match(line)
            if m6:
                group = m6.groupdict()
                ret_dict["total-eta-splt"] = int(group["eta_splt"])

            #Total eta IDP exported     : 2
            m7 = p7.match(line)
            if m7:
                group = m7.groupdict()
                ret_dict["total-eta-idp"] = int(group["eta_idp"])

            #Total eta-fnf records      : 2
            m8 = p8.match(line)
            if m8:
                group = m8.groupdict()
                ret_dict["total-eta-fnf"] = int(group["eta_fnf"])

            #Total retransmitted pkts   : 0
            m9 = p9.match(line)
            if m9:
                group = m9.groupdict()
                ret_dict["total-packets-retransmitted"] = int(group["retr_pkts"])

            #Total out of order pkts    : 0
            m10 = p10.match(line)
            if m10:
                group = m10.groupdict()
                ret_dict["total-packets-out-of-order"] = int(group["order_pkts"])
        return ret_dict

# =============================================
# Schema for 'show platform software fed switch active mpls forwarding label <label> detail'
# Schema for 'show platform software fed active mpls forwarding label <label> detail'
# =============================================
class ShowPlatformSoftwareFedSchema(MetaParser):
    """ Schema for:
        *show platform software fed {switch} active mpls forwarding label {label} detail
        *show platform software fed active mpls forwarding label {label} detail
    """
    schema = {
        'lentry_label':{
            Any():{
                'nobj': list,
                'lentry_hdl': str,
                'modify_cnt': int,
                'backwalk_cnt': int,
                'lspa_handle': str,
                'aal':{
                    'id': int,
                    'lbl': int,
                    'eos0':{
                        'adj_hdl': str,
                        'hw_hdl': str,
                        },
                    'eos1':{
                        'adj_hdl': str,
                        'hw_hdl': str,
                    },
                    'deagg_vrf_id': int,
                    'lspa_handle': str,
                    },
                Optional('eos'):{
                    'objid': int,
                    'local_label': int,
                    'flags': str,
                    'pdflags': str,
                    'nobj0': list,
                    'nobj1': list,
                    'modify': int,
                    'bwalk': int,
                },
                Optional('label'):{
                    Any():{
                        'link_type': str,
                        'local_label': int,
                        'outlabel': str,
                        'flags': {
                            Any(): list,
                        },
                        'pdflags': {
                            Any(): list,
                        },
                        'adj_handle': str,
                        'unsupported_recursion': int,
                        'olbl_changed': int,
                        'local_adj': int,
                        'modify_cnt': int,
                        'bwalk_cnt': int,
                        'subwalk_cnt': int,
                        'collapsed_oce': int,
                        Optional('label_aal'):{
                            Any():{
                                'lbl': int,
                                'smac': str,
                                'dmac': str,
                                'sub_type': int,
                                'link_type': int,
                                'adj_flags': str,
                                'label_type': int,
                                'rewrite_type': str,
                                'vlan_id': int,
                                'vrf_id': int,
                                'ri': str,
                                'ri_id': str,
                                'phdl': str,
                                'ref_cnt':int,
                                'si': str,
                                'si_id': str,
                                'di_id': str,
                                },
                            },
                        },
                    },
                Optional('adj'):{
                    Any():{
                        'link_type': str,
                        'ifnum': str,
                        'adj': str,
                        'si': str,
                        Optional('IPv4'): str,
                        },
                    },
                Optional('objid'):{
                    Any():{
                        'SPECIAL': str,
                    },
                },

                Optional('lb'):{
                    Any():{
                        'ecr_map_objid': int,
                        'link_type': str,
                        'num_choices': int,
                        'flags': str,
                        'mpls_ecr': int,
                        'local_label': int,
                        'path_inhw': int,
                        'ecrh': str,
                        'old_ecrh': str,
                        'modify_cnt': int,
                        'bwalk_cnt': int,
                        'subwalk_cnt': int,
                        'finish_cnt': int,
                        Optional('bwalk'):{
                            'req': int,
                            'in_prog': int,
                            'nested': int,
                            },
                        Optional('aal'):{
                            'ecr_id': int,
                            'af': int,
                            'ecr_type': str,
                            'ref': int,
                            'ecrh': str,
                            'hwhdl': str,
                        }
                    },
                },
                Optional('sw_enh_ecr_scale'):{
                    Any():{
                        'llabel': int,
                        'eos': int,
                        'adjs': int,
                        'mixed_adj': str,
                        'reprogram_hw': str,
                        'ecrhdl': str,
                        'ecr_hwhdl': str,
                        'mod_cnt': int,
                        'prev_npath': int,
                        'pmismatch': int,
                        'pordermatch': int,
                        Optional('ecr_adj'):{
                            Any():{
                                Optional('is_mpls_adj'): int,
                                Optional('l3adj_flags'): str,
                                Optional('recirc_adj_id'): int,
                                'sih': str,
                                'di_id': int,
                                'rih': str,
                                Optional('adj_lentry'): str,
                            },
                        },
                    },
                },

            }
        }
    }

# ================================================================
# Parser for:
#   * 'show platform software fed '
# ================================================================
class ShowPlatformSoftwareFed(ShowPlatformSoftwareFedSchema):
    ''' Parser for:
        ' show platform software fed {switch} active mpls forwarding label {label} detail'
        ' show platform software fed active mpls forwarding label {label} detail '
    '''

    cli_command = ['show platform software fed active mpls forwarding label {label} detail',
                   'show platform software fed {switch} active mpls forwarding label {label} detail']
    def cli(self, label='',switch='',output=None):
        ''' cli for:
         ' show platform software fed {switch} active mpls forwarding label {label} detail '
         ' show platform software fed active mpls forwarding label {label} detail '
        '''
        if output is None:
            # Build command
            if not switch:
                cmd = self.cli_command[0].format(label=label)
            else:
                cmd = self.cli_command[1].format(switch=switch, label=label)
            # Execute command
            out = self.device.execute(cmd)
        else:
            out = output


        #LENTRY:label:22 nobj:(EOS, 142) lentry_hdl:0xde00000a
        p1 = re.compile(r'^LENTRY:label:+(?P<label>\d+)\s+nobj:\(+'
                        r'(?P<nobj>[\w\, ]+)+\)\s+lentry_hdl:+(?P<lentry_hdl>\S+)$')

        #modify_cnt:1 backwalk_cnt:2
        p2 = re.compile(r'^modify_cnt:+(?P<modify_cnt>\d+)\s+'
                        r'backwalk_cnt:+(?P<backwalk_cnt>\d+)$')

        #lspa_handle:0
        p3 = re.compile(r'^lspa_handle:+(?P<lspa_handle>\w+)$')

        #AAL: id:3724541962 lbl:22
        p4 = re.compile(r'^AAL:\s+id:+(?P<id>\d+)\s+lbl:+(?P<lbl>\d+)$')

        #eos0:[adj_hdl:0x83000039, hw_hdl:0x7f02737c6628]
        p5 = re.compile(r'^eos0:\[+adj_hdl:+(?P<adj_hdl>\w+)+,\s+hw_hdl:+(?P<hw_hdl>\w+)+\]+$')

        #eos1:[adj_hdl:0x3d000038, hw_hdl:0x7f02737c6478]
        p6 = re.compile(r'^eos1:\[+adj_hdl:+(?P<adj_hdl>\w+)+,\s+hw_hdl:+'
                        r'(?P<hw_hdl>\w+)+\]+$')

        #deagg_vrf_id = 0 lspa_handle:0
        p7 = re.compile(r'^deagg_vrf_id\s+=\s+(?P<deagg_vrf_id>\d+)+\s+lspa_handle:+'
                        r'(?P<lspa_handle>\w+)+$')

        #EOS:objid:142 local_label:0 flags:0:() pdflags:0
        p8 = re.compile(r'^EOS:+objid:+(?P<objid>\d+)\s+local_label:+'
                        r'(?P<local_label>\d+)\s+flags:+\S:+'
                        r'(?P<flags>[\S\s]+)\s+pdflags:+'
                        r'(?P<pdflags>\S+)$')

        #nobj0:(LABEL, 143), nobj1:(LABEL, 141) modify:1 bwalk:0
        p9 = re.compile(r'^nobj0:\(+(?P<nobj0>[\w\,\s]+)+\)+\,\s+nobj1:\(+'
                        r'(?P<nobj1>[\w\,\s]+)+\)\s+modify:+(?P<modify>\d+)\s+bwalk:+(?P<bwalk>\d+)$')

        #LABEL:objid:143 link_type:MPLS local_label:22 outlabel:(3, 0)
        p10 = re.compile(r'LABEL:+objid:+(?P<objid>\d+)\s+link_type:+'
                         r'(?P<link_type>\w+)\s+local_label:+'
                         r'(?P<local_label>\d+)\s+outlabel:+(?P<outlabel>[\S\s]+)$')

        #flags:0x18:(POP,PHP,) pdflags:0:(INSTALL_HW_OK,) adj_handle:0x83000039
        p11 = re.compile(r'flags:+(?P<flagid>\w+)+:\(+(?P<flagstr>\S+)+\,+\)+\s+pdflags:+'
                         r'(?P<pdflagid>\w+)+:\(+(?P<pdflagstr>\S+)+\,+\)+\s+adj_handle:+(?P<adj_handle>\w+)$')

        #unsupported recursion:0 olbl_changed 0 local_adj:0 modify_cnt:0
        p12 = re.compile(r'^unsupported\s+recursion:+(?P<unsupported_recursion>\d+)\s+olbl_changed\s+'
                         r'(?P<olbl_changed>\d+)\s+local_adj:+'
                         r'(?P<local_adj>\d+)\s+modify_cnt:+(?P<modify_cnt>\d+)$')

        #bwalk_cnt:0 subwalk_cnt:0 collapsed_oce:0
        p13 = re.compile(r'^bwalk_cnt:+(?P<bwalk_cnt>\d+)\s+subwalk_cnt:+'
                         r'(?P<subwalk_cnt>\d+)\s+collapsed_oce:+(?P<collapsed_oce>\d+)$')

        #AAL: id:2197815353 lbl:0 smac:00a7.42d6.c41f dmac:0027.90bf.2ee7
        p14 = re.compile(r'^AAL:\s+id:+(?P<id>\d+)\s+lbl:+(?P<lbl>\d+)\s+smac:+'
                         r'(?P<smac>\S+)\s+dmac:+(?P<dmac>\S+)$')

        #sub_type:0 link_type:2 adj_flags:0 label_type:1 rewrite_type:POP2MPLS(138)
        p15 = re.compile(r'^sub_type:+(?P<sub_type>\d+)\s+link_type:+'
                         r'(?P<link_type>\d+)\s+adj_flags:+(?P<adj_flags>\w+)\s+label_type:+'
                         r'(?P<label_type>\d+)\s+rewrite_type:+(?P<rewrite_type>\S+)$')

        #vlan_id:0 vrf_id:0 ri:0x7f02737cc1e8, ri_id:0x3e phdl:0xab000447, ref_cnt:1
        p16 = re.compile(r'^vlan_id:+(?P<vlan_id>\d+)\s+vrf_id:+(?P<vrf_id>\d+)\s+ri:+'
                         r'(?P<ri>\w+)+,\s+ri_id:+(?P<ri_id>\w+)\s+phdl:+'
                         r'(?P<phdl>\w+)+,\s+ref_cnt:+(?P<ref_cnt>\d+)$')

        #si:0x7f02737cc6b8, si_id:0x4027, di_id:0x526d
        p17 = re.compile(r'^si:+(?P<si>\w+)+,\s+si_id:+(?P<si_id>\w+)+,\s+di_id:+(?P<di_id>\w+)$')

        #ADJ:objid:139 {link_type:MPLS ifnum:0x36, adj:0x5c000037, si: 0x7f02737a2348  }
        p18 = re.compile(r'ADJ:objid:+(?P<objid>\d+) +{link_type:(?P<link_type>\w+) +ifnum:(?P<ifnum>\w+), +adj:(?P<adj>\w+), +si: +(?P<si>\w+) +}$')

        #ADJ:objid:137 {link_type:IP ifnum:0x36, adj:0x63000036, si: 0x7f02737a2348  IPv4:     172.16.25.2 }
        p19 = re.compile(r'ADJ:objid:+(?P<objid>\d+) +{link_type:(?P<link_type>\w+) +ifnum:(?P<ifnum>\w+), +adj:(?P<adj>\w+), +si: +(?P<si>\w+) +IPv4: +(?P<IPv4>[\d\.]+) +}$')

        #LENTRY:label:75 not found...
        p20 = re.compile(r'^LENTRY:label:+(?P<label>\d+)\snot +found\S+$')

        #AAL: Handle not found:0
        p21 = re.compile(r'^AAL:\s+Handle\ not\ found:\S$')

        #LB:obj_id:38 ecr_map_objid:0 link_type:IP num_choices:2 Flags:0
        p22 = re.compile(r'LB:+obj_id:+(?P<obj_id>\d+)\s+ecr_map_objid:+'
                         r'(?P<ecr_map_objid>\d+)\s+link_type:+'
                         r'(?P<link_type>\w+)\s+num_choices:+'
                         r'(?P<num_choices>\d+)\s+Flags:+(?P<flags>\w+)$')

        #mpls_ecr:1 local_label:24 path_inhw:2 ecrh:0xf9000002 old_ecrh:0
        p23 = re.compile(r'mpls_ecr:+(?P<mpls_ecr>\d+)\s+local_label:+'
                         r'(?P<local_label>\d+)\s+path_inhw:+'
                         r'(?P<path_inhw>\d+)\s+ecrh:+'
                         r'(?P<ecrh>\w+)\s+old_ecrh:+(?P<old_ecrh>\w+)$')

        #modify_cnt:0 bwalk_cnt:0 subwalk_cnt:0 finish_cnt:0
        p24 = re.compile(r'modify_cnt:+(?P<modify_cnt>\d+)\s+bwalk_cnt:+'
                         r'(?P<bwalk_cnt>\d+)\s+subwalk_cnt:+'
                         r'(?P<subwalk_cnt>\d+)\s+finish_cnt:+'+
                         r'(?P<finish_cnt>\d+)$')

        #bwalk:[req:0 in_prog:0 nested:0]
        p25 = re.compile(r'bwalk:\[+req:+(?P<req>\d+)\s+in_prog:+'
                         r'(?P<in_prog>\d+)\s+nested:+(?P<nested>\d+)+\]+$')

        #AAL: ecr:id:4177526786 af:0 ecr_type:0 ref:3 ecrh:0x7f02737e49f8(28:2)
        p26 = re.compile(r'AAL:\s+ecr:id:+(?P<ecr_id>\d+)\s+af:(?P<af>\d+)\s+ecr_type:+'
                         r'(?P<ecr_type>\w+)\s+ref:+(?P<ref>\d+)\s+ecrh:+(?P<ecrh>\S+)+$')

        #hwhdl:1937656312 ::0x7f02737e11c8,0x7f02737e2728,0x7f02737e11c8,0x7f02737e2728
        p27 = re.compile(r'hwhdl+(?P<hwhdl>[\S\s]+)$')

        #Sw Enh ECR scale: objid:38 llabel:24 eos:1 #adjs:2 mixed_adj:0
        p28 = re.compile(r'Sw +Enh +ECR +scale:\s+objid:+(?P<objid>\d+)\s+llabel:+'
                         r'(?P<llabel>\d+)\s+eos:+(?P<eos>\d+)\s+\#adjs:+'
                         r'(?P<adjs>\d+)\s+mixed_adj:+(?P<mixed_adj>\w+)$')

        #reprogram_hw:0 ecrhdl:0xf9000002 ecr_hwhdl:0x7f02737e49f8
        p29 = re.compile(r'reprogram_hw:+(?P<reprogram_hw>\w+)\s+ecrhdl:+'
                         r'(?P<ecrhdl>\w+)\s+ecr_hwhdl:+(?P<ecr_hwhdl>\w+)$')

        # mod_cnt:0 prev_npath:0 pmismatch:0 pordermatch:0
        p30 = re.compile(r'mod_cnt:+(?P<mod_cnt>\d+)\s+prev_npath:+'
                         r'(?P<prev_npath>\d+)\s+pmismatch:+(?P<pmismatch>\d+)\s+pordermatch:+'
                         r'(?P<pordermatch>\d+)$')

        #ecr_adj: id:1644167265 is_mpls_adj:1 l3adj_flags:0x100000
        p31 = re.compile(r'(?P<ecr_adj>\S+):\s+id:+(?P<id>\d+)\s+is_mpls_adj:+'
                         r'(?P<is_mpls_adj>\d+)\s+l3adj_flags:+(?P<l3adj_flags>\w+)$')

        # recirc_adj_id:3120562239
        p32 = re.compile(r'recirc_adj_id:+(?P<recirc_adj_id>\d+)$')

        # sih:0x7f02737e11c8(182) di_id:20499 rih:0x7f02737e0bf8(74)
        p33 = re.compile(r'sih:+(?P<sih>\S+)\s+di_id:(?P<di_id>\d+)\s+rih:+(?P<rih>\S+)$')

        # adj_lentry [eos0:0x7f02734123b8 eos1:0x7f02737ec5e8]
        p34 = re.compile(r'adj_lentry\s+(?P<adj_lentry>[\S\s]+)$')

        #ecr_prefix_adj: id:2483028067 (ref:1)
        p35 = re.compile(r'(?P<ecr_prefix_adj>\S+):\s+id:+(?P<id>\d+)\s+\S+$')

        #objid:ADJ SPECIAL:0
        p36 = re.compile(r'objid:+(?P<objid>\S+)\s+SPECIAL:+(?P<SPECIAL>\w+)$')

        # Init vars
        ret_dict = {}
        for line in out.splitlines():
            line = line.strip()
            eos_dict = {}

            #LENTRY:label:22 nobj:(EOS, 142) lentry_hdl:0xde00000a
            m = p1.match(line)
            if m:
                group = m.groupdict()
                label_id = int(group['label'])
                lentry_dict = ret_dict.setdefault('lentry_label', {}).setdefault(label_id, {})
                lentry_dict['nobj'] = list(str(group['nobj']).split(','))
                lentry_dict['lentry_hdl'] = group['lentry_hdl']
                continue

            #modify_cnt:1 backwalk_cnt:2
            m = p2.match(line)
            if m:
                group = m.groupdict()
                lentry_dict['modify_cnt'] = int(group['modify_cnt'])
                lentry_dict['backwalk_cnt'] = int(group['backwalk_cnt'])
                continue

            #lspa_handle:0
            m = p3.match(line)
            if m:
                group = m.groupdict()
                lentry_dict['lspa_handle'] = str(group['lspa_handle'])
                continue

            #AAL: id:3724541962 lbl:22
            m = p4.match(line)
            if m:
                group = m.groupdict()
                aal_dict = ret_dict['lentry_label'][label_id].setdefault('aal', {})
                aal_dict['id'] = int(group['id'])
                aal_dict['lbl'] = int(group['lbl'])
                continue

            #eos0:[adj_hdl:0x83000039, hw_hdl:0x7f02737c6628]
            m = p5.match(line)
            if m:
                group = m.groupdict()
                eos0_dict = ret_dict['lentry_label'][label_id]['aal'].setdefault('eos0', {})
                eos0_dict['adj_hdl'] = str(group['adj_hdl'])
                eos0_dict['hw_hdl'] = str(group['hw_hdl'])
                continue

            #eos1:[adj_hdl:0x3d000038, hw_hdl:0x7f02737c6478]
            m = p6.match(line)
            if m:
                group = m.groupdict()
                eos1_dict = ret_dict['lentry_label'][label_id]['aal'].setdefault('eos1', {})
                eos1_dict['adj_hdl'] = str(group['adj_hdl'])
                eos1_dict['hw_hdl'] = str(group['hw_hdl'])
                continue

            #deagg_vrf_id = 0 lspa_handle:0
            m = p7.match(line)
            if m:
                group = m.groupdict()
                aal_dict['deagg_vrf_id'] = int(group['deagg_vrf_id'])
                aal_dict['lspa_handle'] = str(group['lspa_handle'])
                continue

            #EOS:objid:142 local_label:0 flags:0:() pdflags:0
            m = p8.match(line)
            if m:
                group = m.groupdict()
                eos_dict = ret_dict['lentry_label'][label_id].setdefault('eos', {})
                eos_dict['objid'] = int(group['objid'])
                eos_dict['local_label'] = int(group['local_label'])
                eos_dict['flags'] = str(group['flags'])
                eos_dict['pdflags'] = str(group['pdflags'])
                continue

            #nobj0:(LABEL, 143), nobj1:(LABEL, 141) modify:1 bwalk:0
            m = p9.match(line)
            if m:
                group = m.groupdict()
                ret_dict['lentry_label'][label_id]['eos']['nobj0'] = list(str(group['nobj0']).split(', '))
                ret_dict['lentry_label'][label_id]['eos']['nobj1'] = list(str(group['nobj1']).split(', '))
                ret_dict['lentry_label'][label_id]['eos']['modify']=int(group['modify'])
                ret_dict['lentry_label'][label_id]['eos']['bwalk'] = int(group['bwalk'])
                continue

            #LABEL:objid:143 link_type:MPLS local_label:22 outlabel:(3, 0)
            m = p10.match(line)
            if m:
                group = m.groupdict()
                objid = int(group['objid'])
                label_dict = ret_dict['lentry_label'][label_id].setdefault('label', {}).setdefault(objid, {})
                label_dict['link_type'] = str(group['link_type'])
                label_dict['local_label'] = int(group['local_label'])
                label_dict['outlabel'] = str(group['outlabel'])
                continue

            #flags:0x18:(POP,PHP,) pdflags:0:(INSTALL_HW_OK,) adj_handle:0x83000039
            m = p11.match(line)
            if m:
                group = m.groupdict()
                label_dict['flags'] = {}
                flagid = str(group['flagid'])
                flagstr = str(group['flagstr'])
                flaglist = list(flagstr.split(','))
                label_dict['flags'][flagid] = flaglist
                label_dict['pdflags'] = {}
                flagid = str(group['pdflagid'])
                flagstr = str(group['pdflagstr'])
                flaglist = list(flagstr.split(','))
                label_dict['pdflags'][flagid] = flaglist
                label_dict['adj_handle'] = str(group['adj_handle'])
                continue

            #unsupported recursion:0 olbl_changed 0 local_adj:0 modify_cnt:0
            m = p12.match(line)
            if m:
                group = m.groupdict()
                label_dict['unsupported_recursion'] = int(group['unsupported_recursion'])
                label_dict['olbl_changed'] = int(group['olbl_changed'])
                label_dict['local_adj'] = int(group['local_adj'])
                label_dict['modify_cnt'] = int(group['modify_cnt'])
                continue

            #bwalk_cnt:0 subwalk_cnt:0 collapsed_oce:0
            m = p13.match(line)
            if m:
                group = m.groupdict()
                label_dict['bwalk_cnt'] = int(group['bwalk_cnt'])
                label_dict['subwalk_cnt'] = int(group['subwalk_cnt'])
                label_dict['collapsed_oce'] = int(group['collapsed_oce'])
                continue

            #AAL: id:2197815353 lbl:0 smac:00a7.42d6.c41f dmac:0027.90bf.2ee7
            m = p14.match(line)
            if m:
                group = m.groupdict()
                id = int(group['id'])
                labelaal_dict = ret_dict['lentry_label'][label_id]['label'][objid].setdefault('label_aal', {}).setdefault(id, {})
                labelaal_dict['lbl'] = int(group['lbl'])
                labelaal_dict['smac'] = str(group['smac'])
                labelaal_dict['dmac'] = str(group['dmac'])
                continue

            #sub_type:0 link_type:2 adj_flags:0 label_type:1 rewrite_type:POP2MPLS(138)
            m = p15.match(line)
            if m:
                group = m.groupdict()
                labelaal_dict['sub_type'] = int(group['sub_type'])
                labelaal_dict['link_type'] = int(group['link_type'])
                labelaal_dict['adj_flags'] = str(group['adj_flags'])
                labelaal_dict['label_type'] = int(group['label_type'])
                labelaal_dict['rewrite_type'] = str(group['rewrite_type'])
                continue

            #vlan_id:0 vrf_id:0 ri:0x7f02737cc1e8, ri_id:0x3e phdl:0xab000447, ref_cnt:1
            m = p16.match(line)
            if m:
                group = m.groupdict()
                labelaal_dict['vlan_id'] = int(group['vlan_id'])
                labelaal_dict['vrf_id'] = int(group['vrf_id'])
                labelaal_dict['ri'] = str(group['ri'])
                labelaal_dict['ri_id'] = str(group['ri_id'])
                labelaal_dict['phdl'] = str(group['phdl'])
                labelaal_dict['ref_cnt'] = int(group['ref_cnt'])
                continue

            #si:0x7f02737cc6b8, si_id:0x4027, di_id:0x526d
            m = p17.match(line)
            if m:
                group = m.groupdict()
                labelaal_dict['si'] = str(group['si'])
                labelaal_dict['si_id'] = str(group['si_id'])
                labelaal_dict['di_id'] = str(group['di_id'])
                continue

            #ADJ:objid:71 {link_type:MPLS ifnum:0x7c, adj:0x53000020, si: 0x7ff791190278
            m = p18.match(line)
            if m:
                group = m.groupdict()
                objid = int(group['objid'])
                adj_dict = ret_dict['lentry_label'][label_id].setdefault('adj', {}).setdefault(objid, {})
                adj_dict['link_type'] = str(group['link_type'])
                adj_dict['ifnum'] = str(group['ifnum'])
                adj_dict['adj'] = str(group['adj'])
                adj_dict['si'] = str(group['si'])
                continue

            #ADJ:objid:139 {link_type:MPLS ifnum:0x36, adj:0x5c000037, si: 0x7f02737a2348  }
            m = p19.match(line)
            if m:
                group = m.groupdict()
                objid = int(group['objid'])
                adj_dict = ret_dict['lentry_label'][label_id].setdefault('adj', {}).setdefault(objid, {})
                adj_dict['link_type'] = str(group['link_type'])
                adj_dict['ifnum'] = str(group['ifnum'])
                adj_dict['adj'] = str(group['adj'])
                adj_dict['si'] = str(group['si'])
                adj_dict['IPv4'] = str(group['IPv4'])
                continue

            #LENTRY:label:75 not found...
            m = p20.match(line)
            if m:
                group = m.groupdict()
                label_id = int(group['label'])
                lentry_dict = ret_dict.setdefault('lentry_label', {}).setdefault(label_id,{})
                lentry_dict['label'] = int(group['label'])
                continue

            #AAL: Handle not found:0
            m = p21.match(line)
            if m:
                group = m.groupdict()
                labelaal_dict = ret_dict['lentry_label'][label_id].setdefault('aal', {})
                continue

            #LB:obj_id:38 ecr_map_objid:0 link_type:IP num_choices:2 Flags:0
            m = p22.match(line)
            if m:
                group = m.groupdict()
                objid1 = int(group['obj_id'])
                lb_dict = ret_dict['lentry_label'][label_id].setdefault('lb', {}).setdefault(objid1, {})
                lb_dict['ecr_map_objid'] = int(group['ecr_map_objid'])
                lb_dict['link_type'] = str(group['link_type'])
                lb_dict['num_choices'] = int(group['num_choices'])
                lb_dict['flags'] = str(group['flags'])
                continue

            #mpls_ecr:1 local_label:24 path_inhw:2 ecrh:0xf9000002 old_ecrh:0
            m = p23.match(line)
            if m:
                group = m.groupdict()
                lb_dict['mpls_ecr'] = int(group['mpls_ecr'])
                lb_dict['local_label'] = int(group['local_label'])
                lb_dict['path_inhw'] = int(group['path_inhw'])
                lb_dict['ecrh'] = str(group['ecrh'])
                lb_dict['old_ecrh'] = str(group['old_ecrh'])
                continue

            #modify_cnt:0 bwalk_cnt:0 subwalk_cnt:0 finish_cnt:0
            m = p24.match(line)
            if m:
                group = m.groupdict()
                lb_dict['modify_cnt'] = int(group['modify_cnt'])
                lb_dict['bwalk_cnt'] = int(group['bwalk_cnt'])
                lb_dict['subwalk_cnt'] = int(group['subwalk_cnt'])
                lb_dict['finish_cnt'] = int(group['finish_cnt'])
                lb_dict['aal'] = {}
                lb_dict['bwalk'] = {}
                continue

            #bwalk:[req:0 in_prog:0 nested:0]
            m = p25.match(line)
            if m:
                group = m.groupdict()
                lb_dict['bwalk']['req'] = int(group['req'])
                lb_dict['bwalk']['in_prog'] = int(group['in_prog'])
                lb_dict['bwalk']['nested'] = int(group['nested'])
                continue

            #AAL: ecr:id:4177526786 af:0 ecr_type:0 ref:3 ecrh:0x7f02737e49f8(28:2)
            m = p26.match(line)
            if m:
                group = m.groupdict()
                lb_dict['aal']['ecr_id'] = int(group['ecr_id'])
                lb_dict['aal']['af'] = int(group['af'])
                lb_dict['aal']['ecr_type'] = str(group['ecr_type'])
                lb_dict['aal']['ref'] = int(group['ref'])
                lb_dict['aal']['ecrh'] = str(group['ecrh'])
                continue

            #hwhdl:1937656312 ::0x7f02737e11c8,0x7f02737e2728,0x7f02737e11c8,0x7f02737e2728
            m = p27.match(line)
            if m:
                group = m.groupdict()
                lb_dict['aal']['hwhdl'] = str(group['hwhdl'])
                continue

            #Sw Enh ECR scale: objid:38 llabel:24 eos:1 #adjs:2 mixed_adj:0
            m = p28.match(line)
            if m:
                group = m.groupdict()
                objid = int(group['objid'])
                ecr_dict = ret_dict['lentry_label'][label_id].setdefault('sw_enh_ecr_scale', {}).setdefault(objid, {})
                ecr_dict['llabel'] = int(group['llabel'])
                ecr_dict['eos'] = int(group['eos'])
                ecr_dict['adjs'] = int(group['adjs'])
                ecr_dict['mixed_adj'] = str(group['mixed_adj'])
                continue

            #reprogram_hw:0 ecrhdl:0xf9000002 ecr_hwhdl:0x7f02737e49f8
            m = p29.match(line)
            if m:
                group = m.groupdict()
                ecr_dict['reprogram_hw'] = str(group['reprogram_hw'])
                ecr_dict['ecrhdl'] = str(group['ecrhdl'])
                ecr_dict['ecr_hwhdl'] = str(group['ecr_hwhdl'])
                continue

            # mod_cnt:0 prev_npath:0 pmismatch:0 pordermatch:0
            m = p30.match(line)
            if m:
                group = m.groupdict()
                ecr_dict['mod_cnt'] = int(group['mod_cnt'])
                ecr_dict['prev_npath'] = int(group['prev_npath'])
                ecr_dict['pmismatch'] = int(group['pmismatch'])
                ecr_dict['pordermatch'] = int(group['pordermatch'])
                ecr_dict['ecr_adj'] = {}
                continue

            #ecr_adj: id:1644167265 is_mpls_adj:1 l3adj_flags:0x100000
            m = p31.match(line)
            if m:
                group = m.groupdict()
                id1 = int(group['id'])
                ecr_dict['ecr_adj'][id1] = {}
                ecr_dict['ecr_adj'][id1]['is_mpls_adj'] = int(group['is_mpls_adj'])
                ecr_dict['ecr_adj'][id1]['l3adj_flags'] = str(group['l3adj_flags'])
                continue

            # recirc_adj_id:3120562239
            m = p32.match(line)
            if m:
                group = m.groupdict()
                ecr_dict['ecr_adj'][id1]['recirc_adj_id'] = int(group['recirc_adj_id'])
                continue

            # sih:0x7f02737e11c8(182) di_id:20499 rih:0x7f02737e0bf8(74)
            m = p33.match(line)
            if m:
                group = m.groupdict()
                ecr_dict['ecr_adj'][id1]['sih'] = str(group['sih'])
                ecr_dict['ecr_adj'][id1]['di_id'] = int(group['di_id'])
                ecr_dict['ecr_adj'][id1]['rih'] = str(group['rih'])
                continue

            # adj_lentry [eos0:0x7f02734123b8 eos1:0x7f02737ec5e8]
            m = p34.match(line)
            if m:
                group = m.groupdict()
                ecr_dict['ecr_adj'][id1]['adj_lentry'] = str(group['adj_lentry'])
                continue

            #ecr_prefix_adj: id:2483028067 (ref:1)
            m = p35.match(line)
            if m:
                group = m.groupdict()
                id1 = int(group['id'])
                ecr_dict['ecr_adj'][id1] = {}
                continue

            #objid:ADJ SPECIAL:0
            m = p36.match(line)
            if m:
                group = m.groupdict()
                lentry_dict['objid'] = {}
                id2 = str(group['objid'])
                lentry_dict['objid'][id2] = {}
                lentry_dict['objid'][id2]['SPECIAL'] = str(group['SPECIAL'])
                continue

        return ret_dict


# =============================================
# Schema for 'show platform software fed active acl counters hardware'
# =============================================
class ShowPlatformSoftwareFedactiveAclCountersHardwareSchema(MetaParser):
    """ Schema for
        * show platform software fed active acl counters hardware
    """

    schema = {
        'counters':{
            'unknown_stat_counter' : int,
            'ingress_ipv4_forward' : int,
            'ingress_ipv4_forward_from_cpu' : int,
            'ingress_ipv4_pacl_drop' : int,
            'ingress_ipv4_vacl_drop' : int,
            'ingress_ipv4_racl_drop' : int,
            'ingress_ipv4_gacl_drop' : int,
            'ingress_ipv4_racl_drop_and_log' : int,
            'ingress_ipv4_vacl_drop_and_log' : int,
            'ingress_ipv4_pacl_cpu' : int,
            'ingress_ipv4_vacl_cpu' : int,
            'ingress_ipv4_racl_cpu' : int,
            'ingress_ipv4_gacl_cpu' : int,
            'ingress_ipv4_tcp_mss_cpu' : int,
            'ingress_ipv6_forward' : int,
            'ingress_ipv6_forward_from_cpu' : int,
            'ingress_ipv6_pacl_drop' : int,
            'ingress_ipv6_vacl_drop' : int,
            'ingress_ipv6_racl_drop' : int,
            'ingress_ipv6_gacl_drop' : int,
            'ingress_ipv6_racl_drop_and_log' : int,
            'ingress_ipv6_vacl_drop_and_log' : int,
            'ingress_ipv6_pacl_cpu' : int,
            'ingress_ipv6_pacl_sisf_cpu' : int,
            'ingress_ipv6_vacl_cpu' : int,
            'ingress_ipv6_vacl_sisf_cpu' : int,
            'ingress_ipv6_racl_cpu' : int,
            'ingress_ipv6_gacl_cpu' : int,
            'ingress_ipv6_tcp_mss_cpu' : int,
            'ingress_mac_forward' : int,
            'ingress_mac_forward_from_cpu' : int,
            'ingress_mac_pacl_drop' : int,
            'ingress_mac_vacl_drop' : int,
            'ingress_mac_racl_drop' : int,
            'ingress_mac_gacl_drop' : int,
            'ingress_mac_racl_drop_and_log' : int,
            'ingress_mac_vacl_drop_and_log' : int,
            'ingress_mac_pacl_cpu' : int,
            'ingress_mac_vacl_cpu' : int,
            'ingress_mac_racl_cpu' : int,
            'ingress_mac_gacl_cpu' : int,
            'ingress_dai_smac_validation_drop' : int,
            'ingress_dai_dmac_validation_drop' : int,
            'ingress_dai_ip_validation_drop' : int,
            'ingress_arp_acl_permit' : int,
            'ingress_arp_acl_drop' : int,
            'ingress_auth_acl_drop' : int,
            Optional('ingress_ipv4_ipclients_cpu') : int,
            Optional('ingress_ipv6_ipclients_cpu') : int,
            Optional('ingress_ipv4_ipclients_drop') : int,
            Optional('ingress_ipv6_ipclients_drop') : int,

            'egress_ipv4_forward' : int,
            'egress_ipv4_forward_to_cpu' : int,
            Optional('egress_ipv4_forward_from_cpu') : int,
            'egress_ipv4_pacl_drop' : int,
            'egress_ipv4_vacl_drop' : int,
            'egress_ipv4_racl_drop' : int,
            'egress_ipv4_gacl_drop' : int,
            'egress_ipv4_racl_drop_and_log' : int,
            'egress_ipv4_vacl_drop_and_log' : int,
            'egress_ipv4_pacl_cpu' : int,
            'egress_ipv4_vacl_cpu' : int,
            'egress_ipv4_racl_cpu' : int,
            'egress_ipv4_gacl_cpu' : int,
            'egress_ipv4_tcp_mss_cpu' : int,
            'egress_ipv6_forward' : int,
            'egress_ipv6_forward_to_cpu' : int,
            Optional('egress_ipv6_forward_from_cpu') : int,
            'egress_ipv6_pacl_drop' : int,
            'egress_ipv6_vacl_drop' : int,
            'egress_ipv6_racl_drop' : int,
            'egress_ipv6_gacl_drop' : int,
            'egress_ipv6_racl_drop_and_log' : int,
            'egress_ipv6_vacl_drop_and_log' : int,
            'egress_ipv6_pacl_cpu' : int,
            'egress_ipv6_vacl_cpu' : int,
            'egress_ipv6_racl_cpu' : int,
            'egress_ipv6_gacl_cpu' : int,
            'egress_ipv6_tcp_mss_cpu' : int,
            'egress_mac_forward' : int,
            'egress_mac_forward_to_cpu' : int,
            Optional('egress_mac_forward_from_cpu') : int,
            'egress_mac_pacl_drop' : int,
            'egress_mac_vacl_drop' : int,
            'egress_mac_racl_drop' : int,
            'egress_mac_gacl_drop' : int,
            'egress_mac_racl_drop_and_log' : int,
            'egress_mac_vacl_drop_and_log' : int,
            'egress_mac_pacl_cpu' : int,
            'egress_mac_vacl_cpu' : int,
            'egress_mac_racl_cpu' : int,
            'egress_mac_gacl_cpu' : int,
            'egress_ipv4_cpu_queues_drop' : int,
            'egress_ipv4_p2p_drop' : int,
            'egress_ipv6_p2p_drop' : int,
            'egress_mac_p2p_drop' : int,
            'egress_ipv4_p2p_redirect' : int,
            'egress_ipv6_p2p_redirect' : int,
            'egress_mac_p2p_redirect' : int,
            'egress_ipv4_sgacl_drop' : int,
            'egress_ipv6_sgacl_drop' : int,
            'egress_ipv4_sgacl_test_cell_drop' : int,
            'egress_ipv6_sgacl_test_cell_drop' : int,
            'egress_ipv4_dns_response_cpu' : int,
            'egress_ipv6_dns_response_cpu' : int,
            'egress_ipv4_pre_sgacl_forward' : int,
        }
    }


class ShowPlatformSoftwareFedactiveAclCountersHardware(ShowPlatformSoftwareFedactiveAclCountersHardwareSchema):
    """ Parser for
        * show platform software fed active acl counters hardware
    """

    cli_command = 'show platform software fed active acl counters hardware'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        ret_dict = {}

        # Unknown Stat Counter    : 80
        p1 = re.compile(r'Unknown\s+Stat\s+Counter\s+:\s+(?P<unknown_stats>\d+)')

        # Ingress IPv4 Forward             (0x8d000003):       40365 frames
        # Ingress IPv6 GACL Drop           (0x0a000015):           0 frames
        # Ingress MAC Forward              (0x9100001f):       28270 frames
        # Egress IPv4 Forward              (0x77000030):       20480 frames
        # Egress IPv6 Forward to CPU       (0x5c00003e):           0 frames
        p2 = re.compile(r'^(?P<counter_name>.+[^ ])\s+(\(.+\))?:\s+(?P<num_frames>\d+)\s+frames$')


        for line in output.splitlines():
            line = line.strip()

            # Unknown Stat Counter             (0x49000001):      158905 frames
            m = p1.match(line)
            if m:
                group = m.groupdict()
                counters_dict = ret_dict.setdefault("counters", {})
                counters_dict["unknown_stat_counter"] = \
                    int(group["unknown_stats"])
                continue

            # Ingress IPv4 Forward             (0x8d000003):       40365 frames
            # Ingress IPv6 GACL Drop           (0x0a000015):           0 frames
            # Ingress MAC Forward              (0x9100001f):       28270 frames
            # Egress IPv4 Forward              (0x77000030):       20480 frames
            # Egress IPv6 Forward to CPU       (0x5c00003e):           0 frames
            m = p2.match(line)
            if m:
                group = m.groupdict()
                counter_name = group["counter_name"].lower().replace(" ", "_")
                counters_dict = ret_dict.setdefault("counters", {})
                counters_dict[counter_name] = int(group["num_frames"])
                continue

        return ret_dict


# =======================================================================
# Schema for 'show platform hardware throughput crypto'
# =======================================================================
class ShowPlatformHardwareThroughputCryptoSchema(MetaParser):
    schema = {
        'current_configured_crypto_throughput_level': str,
        'current_enforced_crypto_throughput_level': str,
        'default_crypto_throughput_level': str,
        'level': str,
        'reboot': str,
        'crypto_throughput': str,
        Optional('current_boot_level'): str
    }

# ================================================================
# Parser for 'show platform hardware throughput crypto'
# ================================================================
class ShowPlatformHardwareThroughputCrypto(ShowPlatformHardwareThroughputCryptoSchema):
    ''' Parser for 'show platform hardware throughput crypto' '''

    cli_command = ['show platform hardware throughput crypto']

    def cli(self, output=None):

        if output is None:
            out = self.device.execute(self.cli_command[0])
        else:
            out = output

        ret_dict = {}

        # Current configured crypto throughput level: T3
        p1 = re.compile(r'^Current configured crypto throughput level: (?P<level>.+)$')

        # Current enforced crypto throughput level: 10G
        p2 = re.compile(r'^Current enforced crypto throughput level: (?P<level>.+)$')

        # Default Crypto throughput level: 2.5G
        p3 = re.compile(r'^Default Crypto throughput level: (?P<level>.+)$')

        # Level is saved, reboot is not required
        p4 = re.compile(r'^Level is (?P<saved>[^,]+), reboot is (?P<reboot>.+)$')

        # Crypto Throughput is not throttled
        p5 = re.compile(r'^Crypto Throughput is (?P<throttled>.+)$')

        # Current boot level is network-premier
        p6 = re.compile(r'^Current boot level is (?P<level>.+)$')

        for line in out.splitlines():
            line = line.strip()
            # Current configured crypto throughput level: T3
            m = p1.match(line)
            if m:
                ret_dict['current_configured_crypto_throughput_level'] = m.groupdict()['level']
                continue

            # Current enforced crypto throughput level: 10G
            m = p2.match(line)
            if m:
                ret_dict['current_enforced_crypto_throughput_level'] = m.groupdict()['level']
                continue

            # Default Crypto throughput level: 2.5G
            m = p3.match(line)
            if m:
                ret_dict['default_crypto_throughput_level'] = m.groupdict()['level']
                continue

            # Level is saved, reboot is not required
            m = p4.match(line)
            if m:
                ret_dict['level'] = m.groupdict()['saved']
                ret_dict['reboot'] = m.groupdict()['reboot']
                continue

            # Crypto Throughput is not throttled
            m = p5.match(line)
            if m:
                ret_dict['crypto_throughput'] = m.groupdict()['throttled']
                continue

            # Current boot level is network-premier
            m = p6.match(line)
            if m:
                ret_dict['current_boot_level'] = m.groupdict()['level']
                continue

        return ret_dict

# =======================================================================
# Schema for 'show platform software object-manager {switch} {switch_type} F0 statistics'
# =======================================================================
class ShowPlatSwObjectManagerF0StatisticsSchema(MetaParser):
    """Schema for :
        show platform software object-manager {switch} {switch_type} F0 statistics"""
    schema = {
        'object_update': {
            'pending_issue': int,
            'pending_acknowledgement': int,
        },
        'batch_begin': {
            'pending_issue': int,
            'pending_acknowledgement': int,
        },
        'batch_end': {
            'pending_issue': int,
            'pending_acknowledgement': int,
        },
        'command': {
            'pending_acknowledgement': int,
        },

        'total_objects': int,
        'stale_objects': int,
        'resolve_objects': int,
        'childless_delete_objects': int,
        'backplane_objects': int,
        'error_objects': int,
        'number_of_bundles': int,
        'paused_types': int,
    }


# ================================================================
# Parser for 'show platform software object-manager {switch} {switch_type} F0 statistics'
# ================================================================
class ShowPlatSwObjectManagerF0Statistics(ShowPlatSwObjectManagerF0StatisticsSchema):
    """parser for :
        'show platform software object-manager {switch} {switch_type} F0 statistics'
        'show platform software object-manager F0 statistics'
    """

    cli_command = [
        'show platform software object-manager F0 statistics',
        'show platform software object-manager {switch} {switch_type} F0 statistics'
    ]
    def cli(self, switch=None, switch_type=None, output=None):
        if output is None:
            if switch and switch_type:
                cmd = self.cli_command[1].format(switch=switch,switch_type=switch_type)
            else:
                cmd = self.cli_command[0]
            out = self.device.execute(cmd)
        else:
            out = output

        result_dict = {}

        # Object update: Pending-issue: 180, Pending-acknowledgement: 89
        p1 = re.compile(r'^Object update:\s+Pending-issue:'
                        r'\s+(?P<pending_issue>\d+)\,\s'
                        r'Pending-acknowledgement: '
                        r'(?P<pending_acknowledgement>\d+)$')

        # Batch begin:   Pending-issue: 0, Pending-acknowledgement: 0
        p2 = re.compile(r'^Batch begin:\s+Pending-issue:'
                        r'\s+(?P<pending_issue>\d+)\,\s'
                        r'Pending-acknowledgement: '
                        r'(?P<pending_acknowledgement>\d+)$')

        # Batch end:     Pending-issue: 0, Pending-acknowledgement: 0
        p3 = re.compile(r'^Batch end:\s+Pending-issue:'
                        r'\s+(?P<pending_issue>\d+)\,\s'
                        r'Pending-acknowledgement: '
                        r'(?P<pending_acknowledgement>\d+)$')

        # Command:       Pending-acknowledgement: 0
        p4 = re.compile(r'^Command:+'
                        r'\s+Pending-acknowledgement: '
                        r'(?P<pending_acknowledgement>\d+)$')

        # Total-objects: 1401
        p5 = re.compile(r'^Total-objects:'r'\s+(?P<total_objects>\d+)$')

        # Stale-objects: 0
        p6 = re.compile(r'^Stale-objects:'r'\s+(?P<stale_objects>\d+)$')

        # Resolve-objects: 0
        p7 = re.compile(r'^Resolve-objects:'r'\s+(?P<resolve_objects>\d+)$')

        # Childless-delete-objects: 0
        p8 = re.compile(r'^Childless-delete-objects:'r'\s+(?P<childless_delete_objects>\d+)$')

        # Backplane-objects: 0
        p9 = re.compile(r'^Backplane-objects:'r'\s+(?P<backplane_objects>\d+)$')

        #Error-objects: 1
        p10 = re.compile(r'^Error-objects:'r'\s+(?P<error_objects>\d+)$')

        #Number of bundles: 136
        p11 = re.compile(r'^Number of bundles:'r'\s+(?P<number_of_bundles>\d+)$')

        #Paused-types: 0
        p12 = re.compile(r'^Paused-types:'r'\s+(?P<paused_types>\d+)$')

        for line in out.splitlines():
            line = line.strip()

            # Object update: Pending-issue: 180, Pending-acknowledgement: 89
            m = p1.match(line)
            if m:
                group = m.groupdict()
                object_update = result_dict.setdefault('object_update', {})
                object_update.update({
                    'pending_issue': int(group['pending_issue']),
                    'pending_acknowledgement': int(group['pending_acknowledgement'])
                })
                continue

            # Batch begin:   Pending-issue: 0, Pending-acknowledgement: 0
            m = p2.match(line)
            if m:
                group = m.groupdict()
                batch_begin = result_dict.setdefault('batch_begin', {})
                batch_begin.update({
                    'pending_issue': int(group['pending_issue']),
                    'pending_acknowledgement': int(group['pending_acknowledgement'])
                })
                continue

            # Batch end:     Pending-issue: 0, Pending-acknowledgement: 0
            m = p3.match(line)
            if m:
                group = m.groupdict()
                batch_end = result_dict.setdefault('batch_end', {})
                batch_end.update({
                    'pending_issue': int(group['pending_issue']),
                    'pending_acknowledgement': int(group['pending_acknowledgement'])
                })
                continue

            # Command:       Pending-acknowledgement: 0
            m = p4.match(line)
            if m:
                group = m.groupdict()
                command = result_dict.setdefault('command', {})
                command.update({
                    'pending_acknowledgement': int(group['pending_acknowledgement'])
                })
                continue

            # Total-objects: 1401
            m = p5.match(line)
            if m:
                group = m.groupdict()
                result_dict['total_objects'] = int(group['total_objects'])
                continue

            # Stale-objects: 0
            m = p6.match(line)
            if m:
                group = m.groupdict()
                result_dict['stale_objects'] = int(group['stale_objects'])
                continue

            # Resolve-objects: 0
            m = p7.match(line)
            if m:
                group = m.groupdict()
                result_dict['resolve_objects'] = int(group['resolve_objects'])
                continue

            # Childless-delete-objects: 0
            m = p8.match(line)
            if m:
                group = m.groupdict()
                result_dict['childless_delete_objects'] = int(group['childless_delete_objects'])
                continue

            # Backplane-objects: 0
            m = p9.match(line)
            if m:
                group = m.groupdict()
                result_dict['backplane_objects'] = int(group['backplane_objects'])
                continue

            #Error-objects: 1
            m = p10.match(line)
            if m:
                group = m.groupdict()
                result_dict['error_objects'] = int(group['error_objects'])
                continue

            #Number of bundles: 136
            m = p11.match(line)
            if m:
                group = m.groupdict()
                result_dict['number_of_bundles'] = int(group['number_of_bundles'])
                continue

            #Paused-types: 0
            m = p12.match(line)
            if m:
                group = m.groupdict()
                result_dict['paused_types'] = int(group['paused_types'])
                continue

        return result_dict


# =======================================================================
# Schema for 'show platform software object-manager {switch} {switch_type} F0 error-object'
# =======================================================================
class ShowPlatSwObjectManagerF0ErrorObjectSchema(MetaParser):
    """Schema for :
        'show platform software object-manager {switch} {switch_type} F0 error-object'
        'show platform software object-manager F0 error-object'
    """
    schema = {
        'identifier': {
            Any(): {
                Optional('identifier'): int,
                Optional('status'): str,
                Optional('description'): str,
            }
        },
    }

class ShowPlatSwObjectManagerF0ErrorObject(ShowPlatSwObjectManagerF0ErrorObjectSchema):
    """parser for :
        show platform software object-manager {switch} {switch_type} F0 error-object
        show platform software object-manage F0 error-object
    """

    cli_command = [
            'show platform software object-manager F0 error-object',
            'show platform software object-manager {switch} {switch_type} F0 error-object'
    ]

    def cli(self, switch=None, switch_type=None, output=None):

        if output is None:
            if switch and switch_type:
                cmd = self.cli_command[1].format(switch=switch,switch_type=switch_type)
            else:
                cmd = self.cli_command[0]
            out = self.device.execute(cmd)
        else:
            out = output

        result_dict = {}

        # Description: PREFIX 2.2.2.2/32 (Table id 1)
        p0 = re.compile(r'^Description:\s+(?P<description>.*).*$')

        # Object identifier: 1515
        p1 = re.compile(r'^Object identifier:\s+(?P<identifier>\d+)$')

        # Status: Create-failed"
        p2 = re.compile(r'Status:\s+(?P<status>\S+)$')

        for line in out.splitlines():
            line = line.strip()

            # Object identifier: 1515
            m = p1.match(line)
            if m:
                group = m.groupdict()
                identifier = group.pop('identifier')

                identifier_dict = result_dict.setdefault('identifier', {})
                n_identifier_dict = identifier_dict.setdefault(int(identifier), {})

                n_identifier_dict.update({
                    'identifier': int(identifier),
                })

            # Description: PREFIX 2.2.2.2/32 (Table id 1)
            m = p0.match(line)
            if m:
                group = m.groupdict()
                n_identifier_dict.update({
                    'description': group['description']
                })

            # Status: Create-failed"
            m = p2.match(line)
            if m:
                group = m.groupdict()
                n_identifier_dict.update({
                    'status': group['status']
                })
        return result_dict

# ======================================================================================
#  Schema for
#  * 'show platform software object-manager {switch} {switch_type} F0 pending-ack-update'
#  * 'show platform software object-manager F0 pending-ack-update'
# =======================================================================================
class ShowPlatformSoftwareObjectManagerF0PendingAckUpdateSchema(MetaParser):
    """Schema for 'show platform software object-manager {switch} {switch_type} F0 pending-ack-update'
                  'show platform software object-manager F0 pending-ack-update'
    """
    schema = {
        'object_id': {
            Any(): {
                'update_id': int,
                'description': str,
                'action': str,
                'pending_sec': int,
                'num_retries': int,
                'number_batch_begin_retries': int,
                'number_nacked_download_retries': int,               
            },
        }
    }

# =======================================================================================
#  Parser for
#  * 'show platform software object-manager {switch} {switch_type} F0 pending-ack-update'
#  * 'show platform software object-manager F0 pending-ack-update'
# =======================================================================================

class ShowPlatformSoftwareObjectManagerF0PendingAckUpdate(ShowPlatformSoftwareObjectManagerF0PendingAckUpdateSchema):
    """
    Parser for :
        * 'show platform software object-manager {switch} {switch_type} F0 pending-ack-update'
        * 'show platform software object-manager F0 pending-ack-update'
    """
    cli_command = ['show platform software object-manager {switch} {switch_type} F0 pending-ack-update',\
                    'show platform software object-manager F0 pending-ack-update']
    
    def cli(self, switch_type="", switch="", output=None):
        if output is None:
            if switch and switch_type:
                output = self.device.execute(self.cli_command[0].format(switch=switch, switch_type=switch_type))
            else:
                output = self.device.execute(self.cli_command[1])
        else:
            output = output

        # initial return dictionary
        ret_dict = {}
        sub_dict = {}

        # Update identifier: 305, Object identifier: 305
        p1 = re.compile(r'^Update identifier:\s+(?P<update_id>\d*)(?:,\s*)Object identifier:\s+(?P<object_id>\d*)$')

        # Description: [aom_mlist_show_cb] mlist 2046
        p2 = re.compile(r'^Description:\s*(?P<description>.*)$')

        # Action: Create, Pending seconds: 3930
        p3 = re.compile(r'^Action:\s*(?P<action>\w*)(?:,\s*)Pending seconds:\s*(?P<pending_sec>\d*)$')

        # Number of retries: 0, Number of batch begin retries: 0, Number of nacked download retries: 0
        p4 = re.compile(r'^Number of retries:\s*(?P<num_retries>\d*)(?:,\s*)'
                        r'Number of batch begin retries:\s*(?P<number_batch_begin_retries>\d*)(?:,\s*)'
                        r'Number of nacked download retries:\s*(?P<number_nacked_download_retries>\d*)$')

        for line in output.splitlines():
            line = line.strip()

            # Update identifier: 305, Object identifier: 305
            m = p1.match(line)
            if m:
                groups = m.groupdict()
                object_id = groups['object_id']
                sub_dict = ret_dict.setdefault('object_id', {}).setdefault(object_id, {})
                
                update_id = groups['update_id']
                sub_dict['update_id'] = int(update_id)
                continue

            # Description: [aom_mlist_show_cb] mlist 2046
            m = p2.match(line)
            if m:
                group = m.groupdict()
                description = group['description']
                sub_dict['description'] = str(description)
                continue

            # Action: Create, Pending seconds: 3930
            m = p3.match(line)
            if m:
                group = m.groupdict()
                action = group['action']
                sub_dict['action'] = str(action)

                pending_sec = group['pending_sec']
                sub_dict['pending_sec'] = int(pending_sec)
                continue

            # Number of retries: 0, Number of batch begin retries: 0, Number of nacked download retries: 0
            m = p4.match(line)
            if m:
                group = m.groupdict()
                num_retries = group['num_retries']
                sub_dict['num_retries'] = int(num_retries)

                number_batch_begin_retries = group['number_batch_begin_retries']
                sub_dict['number_batch_begin_retries'] = int(number_batch_begin_retries)

                number_nacked_download_retries = group['number_nacked_download_retries']
                sub_dict['number_nacked_download_retries'] = int(number_nacked_download_retries)
                continue

        return ret_dict

# ============================================================================
# Schema for 'show platform software fed active inject packet-capture detailed'
# ===========================================================================
class ShowPlatformSoftwareFedActiveInjectPacketCaptureDetailedSchema(MetaParser):
    """ Schema for
            * show platform software fed active inject packet-capture detailed
        """
    schema = {
        'inject_packet_capture': str,
        'buffer_wrapping': str,
        'total_captured': int,
        'capture_capacity': int,
        'capture_filter': str,
        'inject_packet_number': {
            Any():{
                'interface': {
                    'pal': {
                        'iifd': str
                    },
                },
                'metadata': {
                    'cause': str,
                    'sub_cause': str,
                    'q_no': str,
                    'linktype': str
                },
                'ether_hdr_1': {
                    'dest_mac': str,
                    'src_mac': str
                },
                'ether_hdr_2': {
                    'ether_type': str
                },
                'ipv4_hdr_1': {
                    'dest_ip': str,
                    'src_ip': str
                },
                'ipv4_hdr_2': {
                    'packet_len': str,
                    'ttl': str,
                    'protocol': str
                },
                'udp_hdr': {
                    'dest_port': str,
                    'src_port': str
                },
                'doppler_frame_descriptor': {
                    'fdformat': str,
                    'system_ttl': str,
                    'fdtype': str,
                    'span_session_map': str,
                    'qoslabel': str,
                    'fpe_first_header_type': str
                }

            }
        }
    }

# ================================================================
# Parser for:
#   * 'show platform software fed active inject packet-capture detailed'
# ================================================================
class ShowPlatformSoftwareFedActiveInjectPacketCaptureDetailed(
    ShowPlatformSoftwareFedActiveInjectPacketCaptureDetailedSchema):
    """ Parser for:
            show platform software fed active inject packet-capture detailed
    """

    cli_command = ['show platform software fed active inject packet-capture detailed']

    def cli(self, output=None):
        """ cli for:
         ' show platform software fed active inject packet-capture detailed '
        """

        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        #Inject packet capturing: disabled. Buffer wrapping: disabled
        p1 = re.compile(r'^Inject +packet +capturing:+\s+(?P<inject_packet_capture>\w+)\.+\s+'
                        r'Buffer +wrapping:\s+(?P<buffer_wrapping>\w+)$')

        #Total captured so far: 4 packets. Capture capacity : 4096 packets
        p2 = re.compile(r'^Total +captured +so +far:\s(?P<total_captured>\d)+\s+packets+\.\s+'
                       r'Capture +capacity +:\s+(?P<capture_capacity>\d+)+\s+packets$')

        #Capture filter : "udp.port == 9995"
        p3 = re.compile(r'^Capture +filter +: +(?P<capture_filter>.+)$')

        #------ Inject Packet Number: 1, Timestamp: 2021/09/15 07:40:40.603 ------
        p4 = re.compile(r'^-+\s+Inject +Packet +Number: +(?P<inject_packet_no>\d+)')

        #interface : pal:  [if-id: 0x00000000]
        p5 = re.compile(r'^interface +: pal: \s+\[+if-id: +(?P<iifd>\S+)$')

        #metadata  : cause: 2 [QFP destination lookup], sub-cause: 1, q-no: 0, linktype: MCP_LINK_TYPE_IP [1]
        p6 = re.compile(r'^metadata +: +cause: +(?P<cause>.+)'
                        r'\s+sub-cause: +(?P<sub_cause>\d+)\, +q-no: +(?P<q_no>\d+)\,'
                        r'\s+linktype: +(?P<linktype>.+)')

        #ether hdr : dest mac: 3c57.3104.6a00, src mac: 3c57.3104.6a00
        p7 = re.compile(r'^ether +hdr +: +dest +mac: +(?P<dest_mac>\S+)\s+src +mac: +(?P<src_mac>\S+)')

        #ether hdr : ethertype: 0x0800 (IPv4)
        p8 = re.compile(r'^ether +hdr +: +ethertype: +(?P<ether_type>.+)$')

        #ipv4  hdr : dest ip: 111.0.0.2, src ip: 111.0.0.1
        p9 = re.compile(r'^ipv4 +hdr +: +dest +ip: +(?P<dest_ip>\S+)\s+src +ip: +(?P<src_ip>\S+)')

        #ipv4  hdr : packet len: 188, ttl: 255, protocol: 17 (UDP)
        p10 = re.compile(r'^ipv4 +hdr +: +packet +len: +(?P<packet_len>\d+)\,\s+ttl: +(?P<ttl>\d+)'
                         r'\,+\s+protocol: +(?P<protocol>.+)$')

        #udp   hdr : dest port: 9995, src port: 53926
        p11 = re.compile(r'^udp +hdr +: +dest +port: +(?P<dest_port>\d+)\,\s+src +port: +(?P<src_port>\d+)')

        #Doppler Frame Descriptor :
        p12 = re.compile(r'^Doppler +Frame +Descriptor +:(?P<doppler_frame_descriptor>)$')

        #fdFormat                  = 0x3            systemTtl                 = 0x8
        p13 = re.compile(r'^fdFormat\s+\= (?P<fdformat>\S+)\s+systemTtl\s+\= (?P<system_ttl>\S+$)')

        #fdType                    = 0x1            spanSessionMap            = 0
        p14 = re.compile(r'^fdType\s+\= (?P<fdtype>\S+)\s+spanSessionMap\s+\= (?P<span_session_map>\S+$)')

        #qosLabel                  = 0x81           fpeFirstHeaderType        = 0
        p15 = re.compile(r'^qosLabel\s+\= (?P<qoslabel>\S+)\s+fpeFirstHeaderType\s+\= (?P<fpe_first_header_type>\S+$)')

        ret_dict = {}
        for line in out.splitlines():
            line = line.strip()

            # Inject packet capturing: disabled. Buffer wrapping: disabled
            m = p1.match(line)
            if m:
                ret_dict.update({
                    'inject_packet_capture': m.groupdict()['inject_packet_capture'],
                    'buffer_wrapping': m.groupdict()['buffer_wrapping']
                })
                continue

            # Total captured so far: 4 packets. Capture capacity : 4096 packets
            m = p2.match(line)
            if m:
                group = m.groupdict()
                ret_dict.update({
                    'total_captured':int(group['total_captured']),
                    'capture_capacity':int(group['capture_capacity'])
                })
                continue

            # Capture filter : "udp.port == 9995"
            m = p3.match(line)
            if m:
                ret_dict.update({'capture_filter': m.groupdict()['capture_filter']})
                continue

            # ------ Inject Packet Number: 1, Timestamp: 2021/09/15 07:40:40.603 ------
            m = p4.match(line)
            if m:
                group = m.groupdict()
                inject_packet_num = group['inject_packet_no']
                inject_packet_dict = ret_dict.setdefault('inject_packet_number', {}).setdefault(inject_packet_num, {})
                continue

            # interface : pal:  [if-id: 0x00000000]
            m = p5.match(line)
            if m:
                group = m.groupdict()
                int_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault('interface', {})
                pal_dict = ret_dict['inject_packet_number'][inject_packet_num]['interface'].setdefault('pal',{})
                pal_dict['iifd'] = group['iifd']
                continue

            # metadata  : cause: 2 [QFP destination lookup], sub-cause: 1, q-no: 0, linktype: MCP_LINK_TYPE_IP [1]
            m = p6.match(line)
            if m:
                group = m.groupdict()
                meta_data_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault('metadata',{})
                meta_data_dict['cause'] = group['cause']
                meta_data_dict['sub_cause'] = group['sub_cause']
                meta_data_dict['q_no'] = group['q_no']
                meta_data_dict['linktype'] = group['linktype']
                continue

            # ether hdr : dest mac: 3c57.3104.6a00, src mac: 3c57.3104.6a00
            m = p7.match(line)
            if m:
                group = m.groupdict()
                ether_hdr_1_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault('ether_hdr_1',{})
                ether_hdr_1_dict['dest_mac'] = group['dest_mac']
                ether_hdr_1_dict['src_mac'] = group['src_mac']
                continue

            # ether hdr : ethertype: 0x0800 (IPv4)
            m = p8.match(line)
            if m:
                group = m.groupdict()
                ether_hdr_2_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault('ether_hdr_2',{})
                ether_hdr_2_dict['ether_type'] = group['ether_type']
                continue

            # ipv4  hdr : dest ip: 111.0.0.2, src ip: 111.0.0.1
            m = p9.match(line)
            if m:
                group = m.groupdict()
                ipv4_hdr_1_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault('ipv4_hdr_1',{})
                ipv4_hdr_1_dict['dest_ip'] = group['dest_ip']
                ipv4_hdr_1_dict['src_ip'] = group['src_ip']
                continue

            # ipv4  hdr : packet len: 188, ttl: 255, protocol: 17 (UDP)
            m = p10.match(line)
            if m:
                group = m.groupdict()
                ipv4_hdr_2_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault('ipv4_hdr_2',{})
                ipv4_hdr_2_dict['packet_len'] = group['packet_len']
                ipv4_hdr_2_dict['ttl'] = group['ttl']
                ipv4_hdr_2_dict['protocol'] = group['protocol']
                continue

            # udp   hdr : dest port: 9995, src port: 53926
            m = p11.match(line)
            if m:
                group = m.groupdict()
                udp_hdr_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault('udp_hdr',{})
                udp_hdr_dict['dest_port'] = group['dest_port']
                udp_hdr_dict['src_port'] = group['src_port']
                continue

            # Doppler Frame Descriptor :
            m = p12.match(line)
            if m:
                group = m.groupdict()
                doppler_frame_des_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault(
                    'doppler_frame_descriptor',{})
                continue

            # fdFormat                  = 0x3            systemTtl                 = 0x8
            m = p13.match(line)
            if m:
                group = m.groupdict()
                doppler_frame_des_dict['fdformat'] = group['fdformat']
                doppler_frame_des_dict['system_ttl'] = group['system_ttl']
                continue

            # fdType                    = 0x1            spanSessionMap            = 0
            m = p14.match(line)
            if m:
                group = m.groupdict()
                doppler_frame_des_dict['fdtype'] = group['fdtype']
                doppler_frame_des_dict['span_session_map'] = group['span_session_map']
                continue

            # qosLabel                  = 0x81           fpeFirstHeaderType        = 0
            m = p15.match(line)
            if m:
                group = m.groupdict()
                doppler_frame_des_dict['qoslabel'] = group['qoslabel']
                doppler_frame_des_dict['fpe_first_header_type'] = group['fpe_first_header_type']
                continue

        return ret_dict

 # ===============================================================================
# Schema for 'show platform software dpidb index'
# ===============================================================================
class ShowPlatformSoftwareDpidIndexSchema(MetaParser):
    """Schema for :
        show platform software dpidb index"""

    schema = {
        Any(): {
            'index' : int,
        },
    }

# ===============================================================================
# Parser for 'show platform software dpidb index'
# ===============================================================================
class ShowPlatformSoftwareDpidIndex(ShowPlatformSoftwareDpidIndexSchema):
    """parser for :
        show platform software dpidb index"""

    cli_command = 'show platform software dpidb index'

    def cli(self, output=None,):

        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output
        result_dict = {}
        #Index 1030 -- swidb Hu1/0/1
        p1 = re.compile(r'^Index\s+(?P<index>\d+)\s+--\s+swidb\s+(?P<interface>\S+)$')

        for line in out.splitlines():
            line = line.strip()
            #Index 1030 -- swidb Hu1/0/1
            m = p1.match(line)
            if m:
                group = m.groupdict()
                interface = group.pop('interface')
                interface_dict = result_dict.setdefault(interface,{})
                interface_dict.update({
                    'index' : int(group['index']),
                })
                continue

        return result_dict

# =============================================================================
#  Schema for
#  * 'show platform software fed switch active ifm mappings lpn'
#  * 'show platform software fed switch active ifm mappings lpn | {interface}'
# ==============================================================================
class ShowPlatformSoftwareFedSwitchActiveIfmMappingsLpnSchema(MetaParser):
    """Schema for 'show platform software fed switch active ifm mappings lpn'
    """
    schema = {
        'interfaces':{
            Any(): {
                'lpn': int,
                'asic': int,
                'port': int,
                'if_id': str,
                'active': str
            }
        },
    }




# ===============================================================================
#  Parser for
#  * 'show platform software fed switch active ifm mappings lpn'
#  * 'show platform software fed switch active ifm mappings lpn | i {interface}'
# ================================================================================
class ShowPlatformSoftwareFedSwitchActiveIfmMappingsLpn(ShowPlatformSoftwareFedSwitchActiveIfmMappingsLpnSchema):
    """
    Parser for :
        * show platform software fed switch active ifm mappings lpn
    """

    cli_command = ['show platform software fed switch active ifm mappings lpn',
                   'show platform software fed switch active ifm mappings lpn | include {interface}']

    def cli(self, interface="", output=None):
        if output is None:
            if interface:
                cmd = self.cli_command[1].format(interface=interface)
            else:
                cmd = self.cli_command[0]
            output = self.device.execute(cmd)

        #19   1     18    TenGigabitEthernet1/0/19   0x0000001b  y
        p = re.compile(r'^(?P<lpn>\d+)\s+(?P<asic>\d+)\s+(?P<port>\d+)\s+(?P<interfaces>\S+)\s+(?P<if_id>(0x([\da-fA-F]){8}))\s+(?P<active>\S+)$')

        # initial return dictionary
        ret_dict ={}

        for line in output.splitlines():
            line = line.strip()

            #19    1  18    TenGigabitEthernet1/0/19   0x0000001b  y
            m = p.match(line)
            if m:

                group = m.groupdict()
                interfaces = group['interfaces']
                sub_dict = ret_dict.setdefault('interfaces', {}).setdefault(interfaces, {})

                lpn = group['lpn']
                sub_dict['lpn'] = int(lpn)

                asic = group['asic']
                sub_dict['asic'] = int(asic)

                port = group['port']
                sub_dict['port'] = int(port)

                if_id = group['if_id']
                sub_dict['if_id'] = if_id

                active = group['active']
                sub_dict['active'] = active
                continue
        return ret_dict

# ======================================================================================
#  Schema for
#  * 'show platform software fed {switch} active ifm interfaces {label}'
#  * 'show platform software fed active ifm interfaces {label}'
# =======================================================================================
class ShowPlatformSoftwareFedSwitchActiveIfmInterfacesLabelSchema(MetaParser):
    """Schema for 'show platform software fed {switch} active ifm interfaces {label}'
                  'show platform software fed active ifm interfaces {label}'
    """
    schema = {
        'interface_name': {
            Any(): {
                'if_id': str,
                'state': str,
            }
        }
    }

# =======================================================================================
#  Parser for
#  * 'show platform software fed {switch} active ifm interfaces {label}'
#  * 'show platform software fed active ifm interfaces {label}'
# =======================================================================================

class ShowPlatformSoftwareFedSwitchActiveIfmInterfacesLabel(ShowPlatformSoftwareFedSwitchActiveIfmInterfacesLabelSchema):
    """
    Parser for :
        * 'show platform software fed {switch} active ifm interfaces {label}'
        * 'show platform software fed active ifm interfaces {label}'
    """
    cli_command = ['show platform software fed {switch} active ifm interfaces {label}',\
                    'show platform software fed active ifm interfaces {label}']
    
    label = ['lisp', 'sw-subif']

    def cli(self, label="", switch=None, output=None):
        if output is None:
            if switch and label:
                output = self.device.execute(self.cli_command[0].format(switch=switch, label=label))
            elif label:
                output = self.device.execute(self.cli_command[1].format(label=label))
            else:
                return ImportError
        else:
            output = output

        # initial return dictionary
        ret_dict ={}

        # LISP0.4103                        0x0000054d          Ready
        # LISP0                             0x0000054c          Ready
        p1 = re.compile(r'^(?P<interface_name>LISP0.\w+|LISP0)(?:\s*)(?P<if_id>0x\w+)(?:\s*)(?P<state>\w+)$')

        for line in output.splitlines():
            line = line.strip()

            # LISP0.4103                        0x0000054d          Ready
            # LISP0                             0x0000054c          Ready
            m = p1.match(line)
            if m:
                group = m.groupdict()
                interface_name = group['interface_name']
                sub_dict = ret_dict.setdefault('interface_name', {}).setdefault(interface_name, {})
                if_id = group['if_id']
                sub_dict['if_id'] = str(if_id)
                state = group['state']
                sub_dict['state'] = str(state)
                continue

        return ret_dict

# =================================================================
#  Schema for 'show platform software fed switch active ptp domain
# ================================================================
class ShowPlatformSoftwareFedSwitchActivePtpDomainSchema(MetaParser):
    """Schema for 'show platform software fed switch {switch} ptp domain
    """
    schema = {
        'domain_number': {
            Any(): {
                'profile_type': str,
                'profile_state': str,
                Optional('clock_mode'): str,
                Optional('delay_mechanism'): str,
                Optional('ptp_clock'): str,
                Optional('mean_path_delay_ns'): int,
                'transport_method': str,
                'message_general_ip_dscp': int,
                'message_event_ip_dscp': int
            }
        },
    }
# =================================================================
#  Parser for 'show platform software fed switch active ptp domain
# ================================================================
class ShowPlatformSoftwareFedSwitchActivePtpDomain(ShowPlatformSoftwareFedSwitchActivePtpDomainSchema):
    """
    Parser for :
        * show platform software fed switch active ptp domain
    """

    cli_command = 'show platform software fed switch active ptp domain'

    def cli(self, output=None):

        if output is None:
            output = self.device.execute(self.cli_command)

        #Displaying data for domain number 0
        p1 = re.compile(r'^Displaying\sdata\sfor\sdomain\snumber\s(?P<domain_number>\d+)$')

        #Profile Type : DEFAULT
        p2 = re.compile(r'^Profile\sType\s\:\s(?P<profile_type>[a-zA-Z]+)$')

        #Profile State: enabled
        p3 = re.compile(r'^Profile\sState\:\s(?P<profile_state>\S+)$')

        #Clock Mode : BOUNDARY CLOCK
        p4 = re.compile(r'^Clock\sMode\s\:\s(?P<clock_mode>[A-Z\s]+)$')

        #Delay Mechanism: : END-TO-END
        p5 = re.compile(r'^Delay\sMechanism\:\s\:\s(?P<delay_mechanism>[A-Z\-]+)$')

        #PTP clock : 1970-1-24 22:41:20
        p6 = re.compile(r'^PTP\sclock\s\:\s(?P<ptp_clock>[\d\-\:\s]+)$')

        #mean_path_delay 83 nanoseconds
        p7 = re.compile(r'^mean_path_delay\s(?P<mean_path_delay_ns>\d+)\snanoseconds$')

        #Transport Method : 802.3
        p8 = re.compile(r'^Transport\sMethod\s\:\s(?P<transport_method>[\w\.\-]+)$')

        #Message general ip dscp  : 47
        p9 = re.compile(r'^Message\sgeneral\sip\sdscp\s+\:\s(?P<message_general_ip_dscp>\d+)$')

        #Message event ip dscp    : 59
        p10 = re.compile(r'^Message\sevent\sip\sdscp\s+\:\s(?P<message_event_ip_dscp>\d+)$')

        # initial return dictionary
        ret_dict ={}

        for line in output.splitlines():
            line = line.strip()

            #Displaying data for domain number 0
            m = p1.match(line)
            if m:
                ret_dict.setdefault('domain_number',{})
                domain_number = m.groupdict()['domain_number']
                sub_dict = ret_dict['domain_number'].setdefault(int(domain_number),{})
                continue

            #Profile Type : DEFAULT
            m = p2.match(line)
            if m:
                profile_type = m.groupdict()['profile_type']
                sub_dict['profile_type'] = profile_type
                continue

            #Profile State: enabled
            m = p3.match(line)
            if m:
                profile_state = m.groupdict()['profile_state']
                sub_dict['profile_state'] = profile_state
                continue

            #Clock Mode : BOUNDARY CLOCK
            m = p4.match(line)
            if m:
                clock_mode = m.groupdict()['clock_mode']
                sub_dict['clock_mode'] = clock_mode
                continue

            #Delay Mechanism: : END-TO-END
            m = p5.match(line)
            if m:
                delay_mechanism  = m.groupdict()['delay_mechanism']
                sub_dict['delay_mechanism'] = delay_mechanism
                continue

            #PTP clock : 1970-1-24 22:41:20
            m = p6.match(line)
            if m:
                ptp_clock = m.groupdict()['ptp_clock']
                sub_dict['ptp_clock'] = ptp_clock
                continue

            #mean_path_delay 83 nanoseconds
            m = p7.match(line)
            if m:
                mean_path_delay_ns = m.groupdict()['mean_path_delay_ns']
                sub_dict['mean_path_delay_ns'] = int(mean_path_delay_ns)
                continue

            #Transport Method : 802.3
            m = p8.match(line)
            if m:
                transport_method = m.groupdict()['transport_method']
                sub_dict['transport_method'] = transport_method
                continue

            #Message general ip dscp  : 47
            m = p9.match(line)
            if m:
                message_general_ip_dscp = m.groupdict()['message_general_ip_dscp']
                sub_dict['message_general_ip_dscp'] = int(message_general_ip_dscp)
                continue

            #Message event ip dscp    : 59
            m = p10.match(line)
            if m:
                message_event_ip_dscp = m.groupdict()['message_event_ip_dscp']
                sub_dict['message_event_ip_dscp'] = int(message_event_ip_dscp)
                continue
        return ret_dict

# ================================================================================
#  Schema for 'show platform software fed switch active ptp interface {interface}'
# ================================================================================
class ShowPlatformSoftwareFedSwitchActivePtpInterfaceInterfaceSchema(MetaParser):
    """Schema for 'show platform software fed switch active ptp interface {interface}'
    """
    schema = {
        'ptp_interface': {
            'ptp_info': {
                'if_id': str,
                'version': int,
                Optional('ptp_vlan_is_valid'): str,
                Optional('ptp_vlan_id'): int,
            },
            'port_info': {
                'mac_address': str,
                'clock_identity': str,
                'number': int,
                Optional('mode'): int,
                'state': str,
                'port_enabled': str
            },

            'num_info': {
                'num_sync_messages_transmitted': int,
                'num_followup_messages_transmitted': int,
                'num_sync_messages_received': int,
                'num_followup_messages_received': int,
                'num_delay_requests_transmitted': int,
            'num_delay_responses_received': int,
            'num_delay_requests_received': int,
            'num_delay_responses_transmitted': int
            },
            'domain_value': int,
            'profile_type': str,
            'clock_mode': str,
            'delay_mechanism': str,
            'ptt_port_enabled': str,
            'sync_seq_num': int,
            'delay_req_seq_num': int,
            'log_mean_sync_interval': int,
            'log_mean_delay_interval': int,
            Optional('tag_native_vlan'): str,
        }
    }

# =================================================================================
#  Parser for 'show platform software fed switch active ptp interface {interface}'
# =================================================================================
class ShowPlatformSoftwareFedSwitchActivePtpInterfaceInterface(ShowPlatformSoftwareFedSwitchActivePtpInterfaceInterfaceSchema):
    """
    Parser for :
        * show platform software fed switch active ptp interface {interface}
    """

    cli_command = 'show platform software fed switch active ptp interface {interface}'

    def cli(self, interface="", output=None):

        if output is None:
            output = self.device.execute(self.cli_command.format(interface=interface))

        #Displaying port data for if_id 2a
        #Displaying port data for if_id 29
        p1 = re.compile(r'^Displaying\sport\sdata\sfor\sif_id\s(?P<if_id>\S+)$')

        #Port Mac Address 34:ED:1B:7D:F2:A1
        p2 = re.compile(r'^Port\sMac\sAddress\s(?P<mac_address>([\da-fA-F]:?).*)$')

        #Port Clock Identity 34:ED:1B:FF:FE:7D:F2:80
        p3 = re.compile(r'^Port\sClock\sIdentity\s(?P<clock_identity>([\da-fA-F]:?).*)$')

        #Port number 33
        p4 = re.compile(r'^Port\snumber\s(?P<number>\d+)$')

        #PTP Version 2
        p5 = re.compile(r'^PTP\sVersion\s(?P<version>\d+)$')

        #domain_value 0
        p6 = re.compile(r'^domain_value\s(?P<domain_value>\d+)$')

        #Profile Type: : DEFAULT
        p7 = re.compile(r'^Profile\sType\:\s\:\s(?P<profile_type>\S+)$')

        #Clock Mode : BOUNDARY CLOCK
        p8 = re.compile(r'^Clock\sMode\s\:\s(?P<clock_mode>.*)$')

        #Delay mechanism: End-to-End
        p9 = re.compile(r'^Delay\smechanism\:\s(?P<delay_mechanism>\S+)$')

        #port_enabled: TRUE
        p10 = re.compile(r'^port_enabled\:\s(?P<port_enabled>\S+)$')

        #ptt_port_enabled: TRUE
        p11 = re.compile(r'^ptt_port_enabled\:\s(?P<ptt_port_enabled>\S+)$')

        #Port state: : SLAVE
        p12 = re.compile(r'^Port\sstate\:\s\:\s(?P<state>\S+)$')

        #sync_seq_num 2189
        p13 = re.compile(r'^sync_seq_num\s(?P<sync_seq_num>\d+)$')

        #delay_req_seq_num 0
        p14 = re.compile(r'^delay_req_seq_num\s(?P<delay_req_seq_num>\d+)$')

        #log mean sync interval -3
        p15 = re.compile(r'^log\smean\ssync\sinterval\s(?P<log_mean_sync_interval>[-?\d]+)$')

        #log mean delay interval -5
        p16 = re.compile(r'^log\smean\sdelay\sinterval\s(?P<log_mean_delay_interval>[-?\d]+)$')

        #ptp vlan is valid : FALSE
        p17 = re.compile(r'^ptp\svlan\sis\svalid\s\:\s(?P<ptp_vlan_is_valid>\S+)$')

        #ptp vlan id 0
        p18 = re.compile(r'^ptp\svlan\sid\s(?P<ptp_vlan_id>\d+)$')

        #port mode 2
        p19 = re.compile(r'^port\smode\s(?P<mode>\d+)$')

        #tag native vlan : FALSE
        p20 = re.compile(r'^tag\snative\svlan\s\:\s(?P<tag_native_vlan>\S+)$')

        #num sync messages transmitted  0
        p21 = re.compile(r'^num\ssync\smessages\stransmitted\s+(?P<num_sync_messages_transmitted>\d+)$')

        #num followup messages transmitted  0
        p22 = re.compile(r'^num\sfollowup\smessages\stransmitted\s+(?P<num_followup_messages_transmitted>\d+)$')

        #num sync messages received  8758
        p23 = re.compile(r'^num\ssync\smessages\sreceived\s+(?P<num_sync_messages_received>\d+)$')

        #num followup messages received  8757
        p24 = re.compile(r'^num\sfollowup\smessages\sreceived\s+(?P<num_followup_messages_received>\d+)$')

        #num delay requests transmitted  8753
        p25 = re.compile(r'^num\sdelay\srequests\stransmitted\s+(?P<num_delay_requests_transmitted>\d+)$')

        #num delay responses received 8753
        p26 = re.compile(r'^num\sdelay\sresponses\sreceived\s+(?P<num_delay_responses_received>\d+)$')

        #num delay requests received  0
        p27 = re.compile(r'^num\sdelay\srequests\sreceived\s+(?P<num_delay_requests_received>\d+)$')

        #num delay responses transmitted  0
        p28 = re.compile(r'^num\sdelay\sresponses\stransmitted\s+(?P<num_delay_responses_transmitted>\d+)$')

        # initial return dictionary
        ret_dict ={}
        for line in output.splitlines():
            line = line.strip()

            #Displaying port data for if_id 2a
            #Displaying port data for if_id 29
            m = p1.match(line)
            if m:
                ptp_interface = ret_dict.setdefault('ptp_interface', {})
                ptp_info = ptp_interface.setdefault('ptp_info',{})
                port_info = ptp_interface.setdefault('port_info',{})
                if_id = m.groupdict()['if_id']
                ptp_info['if_id'] = if_id
                continue

            #Port Mac Address 34:ED:1B:7D:F2:A1
            m = p2.match(line)
            if m:
                mac_address = m.groupdict()['mac_address']
                port_info['mac_address'] = mac_address
                continue

            #Port Clock Identity 34:ED:1B:FF:FE:7D:F2:80
            m = p3.match(line)
            if m:
                clock_identity = m.groupdict()['clock_identity']
                port_info['clock_identity'] = clock_identity
                continue

            #Port number 33
            m = p4.match(line)
            if m:
                number = m.groupdict()['number']
                port_info['number'] = int(number)
                continue

            #PTP Version 2
            m = p5.match(line)
            if m:
                version = m.groupdict()['version']
                ptp_info['version'] = int(version)
                continue

            #domain_value 0
            m = p6.match(line)
            if m:
                domain_value = m.groupdict()['domain_value']
                ptp_interface['domain_value'] = int(domain_value)
                continue

            #Profile Type: : DEFAULT
            m = p7.match(line)
            if m:
                profile_type = m.groupdict()['profile_type']
                ptp_interface['profile_type'] = profile_type
                continue

            #Clock Mode : BOUNDARY CLOCK
            m = p8.match(line)
            if m:
                clock_mode = m.groupdict()['clock_mode']
                ptp_interface['clock_mode'] = clock_mode
                continue

            #Delay mechanism: End-to-End
            m = p9.match(line)
            if m:
                delay_mechanism = m.groupdict()['delay_mechanism']
                ptp_interface['delay_mechanism'] = delay_mechanism
                continue

            #port_enabled: TRUE
            m = p10.match(line)
            if m:
                port_enabled = m.groupdict()['port_enabled']
                port_info['port_enabled'] = port_enabled
                continue

            #ptt_port_enabled: TRUE
            m = p11.match(line)
            if m:
                ptt_port_enabled = m.groupdict()['ptt_port_enabled']
                ptp_interface['ptt_port_enabled'] =  ptt_port_enabled
                continue

            #Port state: : SLAVE
            m = p12.match(line)
            if m:
                state = m.groupdict()['state']
                port_info['state'] = state
                continue

            #sync_seq_num 36853
            m = p13.match(line)
            if m:
                sync_seq_num = m.groupdict()['sync_seq_num']
                ptp_interface['sync_seq_num'] = int(sync_seq_num)
                continue

            #delay_req_seq_num 0
            m = p14.match(line)
            if m:
                delay_req_seq_num = m.groupdict()['delay_req_seq_num']
                ptp_interface['delay_req_seq_num'] = int(delay_req_seq_num)
                continue

            #log mean sync interval -3
            m = p15.match(line)
            if m:
                log_mean_sync_interval = m.groupdict()['log_mean_sync_interval']
                ptp_interface['log_mean_sync_interval'] = int(log_mean_sync_interval)
                continue

            #log mean delay interval -5
            m = p16.match(line)
            if m:
                log_mean_delay_interval = m.groupdict()['log_mean_delay_interval']
                ptp_interface['log_mean_delay_interval'] = int(log_mean_delay_interval)
                continue

            #ptp vlan is valid : FALSE
            m = p17.match(line)
            if m:
                ptp_vlan_is_valid = m.groupdict()['ptp_vlan_is_valid']
                ptp_info['ptp_vlan_is_valid'] = ptp_vlan_is_valid
                continue

            #ptp vlan id 0
            m = p18.match(line)
            if m:
                ptp_vlan_id = m.groupdict()['ptp_vlan_id']
                ptp_info['ptp_vlan_id'] = int(ptp_vlan_id)
                continue

            #port mode 2
            m = p19.match(line)
            if m:
                mode = m.groupdict()['mode']
                port_info['mode'] = int(mode)
                continue

            #tag native vlan : FALSE
            m = p20.match(line)
            if m:
                tag_native_vlan = m.groupdict()['tag_native_vlan']
                ptp_interface['tag_native_vlan'] = tag_native_vlan
                continue

            #num sync messages transmitted  17250
            m = p21.match(line)
            if m:
                num_sync_messages_transmitted = m.groupdict()['num_sync_messages_transmitted']
                num_info = ptp_interface.setdefault('num_info',{})
                num_info['num_sync_messages_transmitted'] = int(num_sync_messages_transmitted)
                continue

            #num followup messages transmitted  17250
            m = p22.match(line)
            if m:
                num_followup_messages_transmitted = m.groupdict()['num_followup_messages_transmitted']
                num_info['num_followup_messages_transmitted'] = int(num_followup_messages_transmitted)
                continue

            #num sync messages received  75403
            m = p23.match(line)
            if m:
                num_sync_messages_received = m.groupdict()['num_sync_messages_received']
                num_info['num_sync_messages_received'] = int(num_sync_messages_received)
                continue

            #num followup messages received  75401
            m = p24.match(line)
            if m:
                num_followup_messages_received = m.groupdict()['num_followup_messages_received']
                num_info['num_followup_messages_received'] = int(num_followup_messages_received)
                continue

            #num delay requests transmitted  75941
            m = p25.match(line)
            if m:
                num_delay_requests_transmitted = m.groupdict()['num_delay_requests_transmitted']
                num_info['num_delay_requests_transmitted'] = int(num_delay_requests_transmitted)
                continue

            #num delay responses received 75343
            m = p26.match(line)
            if m:
                num_delay_responses_received = m.groupdict()['num_delay_responses_received']
                num_info['num_delay_responses_received'] = int(num_delay_responses_received)
                continue

            #num delay requests received  17278
            m = p27.match(line)
            if m:
                num_delay_requests_received = m.groupdict()['num_delay_requests_received']
                num_info['num_delay_requests_received'] = int(num_delay_requests_received)
                continue

            #num delay responses transmitted  17278
            m = p28.match(line)
            if m:
                num_delay_responses_transmitted = m.groupdict()['num_delay_responses_transmitted']
                num_info['num_delay_responses_transmitted'] = int(num_delay_responses_transmitted)
                continue
        return ret_dict


# =========================================================
#  Schema for
#  * 'show platform software fed active acl usage'
#  * 'show platform software fed active acl usage | include {acl_name}'
# =========================================================
class ShowPlatformSoftwareFedActiveAclUsageSchema(MetaParser):
    """Schema for 'show platform software fed active acl usage
    """
    schema = {
        Optional('acl_usage'): {
            Optional('ace_software'): {
                 Optional('vmr_max') : int,
                 Optional('used') : int,
             },
            'acl_name': {
                Any(): {
                    'direction': {
                        Any(): {
                            'feature_type': str,
                            'acl_type': str,
                            'entries_used': int,
                        },
                    },
                },
            },
        }
    }

# =========================================================
#  Parser for
#  * 'show platform software fed active acl usage'
#  * 'show platform software fed active acl usage | include {acl_name}'
# =========================================================
class ShowPlatformSoftwareFedActiveAclUsage(ShowPlatformSoftwareFedActiveAclUsageSchema):
    """
    Parser for :
        * show platform software fed active acl usage
        * show platform software fed active acl usage | include {acl_name}
    """

    cli_command = ['show platform software fed active acl usage',
                   'show platform software fed active acl usage | include {acl_name}']

    def cli(self, acl_name="", output=None):
        if output is None:
            if acl_name:
                cmd = self.cli_command[1].format(acl_name=acl_name)
            else:
                cmd = self.cli_command[0]
            output = self.device.execute(cmd)

        ######  ACE Software VMR max:196608 used:253
        p1 = re.compile(r'^\#\#\#\#\#\s+ACE\sSoftware\sVMR\smax\:(?P<vmr_max>\d+)\sused\:(?P<used>\d+)$')


        #   RACL        IPV4     Ingress   PBR-DMVPN    92
        p2 = re.compile(r'^(?P<feature_type>\S+)\s+(?P<acl_type>\S+)\s+(?P<direction>\S+)\s+(?P<name>\S+)\s+(?P<entries_used>\d+)$')

        # initial return dictionary
        ret_dict ={}

        for line in output.splitlines():
            line = line.strip()

            acl_usage = ret_dict.setdefault('acl_usage', {})

            ######  ACE Software VMR max:196608 used:253
            m = p1.match(line)
            if m:
                group = m.groupdict()
                acl_usage = ret_dict.setdefault('acl_usage', {})
                ace_software = acl_usage.setdefault('ace_software',{})

                vmr_max = group['vmr_max']
                ace_software['vmr_max'] = int(vmr_max)

                used = group['used']
                ace_software['used'] = int(used)
                continue

            #   RACL        IPV4     Ingress   PBR-DMVPN    92
            m = p2.match(line)
            if m:
                group = m.groupdict()
                acl_name = acl_usage.setdefault('acl_name', {}).\
                                 setdefault(Common.convert_intf_name(group['name']), {})
                direction = acl_name.setdefault('direction',{}).\
                                 setdefault(Common.convert_intf_name(group['direction']), {})


                direction['feature_type'] = group['feature_type']
                direction['acl_type'] = group['acl_type']
                direction['entries_used'] = int(group['entries_used'])
                continue
        return ret_dict

# ============================================================================
# Schema for 'show platform software fed active inject packet-capture detailed'
# ===========================================================================
class ShowPlatformSoftwareFedActiveInjectPacketCaptureDetailedSchema(MetaParser):
    """ Schema for
            * show platform software fed active inject packet-capture detailed
        """
    schema = {
        'inject_packet_capture': str,
        'buffer_wrapping': str,
        'total_captured': int,
        'capture_capacity': int,
        'capture_filter': str,
        'inject_packet_number': {
            Any():{
                'interface': {
                    'pal': {
                        'iifd': str
                    },
                },
                'metadata': {
                    'cause': str,
                    'sub_cause': str,
                    'q_no': str,
                    'linktype': str
                },
                'ether_hdr_1': {
                    'dest_mac': str,
                    'src_mac': str
                },
                'ether_hdr_2': {
                    'ether_type': str
                },
                'ipv4_hdr_1': {
                    'dest_ip': str,
                    'src_ip': str
                },
                'ipv4_hdr_2': {
                    'packet_len': str,
                    'ttl': str,
                    'protocol': str
                },
                'udp_hdr': {
                    'dest_port': str,
                    'src_port': str
                },
                'doppler_frame_descriptor': {
                    'fdformat': str,
                    'system_ttl': str,
                    'fdtype': str,
                    'span_session_map': str,
                    'qoslabel': str,
                    'fpe_first_header_type': str
                }

            }
        }
    }

# ================================================================
# Parser for:
#   * 'show platform software fed active inject packet-capture detailed'
# ================================================================
class ShowPlatformSoftwareFedActiveInjectPacketCaptureDetailed(
    ShowPlatformSoftwareFedActiveInjectPacketCaptureDetailedSchema):
    """ Parser for:
            show platform software fed active inject packet-capture detailed
    """

    cli_command = ['show platform software fed active inject packet-capture detailed']

    def cli(self, output=None):
        """ cli for:
         ' show platform software fed active inject packet-capture detailed '
        """

        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        #Inject packet capturing: disabled. Buffer wrapping: disabled
        p1 = re.compile(r'^Inject +packet +capturing:+\s+(?P<inject_packet_capture>\w+)\.+\s+'
                        r'Buffer +wrapping:\s+(?P<buffer_wrapping>\w+)$')

        #Total captured so far: 4 packets. Capture capacity : 4096 packets
        p2 = re.compile(r'^Total +captured +so +far:\s(?P<total_captured>\d)+\s+packets+\.\s+'
                       r'Capture +capacity +:\s+(?P<capture_capacity>\d+)+\s+packets$')

        #Capture filter : "udp.port == 9995"
        p3 = re.compile(r'^Capture +filter +: +(?P<capture_filter>.+)$')

        #------ Inject Packet Number: 1, Timestamp: 2021/09/15 07:40:40.603 ------
        p4 = re.compile(r'^-+\s+Inject +Packet +Number: +(?P<inject_packet_no>\d+)')

        #interface : pal:  [if-id: 0x00000000]
        p5 = re.compile(r'^interface +: pal: \s+\[+if-id: +(?P<iifd>\S+)$')

        #metadata  : cause: 2 [QFP destination lookup], sub-cause: 1, q-no: 0, linktype: MCP_LINK_TYPE_IP [1]
        p6 = re.compile(r'^metadata +: +cause: +(?P<cause>.+)'
                        r'\s+sub-cause: +(?P<sub_cause>\d+)\, +q-no: +(?P<q_no>\d+)\,'
                        r'\s+linktype: +(?P<linktype>.+)')

        #ether hdr : dest mac: 3c57.3104.6a00, src mac: 3c57.3104.6a00
        p7 = re.compile(r'^ether +hdr +: +dest +mac: +(?P<dest_mac>\S+)\s+src +mac: +(?P<src_mac>\S+)')

        #ether hdr : ethertype: 0x0800 (IPv4)
        p8 = re.compile(r'^ether +hdr +: +ethertype: +(?P<ether_type>.+)$')

        #ipv4  hdr : dest ip: 111.0.0.2, src ip: 111.0.0.1
        p9 = re.compile(r'^ipv4 +hdr +: +dest +ip: +(?P<dest_ip>\S+)\s+src +ip: +(?P<src_ip>\S+)')

        #ipv4  hdr : packet len: 188, ttl: 255, protocol: 17 (UDP)
        p10 = re.compile(r'^ipv4 +hdr +: +packet +len: +(?P<packet_len>\d+)\,\s+ttl: +(?P<ttl>\d+)'
                         r'\,+\s+protocol: +(?P<protocol>.+)$')

        #udp   hdr : dest port: 9995, src port: 53926
        p11 = re.compile(r'^udp +hdr +: +dest +port: +(?P<dest_port>\d+)\,\s+src +port: +(?P<src_port>\d+)')

        #Doppler Frame Descriptor :
        p12 = re.compile(r'^Doppler +Frame +Descriptor +:(?P<doppler_frame_descriptor>)$')

        #fdFormat                  = 0x3            systemTtl                 = 0x8
        p13 = re.compile(r'^fdFormat\s+\= (?P<fdformat>\S+)\s+systemTtl\s+\= (?P<system_ttl>\S+$)')

        #fdType                    = 0x1            spanSessionMap            = 0
        p14 = re.compile(r'^fdType\s+\= (?P<fdtype>\S+)\s+spanSessionMap\s+\= (?P<span_session_map>\S+$)')

        #qosLabel                  = 0x81           fpeFirstHeaderType        = 0
        p15 = re.compile(r'^qosLabel\s+\= (?P<qoslabel>\S+)\s+fpeFirstHeaderType\s+\= (?P<fpe_first_header_type>\S+$)')

        ret_dict = {}
        for line in out.splitlines():
            line = line.strip()

            # Inject packet capturing: disabled. Buffer wrapping: disabled
            m = p1.match(line)
            if m:
                ret_dict.update({
                    'inject_packet_capture': m.groupdict()['inject_packet_capture'],
                    'buffer_wrapping': m.groupdict()['buffer_wrapping']
                })
                continue

            # Total captured so far: 4 packets. Capture capacity : 4096 packets
            m = p2.match(line)
            if m:
                group = m.groupdict()
                ret_dict.update({
                    'total_captured':int(group['total_captured']),
                    'capture_capacity':int(group['capture_capacity'])
                })
                continue

            # Capture filter : "udp.port == 9995"
            m = p3.match(line)
            if m:
                ret_dict.update({'capture_filter': m.groupdict()['capture_filter']})
                continue

            # ------ Inject Packet Number: 1, Timestamp: 2021/09/15 07:40:40.603 ------
            m = p4.match(line)
            if m:
                group = m.groupdict()
                inject_packet_num = group['inject_packet_no']
                inject_packet_dict = ret_dict.setdefault('inject_packet_number', {}).setdefault(inject_packet_num, {})
                continue

            # interface : pal:  [if-id: 0x00000000]
            m = p5.match(line)
            if m:
                group = m.groupdict()
                int_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault('interface', {})
                pal_dict = ret_dict['inject_packet_number'][inject_packet_num]['interface'].setdefault('pal',{})
                pal_dict['iifd'] = group['iifd']
                continue

            # metadata  : cause: 2 [QFP destination lookup], sub-cause: 1, q-no: 0, linktype: MCP_LINK_TYPE_IP [1]
            m = p6.match(line)
            if m:
                group = m.groupdict()
                meta_data_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault('metadata',{})
                meta_data_dict['cause'] = group['cause']
                meta_data_dict['sub_cause'] = group['sub_cause']
                meta_data_dict['q_no'] = group['q_no']
                meta_data_dict['linktype'] = group['linktype']
                continue

            # ether hdr : dest mac: 3c57.3104.6a00, src mac: 3c57.3104.6a00
            m = p7.match(line)
            if m:
                group = m.groupdict()
                ether_hdr_1_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault('ether_hdr_1',{})
                ether_hdr_1_dict['dest_mac'] = group['dest_mac']
                ether_hdr_1_dict['src_mac'] = group['src_mac']
                continue

            # ether hdr : ethertype: 0x0800 (IPv4)
            m = p8.match(line)
            if m:
                group = m.groupdict()
                ether_hdr_2_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault('ether_hdr_2',{})
                ether_hdr_2_dict['ether_type'] = group['ether_type']
                continue

            # ipv4  hdr : dest ip: 111.0.0.2, src ip: 111.0.0.1
            m = p9.match(line)
            if m:
                group = m.groupdict()
                ipv4_hdr_1_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault('ipv4_hdr_1',{})
                ipv4_hdr_1_dict['dest_ip'] = group['dest_ip']
                ipv4_hdr_1_dict['src_ip'] = group['src_ip']
                continue

            # ipv4  hdr : packet len: 188, ttl: 255, protocol: 17 (UDP)
            m = p10.match(line)
            if m:
                group = m.groupdict()
                ipv4_hdr_2_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault('ipv4_hdr_2',{})
                ipv4_hdr_2_dict['packet_len'] = group['packet_len']
                ipv4_hdr_2_dict['ttl'] = group['ttl']
                ipv4_hdr_2_dict['protocol'] = group['protocol']
                continue

            # udp   hdr : dest port: 9995, src port: 53926
            m = p11.match(line)
            if m:
                group = m.groupdict()
                udp_hdr_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault('udp_hdr',{})
                udp_hdr_dict['dest_port'] = group['dest_port']
                udp_hdr_dict['src_port'] = group['src_port']
                continue

            # Doppler Frame Descriptor :
            m = p12.match(line)
            if m:
                group = m.groupdict()
                doppler_frame_des_dict = ret_dict['inject_packet_number'][inject_packet_num].setdefault(
                    'doppler_frame_descriptor',{})
                continue

            # fdFormat                  = 0x3            systemTtl                 = 0x8
            m = p13.match(line)
            if m:
                group = m.groupdict()
                doppler_frame_des_dict['fdformat'] = group['fdformat']
                doppler_frame_des_dict['system_ttl'] = group['system_ttl']
                continue

            # fdType                    = 0x1            spanSessionMap            = 0
            m = p14.match(line)
            if m:
                group = m.groupdict()
                doppler_frame_des_dict['fdtype'] = group['fdtype']
                doppler_frame_des_dict['span_session_map'] = group['span_session_map']
                continue

            # qosLabel                  = 0x81           fpeFirstHeaderType        = 0
            m = p15.match(line)
            if m:
                group = m.groupdict()
                doppler_frame_des_dict['qoslabel'] = group['qoslabel']
                doppler_frame_des_dict['fpe_first_header_type'] = group['fpe_first_header_type']
                continue

        return ret_dict

 # ===============================================================================
# Schema for 'show platform software dpidb index'
# ===============================================================================
class ShowPlatformSoftwareDpidIndexSchema(MetaParser):
    """Schema for :
        show platform software dpidb index"""

    schema = {
        Any(): {
            'index' : int,
        },
    }

# ===============================================================================
# Parser for 'show platform software dpidb index'
# ===============================================================================
class ShowPlatformSoftwareDpidIndex(ShowPlatformSoftwareDpidIndexSchema):
    """parser for :
        show platform software dpidb index"""

    cli_command = 'show platform software dpidb index'

    def cli(self, output=None,):

        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        result_dict = {}
        #Index 1030 -- swidb Hu1/0/1
        p1 = re.compile(r'^Index\s+(?P<index>\d+)\s+--\s+swidb\s+(?P<interface>\S+)$')

        for line in out.splitlines():
            line = line.strip()
            #Index 1030 -- swidb Hu1/0/1
            m = p1.match(line)
            if m:
                group = m.groupdict()
                interface = group.pop('interface')
                interface_dict = result_dict.setdefault(interface,{})
                interface_dict.update({
                    'index' : int(group['index']),
                })
                continue

        return result_dict

# ==================================================================================
# Parser for 'show platform hardware qfp active feature sdwan datapath fec global" #
# ==================================================================================
class ShowPlatformHardwareQfpActiveFeatureSdwanDpFecGlobalSchema(MetaParser):
    schema = {
        Any(): { # FEC Global Info
            "ses_chunk_head": int,
            "pak_chunk_head": int,
            "ses_add": int,
            "ses_del": int,
            "ses_alloc_fail": int,
            "ses_mem_req": int,
            "ses_mem_req_resp": int,
            "ses_mem_ret": int,
            "pkt_alloc": int,
            "pkt_free": int,
            "pkt_alloc_fail": int,
            "pak_mem_req": int,
            "pak_mem_req_resp": int,
            "pak_mem_ret": int,
            "win_seq_err": int,
            "mem_to_pkt_err": int,
            "fec_encap_err": int,
            "fec_decap_err": int,
            "fec_compute_err": int,
            "reconstruct_miss": int,
            "fec_recycle_err": int,
            "data_recycle_err": int
        }
    }

class ShowPlatformHardwareQfpActiveFeatureSdwanDpFecGlobal(ShowPlatformHardwareQfpActiveFeatureSdwanDpFecGlobalSchema):

    cli_command = 'show platform hardware qfp active feature sdwan datapath fec global'
    def cli(self, output=None):

        # if the user does not provide output to the parser
        # we need to get it from the device
        if output is None:
            output = self.device.execute(self.cli_command)

        # FEC Global Info
        p1 = re.compile(r'^(?P<key>[A-Za-z\s]+)$')

        # "ses_chunk_head": int
        # "pak_chunk_head": int
        p2 = re.compile(r'^(?P<key>[a-z\_]+)\s+:\s+(?P<value>[\d\D]+)')

        ret_dict = {}
        for line in output.splitlines():
            line = line.strip()
            # FEC Global Info
            m = p1.match(line)
            if m:
                groups = m.groupdict()
                key = groups['key'].replace('-', '_').replace(' ', '_').replace(':', '').lower()
                fec_dict = ret_dict.setdefault(key, {})
                continue
            m = p2.match(line)
            if m:
                groups = m.groupdict()
                key = groups['key']
                value = int(groups['value'],16)
                fec_dict.update({key:value})
                continue

        return ret_dict

# ===========================================================================================
# Parser for 'show platform hardware qfp active feature sdwan datapath fec session summary' #
# ===========================================================================================
class ShowPlatformHardwareQfpActiveFeatureSdwanDpFecSessionSummarySchema(MetaParser):
    schema = {
        'tunnel': {
            str: {
                'flags' : str,
                'tx_data' : int,
                'tx_parity' : int,
                'rx_data' : int,
                'rx_parity' : int,
                'reconstruct' : int,
                Optional('tx_rx_wins') : {
                    str : {
                        'win_flags' : str,
                        'count' : int,
                        'isn' : int,
                        'tos' : int,
                        'parity_len' : int,
                        'fec_len' : int,
                        'fec_data' : str
                    }
                }
            }
        }
    }

class ShowPlatformHardwareQfpActiveFeatureSdwanDpFecSessionSummary(ShowPlatformHardwareQfpActiveFeatureSdwanDpFecSessionSummarySchema):

    cli_command = 'show platform hardware qfp active feature sdwan datapath fec session summary'
    def cli(self, output=None):
        # if the user does not provide output to the parser
        # we need to get it from the device
        if output is None:
            output = self.device.execute(self.cli_command)

        # 12345     0x123    100        2       200         3          1
        p1 = re.compile(r'^(?P<index>[\S]+)\s+(?P<flags>[\S]+)\s+(?P<tx_data>[\d]+)\s+(?P<tx_parity>[\d]+)\s+(?P<rx_data>[\d]+)\s+(?P<rx_parity>[\d]+)\s+(?P<reconstruct>[\d]+)$')

        # 0     0X2     1     219329664 0     92        56        0xC85EAD30
        p2 = re.compile(r'^(?P<win_num>[\d]+)\s+(?P<win_flags>[\S]+)\s+(?P<count>[\d]+)\s+(?P<isn>[\d]+)\s+(?P<tos>[\d]+)\s+(?P<parity_len>[\d]+)\s+(?P<fec_len>[\d]+)\s+(?P<fec_data>[\S]+)$')

        ret_dict = {}
        for line in output.splitlines():
            line = line.strip()
            # 12345     0x123    100        2       200         3          1
            m = p1.match(line)
            if m:
                groups = m.groupdict()
                index_dict = ret_dict.setdefault("tunnel", {}).setdefault(groups["index"],{})
                del groups["index"]
                for key in groups.keys():
                    value = groups[key]
                    # Check is Mandatory as i am iterations through different key/values pairs
                    # of different types.
                    if groups[key].isnumeric():
                        value = int(groups[key])
                    index_dict.update({key:value})
                continue
            # 0     0X2     1     219329664 0     92        56        0xC85EAD30
            m = p2.match(line)
            if m:
                groups = m.groupdict()
                wins_dict = index_dict.setdefault("tx_rx_wins",{})
                win_num_dict = wins_dict.setdefault(groups["win_num"],{})
                del groups["win_num"]
                for key in groups.keys():
                    value = groups[key]
                    # Check is Mandatory as i am iterations through different key/values pairs
                    # of different types.
                    if groups[key].isnumeric():
                        value = int(groups[key])
                    win_num_dict.update({key:value})
                continue

        return ret_dict

# =============================================================================
#  Schema for
#  * 'show platform software fed switch active ifm mappings lpn'
#  * 'show platform software fed switch active ifm mappings lpn | {interface}'
# ==============================================================================
class ShowPlatformSoftwareFedSwitchActiveIfmMappingsLpnSchema(MetaParser):
    """Schema for 'show platform software fed switch active ifm mappings lpn'
    """
    schema = {
        'interfaces':{
            Any(): {
                'lpn': int,
                'asic': int,
                'port': int,
                'if_id': str,
                'active': str
            }
        },
    }

# ===============================================================================
#  Parser for
#  * 'show platform software fed switch active ifm mappings lpn'
#  * 'show platform software fed switch active ifm mappings lpn | i {interface}'
# ================================================================================
class ShowPlatformSoftwareFedSwitchActiveIfmMappingsLpn(ShowPlatformSoftwareFedSwitchActiveIfmMappingsLpnSchema):
    """
    Parser for :
        * show platform software fed switch active ifm mappings lpn
    """

    cli_command = ['show platform software fed switch active ifm mappings lpn',
                   'show platform software fed switch active ifm mappings lpn | include {interface}']

    def cli(self, interface="", output=None):
        if output is None:
            if interface:
                cmd = self.cli_command[1].format(interface=interface)
            else:
                cmd = self.cli_command[0]
            output = self.device.execute(cmd)

        #19   1     18    TenGigabitEthernet1/0/19   0x0000001b  y
        p = re.compile(r'^(?P<lpn>\d+)\s+(?P<asic>\d+)\s+(?P<port>\d+)\s+(?P<interfaces>\S+)\s+(?P<if_id>(0x([\da-fA-F]){8}))\s+(?P<active>\S+)$')

        # initial return dictionary
        ret_dict ={}

        for line in output.splitlines():
            line = line.strip()

            #19    1  18    TenGigabitEthernet1/0/19   0x0000001b  y
            m = p.match(line)
            if m:

                group = m.groupdict()
                interfaces = group['interfaces']
                sub_dict = ret_dict.setdefault('interfaces', {}).setdefault(interfaces, {})

                lpn = group['lpn']
                sub_dict['lpn'] = int(lpn)

                asic = group['asic']
                sub_dict['asic'] = int(asic)

                port = group['port']
                sub_dict['port'] = int(port)

                if_id = group['if_id']
                sub_dict['if_id'] = if_id

                active = group['active']
                sub_dict['active'] = active
                continue
        return ret_dict


# =================================================================
#  Schema for 'show platform software fed switch {switch} ptp domain
# ================================================================
class ShowPlatformSoftwareFedSwitchActivePtpDomainSchema(MetaParser):
    """Schema for 'show platform software fed switch active ptp domain
    """
    schema = {
        'domain_number': {
            Any(): {
                'profile_type': str,
                'profile_state': str,
                Optional('clock_mode'): str,
                Optional('delay_mechanism'): str,
                Optional('ptp_clock'): str,
                Optional('mean_path_delay_ns'): int,
                'transport_method': str,
                'message_general_ip_dscp': int,
                'message_event_ip_dscp': int,
                Optional('clocksource'): int,
                Optional('gm_capable'): str,
                Optional('grandmaster'): str,
                Optional('gm_present'): str,
                Optional('propagation_delay'): str
            }
        },
    }


# =================================================================
#  Parser for 'show platform software fed switch {switch} ptp domain
# ================================================================
class ShowPlatformSoftwareFedSwitchActivePtpDomain(ShowPlatformSoftwareFedSwitchActivePtpDomainSchema):
    """
    Parser for :
        * show platform software fed switch {switch} ptp domain
        * show platform software fed active ptp domain
    """

    cli_command = ['show platform software fed active ptp domain', 
        'show platform software fed switch {switch} ptp domain']

    def cli(self, switch=None, output=None):

        if output is None:
            if switch:
                cmd = self.cli_command[1].format(switch=switch)
            else:
                cmd = self.cli_command[0]
            output = self.device.execute(cmd)

        #Displaying data for domain number 0
        p1 = re.compile(r'^Displaying\sdata\sfor\sdomain\snumber\s(?P<domain_number>\d+)$')

        #Profile Type : DEFAULT
        p2 = re.compile(r'^Profile\sType\s\:\s(?P<profile_type>\w+)$')

        #Profile State: enabled
        p3 = re.compile(r'^Profile\sState\:\s(?P<profile_state>\S+)$')

        #Clock Mode : BOUNDARY CLOCK
        p4 = re.compile(r'^Clock\sMode\s\:\s(?P<clock_mode>[A-Z\s]+)$')

        #Delay Mechanism: : END-TO-END
        p5 = re.compile(r'^Delay\sMechanism\:\s\:\s(?P<delay_mechanism>[A-Z\-]+)$')

        #PTP clock : 1970-1-24 22:41:20
        p6 = re.compile(r'^PTP\sclock\s\:\s(?P<ptp_clock>[\d\-\:\s]+)$')

        #mean_path_delay 83 nanoseconds
        p7 = re.compile(r'^mean_path_delay\s(?P<mean_path_delay_ns>\d+)\snanoseconds$')

        #Transport Method : 802.3
        p8 = re.compile(r'^Transport\sMethod\s\:\s(?P<transport_method>[\w\.\-]+)$')

        #Message general ip dscp  : 47
        p9 = re.compile(r'^Message\sgeneral\sip\sdscp\s+\:\s(?P<message_general_ip_dscp>\d+)$')

        #Message event ip dscp    : 59
        p10 = re.compile(r'^Message\sevent\sip\sdscp\s+\:\s(?P<message_event_ip_dscp>\d+)$')

        # clocksource 160
        p11 = re.compile(r'^clocksource\s+(?P<clocksource>\d+)$')

        # Grandmaster: FALSE
        p12 = re.compile(r'^Grandmaster:\s+(?P<grandmaster>\w+)$')

        # gm_capable: TRUE
        p13 = re.compile(r'^gm_capable:\s+(?P<gm_capable>\w+)$')

        # gm_present: TRUE
        p14 = re.compile(r'^gm_present:\s+(?P<gm_present>\w+)$')

        # neighbor propagation delay threshold: 800 ns
        p15 = re.compile(r'^neighbor propagation delay threshold:\s+(?P<propagation_delay>[\w\s]+)$')

        # initial return dictionary
        ret_dict ={}

        for line in output.splitlines():
            line = line.strip()

            #Displaying data for domain number 0
            m = p1.match(line)
            if m:
                ret_dict.setdefault('domain_number',{})
                domain_number = m.groupdict()['domain_number']
                sub_dict = ret_dict['domain_number'].setdefault(int(domain_number),{})
                continue

            #Profile Type : DEFAULT
            m = p2.match(line)
            if m:
                profile_type = m.groupdict()['profile_type']
                sub_dict['profile_type'] = profile_type
                continue

            #Profile State: enabled
            m = p3.match(line)
            if m:
                profile_state = m.groupdict()['profile_state']
                sub_dict['profile_state'] = profile_state
                continue

            #Clock Mode : BOUNDARY CLOCK
            m = p4.match(line)
            if m:
                clock_mode = m.groupdict()['clock_mode']
                sub_dict['clock_mode'] = clock_mode
                continue

            #Delay Mechanism: : END-TO-END
            m = p5.match(line)
            if m:
                delay_mechanism  = m.groupdict()['delay_mechanism']
                sub_dict['delay_mechanism'] = delay_mechanism
                continue

            #PTP clock : 1970-1-24 22:41:20
            m = p6.match(line)
            if m:
                ptp_clock = m.groupdict()['ptp_clock']
                sub_dict['ptp_clock'] = ptp_clock
                continue

            #mean_path_delay 83 nanoseconds
            m = p7.match(line)
            if m:
                mean_path_delay_ns = m.groupdict()['mean_path_delay_ns']
                sub_dict['mean_path_delay_ns'] = int(mean_path_delay_ns)
                continue

            #Transport Method : 802.3
            m = p8.match(line)
            if m:
                transport_method = m.groupdict()['transport_method']
                sub_dict['transport_method'] = transport_method
                continue

            #Message general ip dscp  : 47
            m = p9.match(line)
            if m:
                message_general_ip_dscp = m.groupdict()['message_general_ip_dscp']
                sub_dict['message_general_ip_dscp'] = int(message_general_ip_dscp)
                continue

            #Message event ip dscp    : 59
            m = p10.match(line)
            if m:
                message_event_ip_dscp = m.groupdict()['message_event_ip_dscp']
                sub_dict['message_event_ip_dscp'] = int(message_event_ip_dscp)
                continue

            # clocksource 160
            m = p11.match(line)
            if m:
                sub_dict['clocksource'] = int(m.groupdict()['clocksource'])
                continue

            # Grandmaster: FALSE
            m = p12.match(line)
            if m:
                sub_dict['grandmaster'] = m.groupdict()['grandmaster']
                continue

            # gm_capable: TRUE
            m = p13.match(line)
            if m:
                sub_dict['gm_capable'] = m.groupdict()['gm_capable']
                continue

            # gm_present: TRUE
            m = p14.match(line)
            if m:
                sub_dict['gm_present'] = m.groupdict()['gm_present']
                continue

            # neighbor propagation delay threshold: 800 ns
            m = p15.match(line)
            if m:
                sub_dict['propagation_delay'] = m.groupdict()['propagation_delay']
                continue
        
        return ret_dict

# ================================================================================
#  Schema for 'show platform software fed switch active ptp interface {interface}'
# ================================================================================
class ShowPlatformSoftwareFedSwitchActivePtpInterfaceInterfaceSchema(MetaParser):
    """Schema for 'show platform software fed switch active ptp interface {interface}'
    """

    schema = {
        'interface': {
            'ptp_info': {
                'version': int,
                Optional('ptp_vlan_is_valid'): str,
                Optional('ptp_vlan_id'): int,
            },
            'port_info': {
                'mac_address': str,
                'clock_identity': str,
                'number': int,
                Optional('mode'): int,
                'state': str,
                'port_enabled': str
            },
            'num_info': {
                'num_sync_messages_transmitted': int,
                'num_followup_messages_transmitted': int,
                'num_sync_messages_received': int,
                'num_followup_messages_received': int,
                Optional('num_delay_requests_transmitted'): int,
                Optional('num_delay_responses_received'): int,
                Optional('num_delay_requests_received'): int,
                Optional('num_delay_responses_transmitted'): int
            },
            'if_id': str,
            'domain_value': int,
            'profile_type': str,
            'clock_mode': str,
            'delay_mechanism': str,
            'ptt_port_enabled': str,
            'sync_seq_num': int,
            'delay_req_seq_num': int,
            Optional('log_mean_sync_interval'): int,
            Optional('log_mean_delay_interval'): int,
            Optional('tag_native_vlan'): str,
        }
    }

# =================================================================================
#  Parser for 'show platform software fed switch active ptp interface {interface}'
# =================================================================================
class ShowPlatformSoftwareFedSwitchActivePtpInterfaceInterface(ShowPlatformSoftwareFedSwitchActivePtpInterfaceInterfaceSchema):
    """
    Parser for :
        * show platform software fed switch active ptp interface {interface}
    """

    cli_command = 'show platform software fed switch active ptp interface {interface}'

    def cli(self, interface="", output=None):

        if output is None:
            output = self.device.execute(self.cli_command.format(interface=interface))

        #Displaying port data for if_id 2a
        #Displaying port data for if_id 29
        p1 = re.compile(r'^Displaying\sport\sdata\sfor\sif_id\s(?P<if_id>[0-9a-fA-F]+)$')

        #Port Mac Address 34:ED:1B:7D:F2:A1
        p2 = re.compile(r'^Port\sMac\sAddress\s(?P<mac_address>([\da-fA-F]:?).*)$')

        #Port Clock Identity 34:ED:1B:FF:FE:7D:F2:80
        p3 = re.compile(r'^Port\sClock\sIdentity\s(?P<clock_identity>([\da-fA-F]:?).*)$')

        #Port number 33
        p4 = re.compile(r'^Port\snumber\s(?P<number>\d+)$')

        #PTP Version 2
        p5 = re.compile(r'^PTP\sVersion\s(?P<version>\d+)$')

        #domain_value 0
        p6 = re.compile(r'^domain_value\s(?P<domain_value>\d+)$')

        #Profile Type: : DEFAULT
        p7 = re.compile(r'^Profile\sType\:\s\:\s(?P<profile_type>\S+)$')

        #Clock Mode : BOUNDARY CLOCK
        p8 = re.compile(r'^Clock\sMode\s\:\s(?P<clock_mode>.*)$')

        #Delay mechanism: End-to-End
        p9 = re.compile(r'^Delay\smechanism\:\s(?P<delay_mechanism>\S+)$')

        #port_enabled: TRUE
        p10 = re.compile(r'^port_enabled\:\s(?P<port_enabled>\S+)$')

        #ptt_port_enabled: TRUE
        p11 = re.compile(r'^ptt_port_enabled\:\s(?P<ptt_port_enabled>\S+)$')

        #Port state: : SLAVE
        p12 = re.compile(r'^Port\sstate\:\s\:\s(?P<state>\S+)$')

        #sync_seq_num 2189
        p13 = re.compile(r'^sync_seq_num\s(?P<sync_seq_num>\d+)$')

        #delay_req_seq_num 0
        p14 = re.compile(r'^delay_req_seq_num\s(?P<delay_req_seq_num>\d+)$')

        #log mean sync interval -3
        p15 = re.compile(r'^log\smean\ssync\sinterval\s(?P<log_mean_sync_interval>[-?\d]+)$')

        #log mean delay interval -5
        p16 = re.compile(r'^log\smean\sdelay\sinterval\s(?P<log_mean_delay_interval>[-?\d]+)$')

        #ptp vlan is valid : FALSE
        p17 = re.compile(r'^ptp\svlan\sis\svalid\s\:\s(?P<ptp_vlan_is_valid>\S+)$')

        #ptp vlan id 0
        p18 = re.compile(r'^ptp\svlan\sid\s(?P<ptp_vlan_id>\d+)$')

        #port mode 2
        p19 = re.compile(r'^port\smode\s(?P<mode>\d+)$')

        #tag native vlan : FALSE
        p20 = re.compile(r'^tag\snative\svlan\s\:\s(?P<tag_native_vlan>\S+)$')

        #num sync messages transmitted  0
        p21 = re.compile(r'^num\ssync\smessages\stransmitted\s+(?P<num_sync_messages_transmitted>\d+)$')

        #num followup messages transmitted  0
        p22 = re.compile(r'^num\sfollowup\smessages\stransmitted\s+(?P<num_followup_messages_transmitted>\d+)$')

        #num sync messages received  8758
        p23 = re.compile(r'^num\ssync\smessages\sreceived\s+(?P<num_sync_messages_received>\d+)$')

        #num followup messages received  8757
        p24 = re.compile(r'^num\sfollowup\smessages\sreceived\s+(?P<num_followup_messages_received>\d+)$')

        #num delay requests transmitted  8753
        p25 = re.compile(r'^num\sdelay\srequests\stransmitted\s+(?P<num_delay_requests_transmitted>\d+)$')

        #num delay responses received 8753
        p26 = re.compile(r'^num\sdelay\sresponses\sreceived\s+(?P<num_delay_responses_received>\d+)$')

        #num delay requests received  0
        p27 = re.compile(r'^num\sdelay\srequests\sreceived\s+(?P<num_delay_requests_received>\d+)$')

        #num delay responses transmitted  0
        p28 = re.compile(r'^num\sdelay\sresponses\stransmitted\s+(?P<num_delay_responses_transmitted>\d+)$')

        # initial return dictionary
        ret_dict ={}
        for line in output.splitlines():
            line = line.strip()

            #Displaying port data for if_id 2a
            #Displaying port data for if_id 29
            m = p1.match(line)
            if m:
                group = m.groupdict()
                sub_dict = ret_dict.setdefault('interface', {})
                sub_dict['if_id'] = group['if_id']
                ptp_info = sub_dict.setdefault('ptp_info',{})
                port_info = sub_dict.setdefault('port_info',{})
                continue

            #Port Mac Address 34:ED:1B:7D:F2:A1
            m = p2.match(line)
            if m:
                mac_address = m.groupdict()['mac_address']
                port_info['mac_address'] = mac_address
                continue

            #Port Clock Identity 34:ED:1B:FF:FE:7D:F2:80
            m = p3.match(line)
            if m:
                clock_identity = m.groupdict()['clock_identity']
                port_info['clock_identity'] = clock_identity
                continue

            #Port number 33
            m = p4.match(line)
            if m:
                number = m.groupdict()['number']
                port_info['number'] = int(number)
                continue

            #PTP Version 2
            m = p5.match(line)
            if m:
                version = m.groupdict()['version']
                ptp_info['version'] = int(version)
                continue

            #domain_value 0
            m = p6.match(line)
            if m:
                domain_value = m.groupdict()['domain_value']
                sub_dict['domain_value'] = int(domain_value)
                continue

            #Profile Type: : DEFAULT
            m = p7.match(line)
            if m:
                profile_type = m.groupdict()['profile_type']
                sub_dict['profile_type'] = profile_type
                continue

            #Clock Mode : BOUNDARY CLOCK
            m = p8.match(line)
            if m:
                clock_mode = m.groupdict()['clock_mode']
                sub_dict['clock_mode'] = clock_mode
                continue

            #Delay mechanism: End-to-End
            m = p9.match(line)
            if m:
                delay_mechanism = m.groupdict()['delay_mechanism']
                sub_dict['delay_mechanism'] = delay_mechanism
                continue

            #port_enabled: TRUE
            m = p10.match(line)
            if m:
                port_enabled = m.groupdict()['port_enabled']
                port_info['port_enabled'] = port_enabled
                continue

            #ptt_port_enabled: TRUE
            m = p11.match(line)
            if m:
                ptt_port_enabled = m.groupdict()['ptt_port_enabled']
                sub_dict['ptt_port_enabled'] =  ptt_port_enabled
                continue

            #Port state: : SLAVE
            m = p12.match(line)
            if m:
                state = m.groupdict()['state']
                port_info['state'] = state
                continue

            #sync_seq_num 36853
            m = p13.match(line)
            if m:
                sync_seq_num = m.groupdict()['sync_seq_num']
                sub_dict['sync_seq_num'] = int(sync_seq_num)
                continue

            #delay_req_seq_num 0
            m = p14.match(line)
            if m:
                delay_req_seq_num = m.groupdict()['delay_req_seq_num']
                sub_dict['delay_req_seq_num'] = int(delay_req_seq_num)
                continue

            #log mean sync interval -3
            m = p15.match(line)
            if m:
                log_mean_sync_interval = m.groupdict()['log_mean_sync_interval']
                sub_dict['log_mean_sync_interval'] = int(log_mean_sync_interval)
                continue

            #log mean delay interval -5
            m = p16.match(line)
            if m:
                log_mean_delay_interval = m.groupdict()['log_mean_delay_interval']
                sub_dict['log_mean_delay_interval'] = int(log_mean_delay_interval)
                continue

            #ptp vlan is valid : FALSE
            m = p17.match(line)
            if m:
                ptp_vlan_is_valid = m.groupdict()['ptp_vlan_is_valid']
                ptp_info['ptp_vlan_is_valid'] = ptp_vlan_is_valid
                continue

            #ptp vlan id 0
            m = p18.match(line)
            if m:
                ptp_vlan_id = m.groupdict()['ptp_vlan_id']
                ptp_info['ptp_vlan_id'] = int(ptp_vlan_id)
                continue

            #port mode 2
            m = p19.match(line)
            if m:
                mode = m.groupdict()['mode']
                port_info['mode'] = int(mode)
                continue

            #tag native vlan : FALSE
            m = p20.match(line)
            if m:
                tag_native_vlan = m.groupdict()['tag_native_vlan']
                sub_dict['tag_native_vlan'] = tag_native_vlan
                continue

            #num sync messages transmitted  17250
            m = p21.match(line)
            if m:
                num_sync_messages_transmitted = m.groupdict()['num_sync_messages_transmitted']
                num_info = sub_dict.setdefault('num_info',{})
                num_info['num_sync_messages_transmitted'] = int(num_sync_messages_transmitted)
                continue

            #num followup messages transmitted  17250
            m = p22.match(line)
            if m:
                num_followup_messages_transmitted = m.groupdict()['num_followup_messages_transmitted']
                num_info['num_followup_messages_transmitted'] = int(num_followup_messages_transmitted)
                continue

            #num sync messages received  75403
            m = p23.match(line)
            if m:
                num_sync_messages_received = m.groupdict()['num_sync_messages_received']
                num_info['num_sync_messages_received'] = int(num_sync_messages_received)
                continue

            #num followup messages received  75401
            m = p24.match(line)
            if m:
                num_followup_messages_received = m.groupdict()['num_followup_messages_received']
                num_info['num_followup_messages_received'] = int(num_followup_messages_received)
                continue

            #num delay requests transmitted  75941
            m = p25.match(line)
            if m:
                num_delay_requests_transmitted = m.groupdict()['num_delay_requests_transmitted']
                num_info['num_delay_requests_transmitted'] = int(num_delay_requests_transmitted)
                continue

            #num delay responses received 75343
            m = p26.match(line)
            if m:
                num_delay_responses_received = m.groupdict()['num_delay_responses_received']
                num_info['num_delay_responses_received'] = int(num_delay_responses_received)
                continue

            #num delay requests received  17278
            m = p27.match(line)
            if m:
                num_delay_requests_received = m.groupdict()['num_delay_requests_received']
                num_info['num_delay_requests_received'] = int(num_delay_requests_received)
                continue

            #num delay responses transmitted  17278
            m = p28.match(line)
            if m:
                num_delay_responses_transmitted = m.groupdict()['num_delay_responses_transmitted']
                num_info['num_delay_responses_transmitted'] = int(num_delay_responses_transmitted)
                continue
        return ret_dict


# =========================================================
#  Schema for
#  * 'show platform software fed active acl usage'
#  * 'show platform software fed active acl usage | include {acl_name}'
# =========================================================
class ShowPlatformSoftwareFedActiveAclUsageSchema(MetaParser):
    """Schema for 'show platform software fed active acl usage
    """
    schema = {
        Optional('acl_usage'): {
            Optional('ace_software'): {
                 Optional('vmr_max') : int,
                 Optional('used') : int,
             },
            'acl_name': {
                Any(): {
                    'direction': {
                        Any(): {
                            'feature_type': str,
                            'acl_type': str,
                            'entries_used': int,
                        },
                    },
                },
            },
        }
    }

# =========================================================
#  Parser for
#  * 'show platform software fed active acl usage'
#  * 'show platform software fed active acl usage | include {acl_name}'
# =========================================================
class ShowPlatformSoftwareFedActiveAclUsage(ShowPlatformSoftwareFedActiveAclUsageSchema):
    """
    Parser for :
        * show platform software fed active acl usage
        * show platform software fed active acl usage | include {acl_name}
    """

    cli_command = ['show platform software fed active acl usage',
                   'show platform software fed active acl usage | include {acl_name}']

    def cli(self, acl_name="", output=None):
        if output is None:
            if acl_name:
                cmd = self.cli_command[1].format(acl_name=acl_name)
            else:
                cmd = self.cli_command[0]
            output = self.device.execute(cmd)

        ######  ACE Software VMR max:196608 used:253
        p1 = re.compile(r'^\#\#\#\#\#\s+ACE\sSoftware\sVMR\smax\:(?P<vmr_max>\d+)\sused\:(?P<used>\d+)$')


        #   RACL        IPV4     Ingress   PBR-DMVPN    92
        p2 = re.compile(r'^(?P<feature_type>\S+)\s+(?P<acl_type>\S+)\s+(?P<direction>\S+)\s+(?P<name>\S+)\s+(?P<entries_used>\d+)$')

        # initial return dictionary
        ret_dict ={}

        for line in output.splitlines():
            line = line.strip()

            acl_usage = ret_dict.setdefault('acl_usage', {})

            ######  ACE Software VMR max:196608 used:253
            m = p1.match(line)
            if m:
                group = m.groupdict()
                acl_usage = ret_dict.setdefault('acl_usage', {})
                ace_software = acl_usage.setdefault('ace_software',{})

                vmr_max = group['vmr_max']
                ace_software['vmr_max'] = int(vmr_max)

                used = group['used']
                ace_software['used'] = int(used)
                continue

            #   RACL        IPV4     Ingress   PBR-DMVPN    92
            m = p2.match(line)
            if m:
                group = m.groupdict()
                acl_name = acl_usage.setdefault('acl_name', {}).\
                                 setdefault(Common.convert_intf_name(group['name']), {})
                direction = acl_name.setdefault('direction',{}).\
                                 setdefault(Common.convert_intf_name(group['direction']), {})

                direction['feature_type'] = group['feature_type']
                direction['acl_type'] = group['acl_type']
                direction['entries_used'] = int(group['entries_used'])
                continue
        return ret_dict

class ShowPlatformSoftwareFedQosPolicyTargetSchema(MetaParser):
    ''' search for
        * show platform software fed active qos policy target brief
    '''

    schema = {
        'tcg_sum_for_policy': {
            Any(): {
                'interface': {
                    Any(): {
                        'loc': str,
                        'iif_id': str,
                        'direction': str,
                        'tccg': int,
                        'child': int,
                        'mpq': str,
                        'state_cfg': str,
                        'state_opr': str,
                        'address': str
                    },
                }
            },
        }
    }

class ShowPlatformSoftwareFedQosPolicyTarget(ShowPlatformSoftwareFedQosPolicyTargetSchema):
    ''' parser for
            * show platform software fed active qos policy target brief
    '''

    cli_command = 'show platform software fed active qos policy target brief'

    def cli(self, output=None):
        if output is None:
            out = self.device.execute('show platform software fed active qos policy target brief')
        else:
            out = output

        ret_dict = {}

        # TCG summary for policy: system-cpp-policy
        p1 = re.compile(r'TCG\ssummary\sfor\spolicy:\s+(?P<policy>\S+)')
        # L:2 GigabitEthernet4/0/9  0x00000000000056  IN    4     0 3/2/0   VALID,SET_INHW  0x7fe0a79f0b88
        p2 = re.compile(
            r'(?P<loc>\S+)\s+(?P<interface>[\w\-\/\s]+)\s+(?P<iif_id>\S+)\s+(?P<direction>(OUT|IN))\s+(?P<tccg>\d+)\s+(?P<child>\d+)\s+(?P<mpq>[\w//]+)\s+(?P<state_cfg>\w+),(?P<state_opr>\S+)\s+(?P<address>\S+)')

        for line in out.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                if 'tcg_sum_for_policy' not in ret_dict:
                    sum_dict = ret_dict.setdefault('tcg_sum_for_policy', {})
                policy = str(group['policy'])
                sum_dict[policy] = {}
                sum_dict[policy]['interface'] = {}
                continue

            m = p2.match(line)
            if m:
                group = m.groupdict()
                interface = str(group['interface'])
                interface = interface.strip()
                sum_dict[policy]['interface'][interface] = {}
                sum_dict[policy]['interface'][interface]['loc'] = str(group['loc'])
                sum_dict[policy]['interface'][interface]['iif_id'] = str(group['iif_id'])
                sum_dict[policy]['interface'][interface]['direction'] = str(group['direction'])
                sum_dict[policy]['interface'][interface]['tccg'] = int(group['tccg'])
                sum_dict[policy]['interface'][interface]['child'] = int(group['child'])
                sum_dict[policy]['interface'][interface]['mpq'] = str(group['mpq'])
                sum_dict[policy]['interface'][interface]['state_cfg'] = str(group['state_cfg'])
                sum_dict[policy]['interface'][interface]['state_opr'] = str(group['state_opr'])
                sum_dict[policy]['interface'][interface]['address'] = str(group['address'])
                continue

        return ret_dict


class ShowPlatformSudiCertificateNonceSchema(MetaParser):
    """Schema for show platform sudi certificate sign nonce 123"""

    schema = {
        'certificates':{
            int: str,
        },
        Optional('signature'):str,
        Optional('signature_version'):int,
    }


class ShowPlatformSudiCertificateNonce(ShowPlatformSudiCertificateNonceSchema):
    """Parser for show platform  sudi  certificate sign nonce 123"""

    cli_command = ['show platform sudi certificate sign nonce {signature}','show platform sudi certificate']

    def cli(self,signature='', output=None):
        if output is None:
            # Build the command
            if signature:
                output = self.device.execute(self.cli_command[0].format(signature=signature))
            else:
                output = self.device.execute(self.cli_command[1])

        certificate_num=0
        certficate=""
        sig_check =False
        ret_dict = {}

        # -----BEGIN CERTIFICATE-----
        p1=re.compile('^\-+BEGIN CERTIFICATE\-+$')

        # -----END CERTIFICATE-----
        p2=re.compile('^\-+END CERTIFICATE\-+$')

        # Signature version: 1
        p3=re.compile('^Signature version:\s+(?P<signature>\d+)$')

        # Signature:
        p4=re.compile('^Signature:$')

        # A59DA741EA66C2AFC006E1766B3B11493A79E67408388C40160C2729F88281E9
        p5=re.compile('^(?P<signatur>[A-Z\d]+)$')

        # o4IBBDCCAQAwDgYDVR0PAQH/BAQDAgXgMAwGA1UdEwEB/wQCMAAwHwYDVR0jBBgw
        p6 =re.compile('([a-zA-Z0-9/+=]+)')

        for line in output.splitlines():
            line=line.strip()

            # -----BEGIN CERTIFICATE-----
            m=p1.match(line)
            if m:
                begin_certf=True
                certificate_num = certificate_num + 1
                continue

            # -----END CERTIFICATE-----
            m=p2.match(line)
            if m:
                root_dict=ret_dict.setdefault('certificates',{})
                #certificate_list.append(certficate)
                root_dict[certificate_num] = certficate
                certficate = ''
                continue

            # Signature version: 1
            m=p3.match(line)
            if m:
                group=m.groupdict()
                ret_dict.setdefault('signature_version',int(group['signature']))
                continue

            # Signature:
            m=p4.match(line)
            if m:
                sig_check=True
                continue

            # 7E873A87E287B685E823F7BC66CF13D43EC238D40DA7CBEA06F6926C04C8C5AFC21BA4C
            m=p5.match(line)
            if m and sig_check:
                group=m.groupdict()
                ret_dict.setdefault('signature', group['signatur'])
                continue

            # o4IBBDCCAQAwDgYDVR0PAQH/BAQDAgXgMAwGA1UdEwEB/wQCMAAwHwYDVR0jBBgw
            m=p6.match(line)
            if m:
                certficate = certficate + m.group()
                continue
        return ret_dict


class ShowEnvironmentStatusSchema(MetaParser):
    """
    Schema for show environment status
    """
    schema = {
        Optional('power_supply'): {
            Any(): {
                'model_num': str,
                'type': str,
                'capacity': str,
                'status': str,
                'fan_states' :{
                    int: str,
                },
            },
        },
        Optional('fan_tray'): {
            Any(): {
                'status': str,
                'fan_states' :{
                    int: str,
                },
            },
        },
        Optional('switch'): {
            Any(): {
                Optional('power_supply'): {
                    Any(): {
                        'model_num': str,
                        'type': str,
                        'capacity': str,
                        'status': str,
                        'fan_states' :{
                            int: str,
                        },
                    },
                },
                Optional('fan_tray'): {
                    Any(): {
                        'status': str,
                        'fan_states' :{
                            int: str,
                        },
                    },
                },
            },
        },
    }


class ShowEnvironmentStatus(ShowEnvironmentStatusSchema):
    """ Parser for show environment status"""

    cli_command = 'show environment status'

    def cli(self,output=None):
        if output is None:
            # excute command to get output
            output = self.device.execute(self.cli_command)

        # initial variables
        ret_dict  = switch_id_dict = {}

        # Switch:1
        p1 = re.compile(r'^Switch:(?P<switch>\S+)$')

        # PS1     C9K-PWR-1500WAC-R     ac    n.a.      standby    good  good
        # PS0     C9K-PWR-650WAC-R      AC    650 W     ok         good  N/A
        p2 = re.compile(r'^(?P<power_supply>\S+) +'
                        r'(?P<model_num>\S+) +'
                        r'(?P<type>\S+) +'
                        r'(?P<capacity>\S+) +W?\s*'
                        r'(?P<status>\S+) +'
                        r'(?P<fan_state0>\S+) +'
                        r'(?P<fan_state1>\S+)$')

        # FM6     active      good  good
        p3= re.compile('^(?P<fan_tray>\w+\d+)\s+(?P<status>\w+)\s+(?P<fan_state0>\w+)\s+(?P<fan_state1>\w+)$')

        # FM0     ok          good  good  good  good
        p4= re.compile(r'^(?P<fan_tray>\w+\d+) +'
                        r'(?P<status>\w+) +'
                        r'(?P<fan_state0>\S+) +'
                        r'(?P<fan_state1>\S+) +'
                        r'(?P<fan_state2>\S+) +'
                        r'(?P<fan_state3>\S+)$')

        for line in output.splitlines():
            line = line.strip()

            #Switch:1
            m = p1.match(line)
            if m:
                group = m.groupdict()
                switch = group['switch']
                switch_dict = ret_dict.setdefault('switch',{})
                switch_id_dict = switch_dict.setdefault(switch,{})
                continue

            # PS1     C9K-PWR-1500WAC-R     ac    n.a.      standby    good  good
            m=p2.match(line)
            if m:
                group= m.groupdict()
                root_dict=switch_id_dict.setdefault('power_supply',{}).setdefault(group['power_supply'],{})
                root_dict.setdefault('model_num',group['model_num'])
                root_dict.setdefault('type',group['type'])
                root_dict.setdefault('capacity',group['capacity'])
                root_dict.setdefault('status',group['status'])
                root_dict1=root_dict.setdefault('fan_states',{})
                root_dict1.setdefault(0,group['fan_state0'])
                root_dict1.setdefault(1,group['fan_state1'])
                continue

            # FM6     active      good  good
            m=p3.match(line)
            if m:
                group=m.groupdict()
                root_dict = switch_id_dict.setdefault('fan_tray', {}).setdefault(group['fan_tray'],{})
                root_dict.setdefault('status',group['status'])
                root_dict1=root_dict.setdefault('fan_states',{})
                root_dict1.setdefault(0,group['fan_state0'])
                root_dict1.setdefault(1,group['fan_state1'])
                continue

            # FM0     ok          good  good  good  good
            m=p4.match(line)
            if m:
                group=m.groupdict()
                root_dict = switch_id_dict.setdefault('fan_tray', {}).setdefault(group['fan_tray'],{})
                root_dict.setdefault('status',group['status'])
                root_dict1=root_dict.setdefault('fan_states',{})
                root_dict1.setdefault(0,group['fan_state0'])
                root_dict1.setdefault(1,group['fan_state1'])
                root_dict1.setdefault(2,group['fan_state2'])
                root_dict1.setdefault(3,group['fan_state3'])

        return ret_dict


class ShowPlatformSoftwareDbalR0DataAllSchema(MetaParser):
  schema = {
  'db_name': {
         Any():{
           'db_mode':str,
            'batches_waiting':int,
            'batches_in_progress':int,
             'batches_done': int,
             'tunnels_active': int,
             'tunnels_closed': int
           }
       }
   }

class ShowPlatformSoftwareDbalR0DataAll(ShowPlatformSoftwareDbalR0DataAllSchema):
    cli_command = 'show platform software dbal smd R0 database all'
    def cli(self, output=None):
        out = self.device.execute(self.cli_command) if output is None else output

        ret_dict = {}


#SMD_CONF                  Local                       0                     0                30                 0                 0

        pr = re.compile(r'^(?P<db_name>\S+) +'
                       r'(?P<db_mode>\S+) +'
                       r'(?P<batches_waiting>\d+) +'
                       r'(?P<batches_in_progress>\d+) +'
                       r'(?P<batches_done>\d+) +'
                       r'(?P<tunnels_active>\d+) +'
                       r'(?P<tunnels_closed>\d+)$')

        for line in out.splitlines():
          line = line.strip()

          m =  pr.match(line)
          if m:
             group = m.groupdict()

             dbnames_dict = ret_dict.setdefault('db_name', {})
             dbname_dict = dbnames_dict.setdefault(group['db_name'],{})

             dbname_dict.update({
              'db_mode': group['db_mode'],
              'batches_waiting' : int(group['batches_waiting']),
              'batches_in_progress' : int(group['batches_in_progress']),
              'batches_done' : int(group['batches_done']),
              'tunnels_active' : int(group['tunnels_active']),
              'tunnels_closed' : int(group['tunnels_closed'])
             })

             continue

        return ret_dict

class showPlatformMplsRlistIdSchema(MetaParser):
    """
    Schema for show environment status
    """
    schema = {
        'rlist_id': {
            Any(): {
                'state': int,
                'status': str,
                'flags': str,
                'remote_ifs': int,
                'packets' : int,
                'pps': int
            },
        },
    }

class ShowPlatformMplsRlistId(showPlatformMplsRlistIdSchema):
    """Parser for:
        show platform software fed switch <switch_type> mpls rlist | in RLIST id:
        """
    cli_command = 'show platform software fed switch {switch_type} mpls rlist | in RLIST id:'

    def cli(self, switch_type="", output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(switch_type=switch_type))

        ret_dict = {}

        ###RLIST id: 0xf0001aeb State: 1 {OK} Flags: 0x0 remote_ifs: 0 packets: 0 (0 pps approx.)
        p1=re.compile(r"^RLIST\s+id:\s+(?P<rlist_id>\S+)\s+State:\s+(?P<state>\d+)\s+\{(?P<status>\S+)\}\s+Flags:\s+(?P<flags>\S+)\s+[A-Z\{\} ]*\s*remote_ifs:\s+(?P<remote_ifs>\d+)\s+packets:\s+(?P<packets>\d+)\s+\((?P<pps>\d+).*$")

        for line in output.splitlines():
            line = line.strip()

            ##RLIST id: 0xf0001aeb State: 1 {OK} Flags: 0x0 remote_ifs: 0 packets: 0 (0 pps approx.)
            m1=p1.match(line)
            if m1:
                r=m1.groupdict()
                res=ret_dict.setdefault('rlist_id',{}).setdefault(r['rlist_id'],{})
                r.pop('rlist_id')
                for key,value in r.items():
                    res[key]=int(value) if value.isdigit() else value
        return ret_dict

class ShowPlatformHardwareFedSwitchActiveFwdAsicDropsExceptionsSchema(MetaParser):
    """Schema for show platform hardware fed switch active fwd-asic drops exceptions in svl"""
    schema = {
        'asic': {
            Any(): {
                'name': {
                    Any(): {
                            'prev': int,
                            'current': int,
                            'delta': int,
                            }
                        }
                    }
                }
            }


class ShowPlatformHardwareFedSwitchActiveFwdAsicDropsExceptions(ShowPlatformHardwareFedSwitchActiveFwdAsicDropsExceptionsSchema):
    """Parser for show platform hardware fed switch active fwd-asic drops exceptions in svl """

    cli_command = 'show platform hardware fed switch active fwd-asic drops exceptions'

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        #****EXCEPTION STATS ASIC INSTANCE 0 (asic/core 0/0)****
        p1=re.compile(r'^\*{4}EXCEPTION +STATS +ASIC +INSTANCE +(?P<asic>\d) +\(asic/core \d\/\d\)\*{4}$')

        #0  0  NO_EXCEPTION                                   354740102   354740637    535
        p2=re.compile(r'^\d +\d +(?P<name>\w+) +(?P<prev>\d+) +(?P<current>\d+) +(?P<delta>\d+)$')

        for line in out.splitlines():
            line = line.strip()

            #****EXCEPTION STATS ASIC INSTANCE 0 (asic/core 0/0)****
            m = p1.match(line)
            if m:
                group = m.groupdict()
                asic_dict = ret_dict.setdefault('asic', {}).setdefault(group['asic'], {})
                continue
            #0  0  NO_EXCEPTION                                   354740102   354740637    535
            m = p2.match(line)
            if m:
                group = m.groupdict()
                dir_dict = asic_dict.setdefault('name', {}). \
                        setdefault(group['name'], {})
                group.pop('name')
                dir_dict.update({k: int(v) for k, v in group.items()})
                continue
        return ret_dict


class ShowPlatformMplsRlistSummarySchema(MetaParser):
    """
    Schema for show platform software fed switch <switch_type> mpls rlist summary
    """
    schema = {
        'mpls_rlist_summary': {
            'current_count': {
                'rlist': int,
                'rentry': int
            },
            'maximum_reached': {
                'rlist': int,
                'rentry': int
            },
            'total_retry_count': {
                'rlist': int,
                'rentry': int
            },
            'current_lspvif_adj_count': int,
            'max_lspvif_adj': int,
            'current_lspvif_adj_label_count': int,
            'max_lspvif_adj_label_info': int,
            'total_lspvif_adj_label_count' : int,
        },
    }

class ShowPlatformMplsRlistSummary(ShowPlatformMplsRlistSummarySchema):
    """Parser for:
        show platform software fed switch <switch_type> mpls rlist
        """
    cli_command = 'show platform software fed switch {switch_type} mpls rlist summary'

    def cli(self, switch_type, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(switch_type=switch_type))

        # Current Count (RLIST/RENTRY) : 4 / 2
        p1=re.compile(r"Current\s+Count\s+\(RLIST\/RENTRY\)\s+\:\s+(?P<rlist>\d+)\s+\/\s+(?P<rentry>\d+)")

        # Maximum Reached (RLIST/RENTRY) : 24 / 48
        p2=re.compile(r"Maximum\s+Reached\s+\(RLIST\/RENTRY\)\s+\:\s+(?P<rlist>\d+)\s+\/\s+(?P<rentry>\d+)")

        # Total Retry Count (RLIST/RENTRY) : 0 / 0
        p3=re.compile(r"Total\s+Retry\s+Count\s+\(RLIST\/RENTRY\)\s+\:\s+(?P<rlist>\d+)\s+\/\s+(?P<rentry>\d+)")

        # Current Lspvif Adjacency's Count : 5
        p4=re.compile(r"Current\s+Lspvif\s+Adjacency's\s+Count\s+\:\s+(?P<current_lspvif_adj_count>\d+)")

        # Max reached Lspvif Adjacency's : 40
        p5=re.compile(r"Max\s+reached\s+Lspvif\s+Adjacency's\s+\:\s+(?P<max_lspvif_adj>\d+)")

        # Current Lspvif Adj label info Count : 1
        p6=re.compile(r"Current\s+Lspvif\s+Adj\s+label\s+info\s+Count\s+\:\s+(?P<current_lspvif_adj_label_count>\d+)")

        # Max reached Lspvif Adj label info : 11
        p7=re.compile(r"Max\s+reached\s+Lspvif\s+Adj\s+label\s+info\s+\:\s+(?P<max_lspvif_adj_label_info>\d+)")

        # Total Retry Lspvif Adj label info Count : 0
        p8=re.compile(r"Total\s+Retry\s+Lspvif\s+Adj\s+label\s+info\s+Count\s+\:\s+(?P<total_lspvif_adj_label_count>\d+)")

        mpls_rlist_summary=dict()
        for line in output.splitlines():
            line=line.strip()

            # Current Count (RLIST/RENTRY) : 4 / 2
            m = p1.match(line)
            if m:
                mpls_rlist_summary_dict=mpls_rlist_summary.setdefault('mpls_rlist_summary',{})
                current_count_dict=mpls_rlist_summary_dict.setdefault('current_count',{})
                for item, value in m.groupdict().items():
                    current_count_dict.update({item:int(value)})

            # Maximum Reached (RLIST/RENTRY) : 24 / 48
            m = p2.match(line)
            if m:
                max_reached_dict=mpls_rlist_summary_dict.setdefault('maximum_reached',{})
                for item, value in m.groupdict().items():
                    max_reached_dict.update({item:int(value)})

            # Total Retry Count (RLIST/RENTRY) : 0 / 0
            m = p3.match(line)
            if m:
                total_retry_count_dict=mpls_rlist_summary_dict.setdefault('total_retry_count',{})
                for item, value in m.groupdict().items():
                    total_retry_count_dict.update({item:int(value)})

            # Current Lspvif Adjacency's Count : 5
            m = p4.match(line)
            if m:
                mpls_rlist_summary_dict.update({
                    'current_lspvif_adj_count':int(m.groupdict()['current_lspvif_adj_count'])})

            # Max reached Lspvif Adjacency's : 40
            m = p5.match(line)
            if m:
                mpls_rlist_summary_dict.update({
                    'max_lspvif_adj':int(m.groupdict()['max_lspvif_adj'])})

            # Current Lspvif Adj label info Count : 1
            m = p6.match(line)
            if m:
                mpls_rlist_summary_dict.update({
                    'current_lspvif_adj_label_count':int(m.groupdict()['current_lspvif_adj_label_count'])})

            # Max reached Lspvif Adj label info : 11
            m = p7.match(line)
            if m:
                mpls_rlist_summary_dict.update({
                    'max_lspvif_adj_label_info':int(m.groupdict()['max_lspvif_adj_label_info'])})

            # Total Retry Lspvif Adj label info Count : 0
            m = p8.match(line)
            if m:
                mpls_rlist_summary_dict.update({
                    'total_lspvif_adj_label_count':int(m.groupdict()['total_lspvif_adj_label_count'])})

        return mpls_rlist_summary


class ShowPlatformSoftwareInterfaceSwitchF0BriefSchema(MetaParser):
    """
    Schema for show platform software interface switch {mode} F0 brief
    """
    schema = {
        'forwarding_manager_interface_information': {
            Any():{
                'id': int,
                'qfp_id': int,
            },
        }
    }


class ShowPlatformSoftwareInterfaceSwitchF0Brief(ShowPlatformSoftwareInterfaceSwitchF0BriefSchema):
    """ Parser for show platform software interface switch {mode} F0 brief"""

    cli_command = 'show platform software interface switch {mode} F0 brief'

    def cli(self, mode, output=None):
        if output is None:
            # excute command to get output
            output = self.device.execute(self.cli_command.format(mode=mode))

        # initial variables
        ret_dict = {}
        # HundredGigE2/0/35/4                1285              1285
        p1=re.compile('^(?P<name>\S+)\s+(?P<id>\d+)\s+(?P<qfp_id>\d+)$')

        for line in output.splitlines():
            line = line.strip()

            # HundredGigE2/0/35/4                1285              1285
            m=p1.match(line)
            if m:
                group=m.groupdict()
                root_dict = ret_dict\
                    .setdefault('forwarding_manager_interface_information',{})\
                    .setdefault(group['name'],{})
                root_dict['id']=int(group['id'])
                root_dict['qfp_id']=int(group['qfp_id'])
                continue

        return ret_dict


class ShowPlatformSoftwareFedSwitchPortSummarySchema(MetaParser):
    """
    Schema for show platform software fed switch {mode} port summary
    """
    schema = {
        'interface': {
            Any(): {
                'if_id': int,
                'port_enable': str,
            }
        }
    }


class ShowPlatformSoftwareFedSwitchPortSummary(ShowPlatformSoftwareFedSwitchPortSummarySchema):
    """ Parser for show platform software fed switch {mode} port summary"""

    cli_command = 'show platform software fed switch {mode} port summary'

    def cli(self, mode, output=None):
        if output is None:
            # excute command to get output
            output = self.device.execute(self.cli_command.format(mode=mode))

        # initial variables
        ret_dict = {}

        # 1266           HundredGigE2/0/27/1             true
        p1 = re.compile('^(?P<if_id>\d+)\s+(?P<if_name>\S+)\s+(?P<port_enable>\w+)$')

        for line in output.splitlines():
            line = line.strip()

            # 1266           HundredGigE2/0/27/1             true
            m=p1.match(line)
            if m:
                group = m.groupdict()
                root_dict = ret_dict.setdefault('interface',{}).setdefault(group['if_name'],{})
                root_dict['if_id'] = int(group['if_id'])
                root_dict['port_enable'] = group['port_enable']
                continue
        return ret_dict

# ==================================================
# Parser for 'show platform software fed mode count'
# ==================================================
class ShowPlatformSoftwareFedLspaAllPermodeSchema(MetaParser):

    ''' Schema for "show Platform software fed mode count" '''

    schema = {
        'lspa_mode_count':int
        }

# ==================================================
# Parser for 'show platform software fed mode count'
# ==================================================
class ShowPlatformSoftwareFedLspaAllPermode(ShowPlatformSoftwareFedLspaAllPermodeSchema):
    ''' Parser for
      "show platform software fed {switchvirtualstate} mpls lspa all | c {mode}"
    '''

    cli_command = ['show platform software fed {switchvirtualstate} mpls lspa all | c {mode}']

    def cli(self, switchvirtualstate="", mode="", output=None):
        if output is None:
            cmd = self.cli_command[0].format(switchvirtualstate=switchvirtualstate,mode=mode)
            output = self.device.execute(cmd)

        # Init vars
        ret_dict = {}

        #Number of lines which match regexp = 0
        p1 = re.compile(r'^Number +of +lines +which +match +regexp+\s+\W+\s+(?P<lspa_mode_count>(\d+))$')

        for line in output.splitlines():
            line = line.strip()

            #Number of lines which match regexp = 0
            m = p1.match(line)
            if m:
                lspa_mode_count=int(m.groupdict()['lspa_mode_count'])
                ret_dict['lspa_mode_count']= lspa_mode_count
                continue
        return ret_dict

# ======================================================================================
# Schema for :
#   * 'show platform software fed {switch} active mpls ipv4 vrf-name {vn_name} {ip_add}'
#   * 'show platform software fed active mpls ipv4 vrf-name {vn_name} {ip_add}'
# ======================================================================================
class ShowPlatformSofwareFedActiveMplsIpv4VrfNameIpAddSchema(MetaParser):

    ''' Schema for :
        * 'show platform software fed {switch} active mpls ipv4 vrf-name {vn_name} {ip_add}'
        * 'show platform software fed active mpls ipv4 vrf-name {vn_name} {ip_add}'
    '''

    schema = {
        'ipv4_add': {
            Any(): {
                'ipv4route_id': str,
                'obj_name': str,
                'obj_id': int,
                'tblid': int,
                'da': int,
                Optional('child'): {
                    Optional('child_adj'): {
                        Optional('objid'): int,
                        Optional('nh_type'): str,
                        Optional('iif_id'): str,
                        Optional('ether_type'): str,
                        Optional('srcmac'): str,
                        Optional('dstmac'): str,
                    },
                    Optional('child_npd'): {
                        Optional('child_device'): int,
                        Optional('nh_gid'): int,
                        Optional('nh_oid'): int,
                        Optional('old_gid'): int,
                        Optional('old_oid'): int,
                        Optional('parent_oid'): int,
                        Optional('child_fec_oid'): int,
                        Optional('was_nor_nh'): int,
                        Optional('cr_def'): int,
                        Optional('stale'): int,
                        Optional('l3port_valid'): int,
                    },
                    Optional('child_sdk'): {
                        Optional('cla_nhtype'): int,
                    }
                },
                Optional('sdk_fec_dest'): {
                    Optional('sdk_oid'): int,
                    Optional('sdk_dev'): int,
                    Optional('dest_type'): str,
                },
                Optional('npd'): {
                    Optional('device'): int,
                    Optional('lspa_rec'): int,
                    Optional('api_type'): str,
                    Optional('sdk_oid'): int,
                    Optional('devid'): int,
                    Optional('asic'): int,
                },
                Optional('sdk'): {
                    Optional('is_host'): int,
                    Optional('l3_dest_id'): str,
                    Optional('l3_dest_name'): str,
                    Optional('vrf_gid'): int,
                    Optional('vrf_oid'): int,
                },
                Optional('object_type'): str,
                Optional('sdk_nexthop'): {
                    Optional('oid'): int,
                    Optional('dev'): int,
                    Optional('gid'): str,
                    Optional('macaddr'): str,
                    Optional('nh_type'): str,
                },
                Optional('sdk_outgoing_port'): {
                    Optional('out_oid'): int,
                    Optional('porttype'): str,
                },
                Optional('forus_destination'): {
                    Any(): {
                        Optional('forus_obj_id'): int,
                    }
                },
                Optional('subnet_present_l3port_oid'): int,
                Optional(Any()): {
                    Optional('ipnexthop_obj_id'): int,
                },
            }
        }
    }            

# ======================================================================================
# Parser for:
#   * 'show platform software fed {switch} active mpls ipv4 vrf-name {vn_name} {ip_add}'
#   * 'show platform software fed active mpls ipv4 vrf-name {vn_name} {ip_add}'
# ======================================================================================
class ShowPlatformSofwareFedActiveMplsIpv4VrfNameIpAdd(ShowPlatformSofwareFedActiveMplsIpv4VrfNameIpAddSchema):
    ''' Parser for
        * 'show platform software fed {switch} active mpls ipv4 vrf-name {vn_name} {ip_add}'
        * 'show platform software fed active mpls ipv4 vrf-name {vn_name} {ip_add}'
    '''
    cli_command = ['show platform software fed {switch} active mpls ipv4 vrf-name {vn_name} {ip_address}', 
                    'show platform software fed active mpls ipv4 vrf-name {vn_name} {ip_address}']

    def cli(self,switch='',vn_name='',ip_address='',output=None):

        if output is None:
            if vn_name and ip_address:
                if switch:
                    output = self.device.execute(self.cli_command[0].format(switch=switch,vn_name=vn_name,ip_address=ip_address))
                else:
                    output = self.device.execute(self.cli_command[1].format(vn_name=vn_name,ip_address=ip_address))

        # Init vars
        ret_dict = {}
        ipv4_add_dict = {}

        # IPV4ROUTE_ID:id:0x5b36201d0608 nobj:(PUSH_COUNTER,418) 20.1.1.123/32 tblid:2 DA:0
        p1 = re.compile(r'^IPV4ROUTE_ID:id:(?P<ipv4route_id>\w+)(?:\s+)nobj:\((?P<obj_name>\w+)(?:,)'
                        r'(?P<obj_id>\d+)\)(?:\s+)(?P<ipv4_add>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2})'
                        r'(?:\s+)tblid:(?P<tblid>\d+)(?:\s+)DA:(?P<da>\d+)$')

        # NPD: device:0 lspa_rec:0 api_type:route(3)
        p2 = re.compile(r'^NPD:\s+device:(?P<device>\d+)(?:\s+)lspa_rec:(?P<lspa_rec>\d+)(?:\s+)api_type:(?P<api_type>\S+)$')

        # NPD: SDK oid 534, devid:0, asic:0
        p3 = re.compile(r'^NPD:\sSDK\soid\s(?P<sdk_oid>\d+)(?:,\s+)devid:(?P<devid>\d+)(?:,\s+)asic:(?P<asic>\d+)$')

        # SDK: is_host:0 l3_dest:0x62faa7b0fca0 l3_dest:la_vxlan_next_hop_base(oid=2113) vrf(gid/oid):2/697
        p4 = re.compile(r'^SDK:(?:\s+)is_host:(?P<is_host>\d+)(?:\s+)'
                        r'l3_dest:(?P<l3_dest_id>\w+)(?:\s+)'
                        r'l3_dest:(?P<l3_dest_name>\S+)(?:\s+)'
                        r'vrf\(gid\/oid\):(?P<vrf_gid>\d+)\/(?P<vrf_oid>\d+)$')

        # object type: vxlan_next_hop
        p5 = re.compile(r'^object type:\s+(?P<object_type>\w+)$')

        # sdk nexthop oid:1449,dev:0, gid:0xa,macaddr:a0f8.4910.ab57, nh_type:normal(0)
        p6 = re.compile(r'^sdk nexthop oid:(?P<oid>\d+),dev:(?P<dev>\d+),\s+gid:(?P<gid>\w+)'
                        r',macaddr:(?P<macaddr>([a-fA-F\d]{4}\.){2}[a-fA-F\d]{4}),\s+nh_type:(?P<nh_type>\S+)$')

        # sdk outgoing port oid 2143, porttype:svi(104)
        p7 = re.compile(r'^sdk outgoing port oid\s+(?P<out_oid>\d+),\s+porttype:(?P<porttype>\S+)$')

        # forus_destination  SPECIAL_IPNEXTHOP_ID:obj_id:0
        p8 = re.compile(r'^forus_destination\s+(?P<forus_name>\w+):obj_id:(?P<forus_obj_id>\d+)$')

        # Subnet Present in SDK for L3Port OID:2143
        p9 = re.compile(r'^Subnet Present in SDK for L3Port OID:(?P<subnet_present_l3port_oid>\d+)$')

        # SPECIAL_IPNEXTHOP_ID:obj_id:0
        p10 = re.compile(r'^(?P<ipnexthop_name>\w+):obj_id:(?P<ipnexthop_obj_id>\d+)$')

        # sdk fec destination oid:1449,dev:0, destination_type:4b
        p11 = re.compile(r'^sdk fec destination oid:(?P<sdk_oid>\d+),dev:(?P<sdk_dev>\d+),\s+destination_type:(?P<dest_type>\S+)$')

        # ADJ:objid:101 nh_type:NHADJ_NORMAL iif_id:0x553 ether_type:0x8 #child:2
        p12 = re.compile(r'^ADJ:objid:(?P<objid>\d+)\s+nh_type:(?P<nh_type>\w+)\s+'
                            r'iif_id:(?P<iif_id>\w+)\s+ether_type:(?P<ether_type>\w+)\s+#child:\d+$')

        # srcmac:f87a.4125.2f02 dstmac:a0f8.4910.ab57
        p13 = re.compile(r'^srcmac:(?P<srcmac>([a-fA-F\d]{4}\.){2}[a-fA-F\d]{4})\s+dstmac:(?P<dstmac>([a-fA-F\d]{4}\.){2}[a-fA-F\d]{4})$')

        # NPD: device:0 nh_gid/oid:10/1449 old_gid/oid:0/0 parent_oid:2143
        p14 = re.compile(r'^NPD:\s+device:(?P<child_device>\d+)\s+nh_gid\/oid:(?P<nh_gid>\d+)\/(?P<nh_oid>\d+)\s+'
                            r'old_gid\/oid:(?P<old_gid>\d+)\/(?P<old_oid>\d+)\s+parent_oid:(?P<parent_oid>\d+)$')

        # fec_oid:1454 was_nor_nh:1 cr_def:0 stale:0 l3port_valid:1
        p15 = re.compile(r'^fec_oid:(?P<child_fec_oid>\d+)\s+was_nor_nh:(?P<was_nor_nh>\d+)\s+cr_def:(?P<cr_def>\d+)'
                            r'\s+stale:(?P<stale>\d+)\s+l3port_valid:(?P<l3port_valid>\d+)$')

        # SDK: cla_nhtype:0
        p16 = re.compile(r'^SDK:\s+cla_nhtype:(?P<cla_nhtype>\d+)$')

        for line in output.splitlines():
            line = line.strip()
            
            # IPV4ROUTE_ID:id:0x5b36201d0608 nobj:(PUSH_COUNTER,418) 20.1.1.123/32 tblid:2 DA:0
            m = p1.match(line)
            if m:
                groups = m.groupdict()
                ipv4_add = m.groupdict()['ipv4_add']
                ipv4_add_dict = ret_dict.setdefault('ipv4_add', {}).setdefault(ipv4_add, {})
                ipv4_add_dict.update({                                                        
                            'ipv4route_id': str(groups['ipv4route_id']),
                            'obj_name': str(groups['obj_name']),
                            'obj_id': int(groups['obj_id']),
                            'tblid': int(groups['tblid']),
                            'da': int(groups['da']),
                        })
                continue

            # NPD: device:0 lspa_rec:0 api_type:route(3)
            m = p2.match(line)
            if m:
                groups = m.groupdict()
                npd_dict = ipv4_add_dict.setdefault('npd', {})
                npd_dict.update({                                                        
                            'device': int(groups['device']),
                            'lspa_rec': int(groups['lspa_rec']),
                            'api_type': str(groups['api_type']),
                        })
                continue

            # NPD: SDK oid 534, devid:0, asic:0
            m = p3.match(line)
            if m:
                groups = m.groupdict()
                npd_dict.update({                                                        
                            'sdk_oid': int(groups['sdk_oid']),
                            'devid': int(groups['devid']),
                            'asic': int(groups['asic']),
                        })
                continue

            # SDK: is_host:0 l3_dest:0x62faa7b0fca0 l3_dest:la_vxlan_next_hop_base(oid=2113) vrf(gid/oid):2/697
            m = p4.match(line)
            if m:
                groups = m.groupdict()
                sdk_dict = ipv4_add_dict.setdefault('sdk', {})
                sdk_dict.update({                                                        
                            'is_host': int(groups['is_host']),
                            'l3_dest_id': str(groups['l3_dest_id']),
                            'l3_dest_name': str(groups['l3_dest_name']),
                            'vrf_gid': int(groups['vrf_gid']),
                            'vrf_oid': int(groups['vrf_oid']),
                        })
                continue
            
            # object type: vxlan_next_hop
            m = p5.match(line)
            if m:
                groups = m.groupdict()
                ipv4_add_dict.update({                                                        
                            'object_type': str(groups['object_type']),
                        })
                continue

            # sdk nexthop oid:1449,dev:0, gid:0xa,macaddr:a0f8.4910.ab57, nh_type:normal(0)
            m = p6.match(line)
            if m:
                groups = m.groupdict()
                sdk_nexthop_dict = ipv4_add_dict.setdefault('sdk_nexthop', {})
                sdk_nexthop_dict.update({                                                        
                            'oid': int(groups['oid']),
                            'dev': int(groups['dev']),
                            'gid': str(groups['gid']),
                            'macaddr': str(groups['macaddr']),
                            'nh_type': str(groups['nh_type']),
                        })
                continue

            # sdk outgoing port oid 2143, porttype:svi(104)
            m = p7.match(line)
            if m:
                groups = m.groupdict()
                sdk_outgoing_port_dict = ipv4_add_dict.setdefault('sdk_outgoing_port', {})
                sdk_outgoing_port_dict.update({                                                        
                            'out_oid': int(groups['out_oid']),
                            'porttype': str(groups['porttype']),
                        })
                continue

            # forus_destination  SPECIAL_IPNEXTHOP_ID:obj_id:0
            m =p8.match(line)
            if m:
                groups = m.groupdict()
                forus_name = m.groupdict()['forus_name']
                forus_destination_dict = ipv4_add_dict.setdefault('forus_destination', {})
                forus_name_dict = forus_destination_dict.setdefault(forus_name, {})
                forus_name_dict.update({                                                        
                            'forus_obj_id': int(groups['forus_obj_id']),
                        })
                continue

            # Subnet Present in SDK for L3Port OID:2143
            m = p9.match(line)
            if m:
                groups = m.groupdict()
                ipv4_add_dict.update({                                                        
                            'subnet_present_l3port_oid': int(groups['subnet_present_l3port_oid']),
                        })
                continue

            # SPECIAL_IPNEXTHOP_ID:obj_id:0
            m = p10.match(line)
            if m:
                groups = m.groupdict()
                ipnexthop_name = m.groupdict()['ipnexthop_name']
                ipnexthop_name_dict = ipv4_add_dict.setdefault(ipnexthop_name, {})
                ipnexthop_name_dict.update({                                                        
                            'ipnexthop_obj_id': int(groups['ipnexthop_obj_id']),
                        })
                continue

            # sdk fec destination oid:1449,dev:0, destination_type:4b
            m = p11.match(line)
            if m:
                sdk_fec_dest = m.groupdict()
                sdk_fec_dest_dict = ipv4_add_dict.setdefault('sdk_fec_dest', {})
                sdk_fec_dest_dict.update({                                                        
                            'sdk_oid': int(sdk_fec_dest['sdk_oid']),
                            'sdk_dev': int(sdk_fec_dest['sdk_dev']),
                            'dest_type': str(sdk_fec_dest['dest_type']),
                        })
                continue

            # ADJ:objid:101 nh_type:NHADJ_NORMAL iif_id:0x553 ether_type:0x8 #child:2
            m = p12.match(line)
            if m:
                child_adj = m.groupdict()
                ipv4_add_dict.setdefault('child', {}).setdefault('child_adj', {})
                child_adj_dict = ipv4_add_dict.setdefault('child', {}).setdefault('child_adj', {})
                child_adj_dict.update({                                                        
                            'objid': int(child_adj['objid']),
                            'nh_type': str(child_adj['nh_type']),
                            'iif_id': str(child_adj['iif_id']),
                            'ether_type': str(child_adj['ether_type']),
                        })
                continue

            # srcmac:f87a.4125.2f02 dstmac:a0f8.4910.ab57
            m = p13.match(line)
            if m:
                groups = m.groupdict()
                child_adj_dict.update({                                                        
                            'srcmac': str(groups['srcmac']),
                            'dstmac': str(groups['dstmac']),
                        })
                continue

            # NPD: device:0 nh_gid/oid:10/1449 old_gid/oid:0/0 parent_oid:2143
            m = p14.match(line)
            if m:
                child_npd = m.groupdict()
                child_npd_dict = ipv4_add_dict.setdefault('child', {}).setdefault('child_npd', {})
                child_npd_dict.update({                                                        
                            'child_device': int(child_npd['child_device']),
                            'nh_gid': int(child_npd['nh_gid']),
                            'nh_oid': int(child_npd['nh_oid']),
                            'old_gid': int(child_npd['old_gid']),
                            'old_oid': int(child_npd['old_oid']),
                            'parent_oid': int(child_npd['parent_oid']),
                        })
                continue

            # fec_oid:1454 was_nor_nh:1 cr_def:0 stale:0 l3port_valid:1
            m = p15.match(line)
            if m:
                child_npd = m.groupdict()
                child_npd_dict.update({                                                        
                            'child_fec_oid': int(child_npd['child_fec_oid']),
                            'was_nor_nh': int(child_npd['was_nor_nh']),
                            'cr_def': int(child_npd['cr_def']),
                            'stale': int(child_npd['stale']),
                            'l3port_valid': int(child_npd['l3port_valid']),
                        })
                continue

            # SDK: cla_nhtype:0
            m = p16.match(line)
            if m:
                child_sdk = m.groupdict()
                child_sdk_dict = ipv4_add_dict.setdefault('child', {}).setdefault('child_sdk', {})
                child_sdk_dict.update({                                                        
                            'cla_nhtype': int(child_sdk['cla_nhtype']),
                        })
                continue

        return ret_dict

# =======================================
# Parser for 'show platform software fed'
# =======================================
class ShowPlatformSoftwareFedLspaAllSchema(MetaParser):

    ''' Schema for "show Platform software fed" '''

    schema = {
            'lspa_info': {
                    Optional('total_lspa_entries'):int,
                    Optional('lspa_record'): {
                            Any(): {
                                    Optional('mode'):str,
                                    Optional('ref_cnt'):int
                            }
                    }
            }
    }

# =======================================
# Parser for 'show platform software fed'
# =======================================
class ShowPlatformSoftwareFedLspaAll(ShowPlatformSoftwareFedLspaAllSchema):
    ''' Parser for
      "show platform software fed {switchvirtualstate} mpls lspa all"
    '''

    cli_command = ['show platform software fed {switchvirtualstate} mpls lspa all']

    def cli(self, switchvirtualstate="", output=None):
        if output is None:
            cmd = self.cli_command[0].format(switchvirtualstate=switchvirtualstate)
            output = self.device.execute(cmd)

        # Init vars
        ret_dict = {}

        #Detailed LSPA info for all LSPA: (# of entries:2)
        p1 = re.compile(r'^Detailed +LSPA +info +for +all +LSPA+\W+of +entries\W+(?P<total_lspa_entries>\d+)\)$')
        #LSPA:NPD:lspa_rec:0x118804cdfb8 lspa:0x118804ce108 rm_hdl:0 mode:PER_VRF ref_cnt:11
        #       lspakey[pfx1_gid,vpnlbl]:[1010,22][0,0] mode:1
        #       lspa:[vrf_id:6 vpn_encap_gid:0 l3nh_oid:1501 paths:1 dst_oid:1495]
        #    SDK: fec:oid:1501 l3_fec_st:1495, type:la_prefix_object_base(oid=1495)
        p2 = re.compile(r'^\S+lspa_rec\W+(?P<lspa_rec>(\S+))+\s+\S+\s+\S+\s+mode\W+(?P<mode>(\S+))+\s+ref_cnt\W+(?P<ref_cnt>(\d+))$')

        for line in output.splitlines():
            line = line.strip()

            #Detailed LSPA info for all LSPA: (# of entries:2)
            m = p1.match(line)
            if m:
                lspa_dict = ret_dict.setdefault('lspa_info', {})
                total_lspa_entries=int(m.groupdict()['total_lspa_entries'])
                lspa_dict['total_lspa_entries'] = total_lspa_entries
                continue

            m = p2.match(line)
            if m:
                lspa_rec_dict = lspa_dict.setdefault('lspa_record', {})
                rec_id=m.groupdict()['lspa_rec']
                lspa_rec=lspa_rec_dict.setdefault(rec_id,{})
                mode = m.groupdict()['mode']
                ref_cnt = int(m.groupdict()['ref_cnt'])
                lspa_rec['mode']=mode
                lspa_rec['ref_cnt']=ref_cnt
                continue

        return ret_dict

# ==============================================================
# Parser for 'show platform software dns-umbrella statistics'
# ==============================================================
class ShowPlatformSoftwareDnsUmbrellaStatisticsSchema(MetaParser):
    """Schema for show platform software dns-umbrella statistics"""
    schema = {
        'umbrella_statistics': {
            'total_packets': int,
            'dns_crypt_queries': int,
            'dns_crypt_responses': int,
            'dns_queries': int,
            'dns_bypass_queries': int,
            'dns_umbrella_responses': int,
            'dns_other_responses': int,
            'aged_queries': int,
            'dropped_packets': int,
        },
    }

class ShowPlatformSoftwareDnsUmbrellaStatistics(ShowPlatformSoftwareDnsUmbrellaStatisticsSchema):
    """Parser for show platform software dns-umbrella statistics"""

    cli_command = 'show platform software dns-umbrella statistics'

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        # initial return dictionary
        ret_dict = {}

        # Umbrella Statistics
        p0 = re.compile(r'^Umbrella\s+Statistics$')

        #Total Packets               : 57057
        p1 = re.compile(r'^Total\s+Packets\s+:\s+(?P<TotalPacket>\d+)$')

        #DNSCrypt queries            : 0
        p2 = re.compile(r'^DNSCrypt\s+queries\s+:\s+(?P<DnsCryptQueri>\d+)$')

        #DNSCrypt responses          : 0
        p3 = re.compile(r'^DNSCrypt\s+responses\s+:\s+(?P<DnsCryptResp>\d+)$')

        #DNS queries                 : 32321
        p4 = re.compile(r'^DNS\s+queries\s+:\s+(?P<DnsQueri>\d+)$')

        #DNS bypassed queries(Regex) : 0
        p5 = re.compile(r'^DNS\s+bypassed\s+queries\(Regex\)\s+:\s+(?P<DnsBypassQueri>\d+)$')

        #DNS responses(Umbrella)     : 24693
        p6 = re.compile(r'^DNS\s+responses\(Umbrella\)\s+:\s+(?P<DnsUmbrellaResp>\d+)$')

        #DNS responses(Other)        : 37
        p7 = re.compile(r'^DNS\s+responses\(Other\)\s+:\s+(?P<DnsOtherResp>\d+)$')

        #Aged queries                : 7628
        p8 = re.compile(r'^Aged\s+queries\s+:\s+(?P<AgedQueri>\d+)$')

        #Dropped pkts                : 0
        p9 = re.compile(r'^Dropped\s+pkts\s+:\s+(?P<DroppedPkts>\d+)$')

        for line in out.splitlines():
            line = line.strip()

            #Umbrella Statistics
            m = p0.match(line)
            if m:
                ret_dict['umbrella_statistics'] = {}
                continue

            #Total Packets               : 57057
            m = p1.match(line)
            if m:
                ret_dict['umbrella_statistics']['total_packets'] = int(m.groupdict()['TotalPacket'])
                continue

            #DNSCrypt queries            : 0
            m = p2.match(line)
            if m:
                ret_dict['umbrella_statistics']['dns_crypt_queries'] = int(m.groupdict()['DnsCryptQueri'])
                continue

            #DNSCrypt responses          : 0
            m = p3.match(line)
            if m:
                ret_dict['umbrella_statistics']['dns_crypt_responses'] = int(m.groupdict()['DnsCryptResp'])
                continue

            #DNS queries                 : 32321
            m = p4.match(line)
            if m:
                ret_dict['umbrella_statistics']['dns_queries'] = int(m.groupdict()['DnsQueri'])
                continue

            #DNS bypassed queries(Regex) : 0
            m = p5.match(line)
            if m:
                ret_dict['umbrella_statistics']['dns_bypass_queries'] = int(m.groupdict()['DnsBypassQueri'])
                continue

            #DNS responses(Umbrella)     : 24693
            m = p6.match(line)
            if m:
                ret_dict['umbrella_statistics']['dns_umbrella_responses'] = int(m.groupdict()['DnsUmbrellaResp'])
                continue

            #DNS responses(Other)        : 37
            m = p7.match(line)
            if m:
                ret_dict['umbrella_statistics']['dns_other_responses'] = int(m.groupdict()['DnsOtherResp'])
                continue

            #Aged queries                : 7628
            m = p8.match(line)
            if m:
                ret_dict['umbrella_statistics']['aged_queries'] = int(m.groupdict()['AgedQueri'])
                continue

            #Dropped pkts                : 0
            m = p9.match(line)
            if m:
                ret_dict['umbrella_statistics']['dropped_packets'] = int(m.groupdict()['DroppedPkts'])
                continue

        return ret_dict
# =====================================
# Schema for:
#  * 'show platform hardware authentication status'
# =====================================
class ShowPlatformHardwareAuthenticationStatusSchema(MetaParser):
    """Schema for show platform hardware authentication status."""

    schema = {

            Optional('SUP0 Authentication'): str,
            Optional('Fan Tray Authentication'): str,
            Optional('Line Card:6 Authentication'):str,
            Optional('Line Card:1 Authentication'): str,
            Optional('SUP1 Authentication'):str,
            Optional('Line Card:5 Authentication'):str,
            Optional('Line Card:2 Authentication'):str,
            Optional('Line Card:7 Authentication'):str,
            Optional('Line Card 1 Authentication'):str,
            Optional('Line Card 2 Authentication'):str,
            Optional('Line Card 5 Authentication'):str,
            Optional('Line Card 6 Authentication'):str,
            Optional('Fan Tray 1 Authentication'):str,
            Optional('Chassis Authentication'):str,
            Optional('SSD FRU Authentication'):str,
            Optional('SUP 0 Authentication'): str,
            Optional('SUP 1 Authentication'): str,

    }
# =====================================
# Parser for:
#  * 'show platform hardware authentication status'
# =====================================
class ShowPlatformHardwareAuthenticationStatus(ShowPlatformHardwareAuthenticationStatusSchema):
    """Parser for show platform hardware authentication status"""

    cli_command = 'show platform hardware authentication status'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        #show platform hardware authentication status
        #    SUP 0 Authentication:  pass
        #    SUP 1 Authentication:  pass
        #    Line Card 1 Authentication:  pass
        #    Line Card 2 Authentication:  pass
        #    Line Card 5 Authentication:  pass
        #    Line Card 6 Authentication:  pass
        #    Fan Tray 1 Authentication:  pass
        #    Chassis Authentication: pass

        ret_dict = {}

        p1=re.compile('(Line\s+Card |SUP|Line\s+Card:|Fan\s+Tray|Chassis|SSD.+|SUP\s+|Fan\s+Tray )\d*\s*Authentication:\s+(?P<Slot>(pass|Not Available|fail))')

        for line in output.splitlines():
            Auth=[]
            line=line.strip()
            Auth= line.split(': ')

            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict[Auth[0]] = group['Slot']
                continue

        return ret_dict
# =====================================
# Schema for:
#  * 'show platform sudi pki'
# =====================================
class ShowPlatformSudiPkiSchema(MetaParser):
    """Schema for show platform sudi pki."""

    schema = {
        Optional('Cisco Manufacturing CA III certificate') : str,
        Optional('Cisco Manufacturing CA') : str,
        Optional('Cisco Manufacturing CA III') : str,
        Optional('Cisco Manufacturing CA SHA2') : str,

    }
# =====================================
# Parser for:
#  * 'show platform sudi pki'
# =====================================
class ShowPlatformSudiPki(ShowPlatformSudiPkiSchema):
    """Parser for show platform sudi pki"""

    cli_command = 'show platform sudi pki'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        #'Cisco Manufacturing CA III' certificate : Enabled
        #    SUDI Issuer-CN                      Validation status
        #    -----------------------------------------------------
        #    Cisco Manufacturing CA              Valid
        #    Cisco Manufacturing CA III          Valid
        #    Cisco Manufacturing CA SHA2         Valid

        ret_dict = {}

        p1=re.compile('((Cisco.+|\'Cisco.+:)\s+(?P<Valid>(((Enabled\s\(.*\))|Enabled)|((Disabled\s\(.*\))|Disabled)|Valid|Not Supported|Invalid|Init Failure)))')

        for line in output.splitlines():
            line1=[]
            line=line.strip()
            if ":" in line:
                line1.insert(0,'Cisco Manufacturing CA III certificate')
            else:
                line1 = line.split('  ')

            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict[line1[0]] = group['Valid']
                continue

        return ret_dict


class ShowPlatformHardwareChassisFantrayDetailSwitchSchema(MetaParser):
    """
    Schema for show platform hardware chassis fantray detail switch {mode}
    """
    schema = {
        'fantray_details':{
            Any(): {
                'inlet_rpm': int,
                'outlet_rpm': int,
                'pwm':str
            },
        },
    }

class ShowPlatformHardwareChassisFantrayDetailSwitch(ShowPlatformHardwareChassisFantrayDetailSwitchSchema):
    """ Parser for show platform hardware chassis fantray detail switch {mode}"""

    cli_command = 'show platform hardware chassis fantray detail switch {mode}'

    def cli(self, mode, output=None):
        if output is None:
            # excute command to get output
            output = self.device.execute(self.cli_command.format(mode=mode))

        # initial variables
        ret_dict = {}

        # FT1:
        p1 = re.compile('^(?P<fan_tray>.+)\:$')

        # Inlet:8330 RPM, Outlet:10015 RPM, PWM:30%
        p2 = re.compile('^Inlet:(?P<inlet_rpm>\d+) +RPM\, +Outlet:(?P<outlet_rpm>\d+) +RPM\, PWM:(?P<pwm>\d+%)$')

        for line in output.splitlines():
            line = line.strip()

            # FT1:
            m = p1.match(line)
            if m:
                group = m.groupdict()
                root_dict = ret_dict.setdefault('fantray_details',{}).setdefault(group['fan_tray'],{})
                continue

            # Inlet:8330 RPM, Outlet:10015 RPM, PWM:30%
            m = p2.match(line)
            if m:
                group = m.groupdict()
                root_dict['inlet_rpm'] = int(group['inlet_rpm'])
                root_dict['outlet_rpm'] = int(group['outlet_rpm'])
                root_dict['pwm'] = group['pwm']
                continue

        return ret_dict


class ShowPlatformHardwareChassisPowerSupplyDetailSwitchAllSchema(MetaParser):
    """
    Schema for show platform hardware chassis power-supply detail switch {mode} all
    """
    schema = {
        'power_supply_details' : {
            Any(): {
                'input_voltage_volt': str,
                'output_voltage_volt': str,
                'input_power_watt':str,
                'output_power_watt': str,
                'input_current_amp': str,
                'output_current_amp':str,
                'temperature1_celsius': str,
                'temperature2_celsius': str,
                'temperature3_celsius':str,
                'fan_speed_1_rpm':str
            },
        },
    }

class ShowPlatformHardwareChassisPowerSupplyDetailSwitchAll(ShowPlatformHardwareChassisPowerSupplyDetailSwitchAllSchema):
    """ Parser for show platform hardware chassis power-supply detail switch {mode} all"""

    cli_command = 'show platform hardware chassis power-supply detail switch {mode} all'

    def cli(self, mode, output=None):
        if output is None:
            # excute command to get output
            output = self.device.execute(self.cli_command.format(mode=mode))
        else:
            output = output
        # initial variables
        ret_dict = {}

        # PS1:
        p1 = re.compile('^(?P<power_supply>.+)\:$')

        # Input Voltage   :       121.1250 V
        p2 = re.compile('^Input\s+Voltage\s+:\s+(?P<input_voltage_volt>\d+\.\d+) V$')

        # Output Voltage  :       12.0547 V
        p3 = re.compile('^Output\s+Voltage\s+:\s+(?P<output_voltage_volt>\d+\.\d+) V$')

        # Input Power     :       507.5000 W
        p4 = re.compile('^Input\s+Power\s+:\s+(?P<input_power_watt>\d+\.\d+) W$')

        # Output Power    :       0.0000 W
        p5 = re.compile('^Output\s+Power\s+:\s+(?P<output_power_watt>\d+\.\d+) W$')

        # Input Current   :       0.0000 A
        p6 = re.compile('^Input\s+Current\s+:\s+(?P<input_current_amp>\d+\.\d+) A$')

        # Output Current  :       0.0000 A
        p7 = re.compile('^Output\s+Current\s+:\s+(?P<output_current_amp>\d+\.\d+) A$')

        # Temperature1    :       0.0000 C
        p8 = re.compile('^Temperature1\s+:\s+(?P<temperature1_celsius>\d+\.\d+) C$')

        # Temperature2    :       0.0000 C
        p9 = re.compile('^Temperature2\s+:\s+(?P<temperature2_celsius>\d+\.\d+) C$')

        # Temperature3    :       0.0000 C
        p10 = re.compile('^Temperature3\s+:\s+(?P<temperature3_celsius>\d+\.\d+) C$')

        # Fan Speed 1     :       0.0000 RPM
        p11= re.compile('^Fan\s+Speed\s+1\s+:\s+(?P<fan_speed_1_rpm>\d+\.\d+) RPM$')

        for line in output.splitlines():
            line=line.strip()

            # PS1:
            m = p1.match(line)
            if m:
                group = m.groupdict()
                root_dict=ret_dict.setdefault('power_supply_details',{}).setdefault(group['power_supply'],{})
                continue

            # Input Voltage   :       121.1250 V
            m = p2.match(line)
            if m:
                group = m.groupdict()
                root_dict['input_voltage_volt'] = group['input_voltage_volt']
                continue

            # Output Voltage  :       12.0547 V
            m = p3.match(line)
            if m:
                group = m.groupdict()
                root_dict['output_voltage_volt'] = group['output_voltage_volt']
                continue

            # Input Power     :       507.5000 W
            m = p4.match(line)
            if m:
                group = m.groupdict()
                root_dict['input_power_watt'] = group['input_power_watt']
                continue

            # Output Power    :       0.0000 W
            m = p5.match(line)
            if m:
                group = m.groupdict()
                root_dict['output_power_watt'] = group['output_power_watt']
                continue

            # Input Current   :       4.3359 A
            m = p6.match(line)
            if m:
                group = m.groupdict()
                root_dict['input_current_amp'] = group['input_current_amp']
                continue

            # Output Current  :      39.5625 A
            m = p7.match(line)
            if m:
                group = m.groupdict()
                root_dict['output_current_amp'] = group['output_current_amp']
                continue

            # Temperature1    :      38.0000 C
            m = p8.match(line)
            if m:
                group = m.groupdict()
                root_dict['temperature1_celsius'] = group['temperature1_celsius']
                continue

            # Temperature2    :      62.0000 C
            m = p9.match(line)
            if m:
                group = m.groupdict()
                root_dict['temperature2_celsius'] = group['temperature2_celsius']
                continue

            # Temperature3    :      55.0000 C
            m = p10.match(line)
            if m:
                group = m.groupdict()
                root_dict['temperature3_celsius'] = group['temperature3_celsius']
                continue

            # Fan Speed 1     :   11488.0000 RPM
            m = p11.match(line)
            if m:
                group = m.groupdict()
                root_dict['fan_speed_1_rpm'] = group['fan_speed_1_rpm']
                continue

        return ret_dict

class ShowPlatformSoftwareCpmSwitchB0CountersDropSchema(MetaParser):
    """
    Schema for show platform software cpm switch {mode} B0 counters drop
    """
    schema = {
        Any(): int,
    }

class ShowPlatformSoftwareCpmSwitchB0CountersDrop(ShowPlatformSoftwareCpmSwitchB0CountersDropSchema):
    """ Parser for show platform software cpm switch {mode} B0 counters drop"""

    cli_command = 'show platform software cpm switch {mode} B0 counters drop'

    def cli(self, mode, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(mode=mode))

        # initial variables
        ret_dict = {}

        #RX unexpected packet count                    311
        p1 = re.compile('^(?P<drop_counters>[\w ]+)\s+(?P<drop_count>\d+)$')

        for line in output.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict[group['drop_counters'].strip()] = int(group['drop_count'])
                continue

        return ret_dict


class ShowPlatformSoftwareCpmSwitchB0CountersPuntInjectSchema(MetaParser):
    """
    Schema for show platform software cpm switch {mode} B0 counters punt-inject
    """
    schema = {
        'traffic_type': {
            Any(): {
                'packets_inject' : int,
                'packets_punt' : int,
                'drop_inject' : int,
                'drop_punt' : int,
            },
        },
    }

class ShowPlatformSoftwareCpmSwitchB0CountersPuntInject(ShowPlatformSoftwareCpmSwitchB0CountersPuntInjectSchema):
    """ Parser for show platform software cpm switch {mode} B0 counters punt-inject"""

    cli_command = 'show platform software cpm switch {mode} B0 counters punt-inject'

    def cli(self, mode, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(mode=mode))

        # initial variables
        ret_dict = {}

        p1 = re.compile('^(?P<traffic_type>\w+\s+\w+)\s+(?P<packets_inject>\d+)\s+(?P<packets_punt>\d+)\s+(?P<drop_inject>\d+)\s+(?P<drop_punt>\d+)$')

        for line in output.splitlines():
            line=line.strip()
            m=p1.match(line)
            if m:
                group=m.groupdict()
                root_dict = ret_dict.setdefault('traffic_type',{}).setdefault(group['traffic_type'].strip(),{})
                root_dict['packets_inject']= int(group['packets_inject'])
                root_dict['packets_punt'] = int(group['packets_punt'])
                root_dict['drop_inject'] = int(group['drop_inject'])
                root_dict['drop_punt'] = int(group['drop_punt'])
                continue

        return ret_dict


class ShowPlatformSoftwareCpmSwitchB0IpcBriefSchema(MetaParser):
    """
    Schema for show platform software cpm switch {mode} B0 ipc brief
    """
    schema = {
        'ipc_status':{
                'cpm_cm': str,
                'cpm_fed': str,
        },
    }

class ShowPlatformSoftwareCpmSwitchB0IpcBrief(ShowPlatformSoftwareCpmSwitchB0IpcBriefSchema):
    """ Parser for show platform software cpm switch {mode} B0 ipc brief"""

    cli_command = 'show platform software cpm switch {mode} B0 ipc brief'

    def cli(self, mode, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(mode=mode))

        # initial variables
        ret_dict = {}

        # cpm-cm     connected
        p1 = re.compile('^cpm-cm\s+(?P<cpm_cm>\w+)$')

        # cpm-fed    connected
        p2 = re.compile('^cpm-fed\s+(?P<cpm_fed>\w+)$')

        for line in output.splitlines():
            line=line.strip()

            # cpm-cm     connected
            m=p1.match(line)
            if m:
                group=m.groupdict()
                root_dict = ret_dict.setdefault('ipc_status',{})
                root_dict['cpm_cm']=group['cpm_cm']
                continue

            # cpm-fed    connected
            m=p2.match(line)
            if m:
                group=m.groupdict()
                root_dict['cpm_fed']=group['cpm_fed']
                continue

        return ret_dict


class ShowPlatformSoftwareCpmSwitchB0IpcDetailSchema(MetaParser):
    """
    Schema for show platform software cpm switch {mode} B0 ipc detail
    """
    schema = {
        'bipc_connection_status':{
            Optional('service') : str,
            Optional('peer_location') : int,
            Optional('peer_state') : int,
            Optional('connection_drops') : int,
            Optional('flow_control') : int,
            Optional('transition_count') : int,
            Optional('received_msgs') : int,
            Optional('tdl_hdl_failure') : int,
            Optional('dispatch_failures') : int,
            Optional('rx_other_drops') : int,
            Optional('sent_msgs') : int,
            Optional('tx_no_mem_failures') : int,
            Optional('tx_other_drops') : int,
            Optional('tx_no_space_failures') : int
        },
    }

class ShowPlatformSoftwareCpmSwitchB0IpcDetail(ShowPlatformSoftwareCpmSwitchB0IpcDetailSchema):
    """ Parser for show platform software cpm switch {mode} B0 ipc detail"""

    cli_command = 'show platform software cpm switch {mode} B0 ipc detail'

    def cli(self, mode, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(mode=mode))

        # initial variables
        ret_dict = {}

        # Service: cpm-cm
        p1=re.compile('^Service:\s+(?P<service>\S+)$')

        # Peer Location: -1
        p2=re.compile('^Peer Location:\s+(?P<peer_location>\S+)$')

        # Peer State: 2
        p3=re.compile('^Peer State:\s+(?P<peer_state>\d+)$')

        # Connection Drops: 0
        p4=re.compile('^Connection Drops:\s+(?P<connection_drops>\d+)$')

        # Flow Control: 0
        p5=re.compile('^Flow Control:\s+(?P<flow_control>\d+)$')

        # Transition Count: 0
        p6=re.compile('^Transition Count:\s+(?P<transition_count>\d+)$')

        # Received Msgs: 1
        p7=re.compile('^Received Msgs:\s+(?P<received_msgs>\d+)$')

        # TDL hdl failure: 0
        p8=re.compile('^TDL hdl failure:\s+(?P<tdl_hdl_failure>\d+)$')

        # Dispatch failures: 1
        p9=re.compile('^Dispatch failures:\s+(?P<dispatch_failures>\d+)$')

        # Rx Other Drops: 0
        p10=re.compile('^Rx Other Drops:\s+(?P<rx_other_drops>\d+)$')

        # Sent msgs: 1
        p11=re.compile('^Sent msgs:\s+(?P<sent_msgs>\d+)$')

        # Tx No Mem failures: 0
        p12=re.compile('^Tx No Mem failures:\s+(?P<tx_no_mem_failures>\d+)$')

        # Tx Other Drops: 0
        p13=re.compile('^Tx Other Drops:\s+(?P<tx_other_drops>\d+)$')

        # Tx No Space failures: 0
        p14=re.compile('^Tx No Space failures:\s+(?P<tx_no_space_failures>\d+)$')

        for line in output.splitlines():
            line = line.strip()

            # Service: cpm-cm
            m = p1.match(line)
            if m:
                group = m.groupdict()
                root_dict = ret_dict.setdefault('bipc_connection_status',{})
                root_dict['service']=group['service']
                continue

            # Peer Location: -1
            m = p2.match(line)
            if m:
                group = m.groupdict()
                root_dict['peer_location']=int(group['peer_location'])
                continue

            # Peer State: 2
            m = p3.match(line)
            if m:
                group = m.groupdict()
                root_dict['peer_state']=int(group['peer_state'])
                continue

            # Connection Drops: 0
            m = p4.match(line)
            if m:
                group = m.groupdict()
                root_dict['connection_drops']=int(group['connection_drops'])
                continue

            # Flow Control: 0
            m = p5.match(line)
            if m:
                group = m.groupdict()
                root_dict['flow_control']=int(group['flow_control'])
                continue

            # Transition Count: 0
            m = p6.match(line)
            if m:
                group = m.groupdict()
                root_dict['transition_count']=int(group['transition_count'])
                continue

            # Received Msgs: 1
            m = p7.match(line)
            if m:
                group = m.groupdict()
                root_dict['received_msgs']=int(group['received_msgs'])
                continue

            # TDL hdl failure: 0
            m = p8.match(line)
            if m:
                group = m.groupdict()
                root_dict['tdl_hdl_failure']=int(group['tdl_hdl_failure'])
                continue

            # Dispatch failures: 1
            m = p9.match(line)
            if m:
                group = m.groupdict()
                root_dict['dispatch_failures']=int(group['dispatch_failures'])
                continue

            # Rx Other Drops: 0
            m = p10.match(line)
            if m:
                group = m.groupdict()
                root_dict['rx_other_drops']=int(group['rx_other_drops'])
                continue

            # Sent msgs: 1
            m = p11.match(line)
            if m:
                group = m.groupdict()
                root_dict['sent_msgs']=int(group['sent_msgs'])
                continue

            # Tx No Mem failures: 0
            m = p12.match(line)
            if m:
                group = m.groupdict()
                root_dict['tx_no_mem_failures']=int(group['tx_no_mem_failures'])
                continue

            # Tx Other Drops: 0
            m = p13.match(line)
            if m:
                group = m.groupdict()
                root_dict['tx_other_drops']=int(group['tx_other_drops'])
                continue

            # Tx No Space failures: 0
            m = p14.match(line)
            if m:
                group = m.groupdict()
                root_dict['tx_no_space_failures']=int(group['tx_no_space_failures'])
                continue

        return ret_dict

# ==========================================================================
# Schema for 'show platform software fed switch active punt cpuq {cpu_q_id}'
# ==========================================================================
class ShowPlatformSoftwareFedSwitchActivePuntCpuqSchema(MetaParser):
    """Schema for show platform software fed switch active punt cpuq {cpu_q_id}"""

    schema = {
                 'punt_cpu_q_statistics':{
                     'cpu_q_id': int,
                     'cpu_q_name': str,
                     'packets_received_from_asic': int,
                     'send_to_iosd_total_attempts': int,
                     'send_to_iosd_failed_count': int,
                     'rx_suspend_count': int,
                     'rx_unsuspend_count': int,
                     'rx_unsuspend_send_count': int,
                     'rx_unsuspend_send_failed_count': int,
                     'rx_consumed_count': int,
                     'rx_dropped_count': int,
                     'rx_non_active_dropped_count': int,
                     'rx_conversion_failure_dropped': int,
                     'rx_intack_count': int,
                     'rx_packets_dq_d_after_intack': int,
                     'active_rxq_event': int,
                     'rx_spurious_interrupt': int,
                     'rx_phy_idb_fetch_failed': int,
                     'rx_table_id_fetch_failed': int,
                     'rx_invalid_punt_cause': int,
                 },
                'replenish_stats_for_all_rxq': {
                     'number_of_replenish': int,
                     'number_of_replenish_suspend': int,
                     'number_of_replenish_unsuspend': int,
                 },
              }

# =========================================================================
#  Parser for show platform software fed switch active punt cpuq {cpu_q_id}
# =========================================================================
class ShowPlatformSoftwareFedSwitchActivePuntCpuq(ShowPlatformSoftwareFedSwitchActivePuntCpuqSchema):
    """
    show platform software fed switch active punt cpuq {cpu_q_id}
    """

    cli_command = ['show platform software fed {switch} active punt cpuq {cpu_q_id}',
                   'show platform software fed active punt cpuq {cpu_q_id}']

    def cli(self, cpu_q_id, switch="", output=None):

        if output is None:
            if switch:
                cmd = self.cli_command[0].format(switch=switch,cpu_q_id=cpu_q_id)
            else:
                cmd = self.cli_command[1].format(cpu_q_id=cpu_q_id)

            output = self.device.execute(cmd)

        ret_dict = {}

        # Punt CPU Q Statistics
        p0 = re.compile(r'Punt CPU Q Statistics$')

        # CPU Q Id                       : 18
        p1 = re.compile(r'CPU Q Id +: +(?P<cpu_q_id>\d+)$')

        # CPU Q Name                     : CPU_Q_TRANSIT_TRAFFIC
        p2 = re.compile(r'^CPU Q Name +: +(?P<cpu_q_name>\S+)$')

        # Packets received from ASIC     : 64564
        p3 = re.compile(r'^Packets received from ASIC +: +(?P<packets_received_from_asic>\d+)$')

        # Send to IOSd total attempts    : 64564
        p4 = re.compile(r'^Send to IOSd total attempts +: +(?P<send_to_iosd_total_attempts>\d+)$')

        # Send to IOSd failed count      : 0
        p5 = re.compile(r'^Send to IOSd failed count +: +(?P<send_to_iosd_failed_count>\d+)$')

        # RX suspend count               : 0
        p6 = re.compile(r'^RX suspend count +: +(?P<rx_suspend_count>\d+)$')

        # RX unsuspend count             : 0
        p7 = re.compile(r'^RX unsuspend count +: +(?P<rx_unsuspend_count>\d+)$')

        # RX unsuspend send count        : 0
        p8 = re.compile(r'^RX unsuspend send count +: +(?P<rx_unsuspend_send_count>\d+)$')

        # RX unsuspend send failed count : 0
        p9 = re.compile(r'^RX unsuspend send failed count +: +(?P<rx_unsuspend_send_failed_count>\d+)$')

        # RX consumed count              : 0
        p10 = re.compile(r'^RX consumed count +: +(?P<rx_consumed_count>\d+)$')

        # RX dropped count               : 0
        p11 = re.compile(r'^RX dropped count +: +(?P<rx_dropped_count>\d+)$')

        # RX non-active dropped count    : 0
        p12 = re.compile(r'^RX non-active dropped count +: +(?P<rx_non_active_dropped_count>\d+)$')

        # RX conversion failure dropped  : 0
        p13 = re.compile(r'^RX conversion failure dropped +: +(?P<rx_conversion_failure_dropped>\d+)$')

        # RX INTACK count                : 15377
        p14 = re.compile(r'^RX INTACK count +: +(?P<rx_intack_count>\d+)$')

        # RX packets dq'd after intack   : 0
        p15 = re.compile(r'^RX packets dq\'d after intack +: +(?P<rx_packets_dq_d_after_intack>\d+)$')

        # Active RxQ event               : 16723
        p16 = re.compile(r'^Active RxQ event +: +(?P<active_rxq_event>\d+)$')

        # RX spurious interrupt          : 1831
        p17 = re.compile(r'^RX spurious interrupt +: +(?P<rx_spurious_interrupt>\d+)$')

        # RX phy_idb fetch failed: 0
        p18 = re.compile(r'^RX phy_idb fetch failed+: +(?P<rx_phy_idb_fetch_failed>\d+)$')

        # RX table_id fetch failed: 0
        p19 = re.compile(r'^RX table_id fetch failed+: +(?P<rx_table_id_fetch_failed>\d+)$')

        # RX invalid punt cause: 0
        p20 = re.compile(r'^RX invalid punt cause+: +(?P<rx_invalid_punt_cause>\d+)$')

        # Replenish Stats for all rxq:
        p21 = re.compile(r'Replenish Stats for all rxq:$')

        # Number of replenish            : 20055
        p22 = re.compile(r'^Number of replenish +: +(?P<number_of_replenish>\d+)$')

        # Number of replenish suspend    : 0
        p23 = re.compile(r'^Number of replenish suspend +: +(?P<number_of_replenish_suspend>\d+)$')

        # Number of replenish un-suspend : 0
        p24 = re.compile(r'^Number of replenish un-suspend +: +(?P<number_of_replenish_unsuspend>\d+)$')

        for line in output.splitlines():
            line = line.strip()

            # Punt CPU Q Statistics
            m = p0.match(line)
            if m:
                punt_cpu_q_statistics = ret_dict.setdefault('punt_cpu_q_statistics', {})

            # CPU Q Id                       : 18
            m = p1.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["cpu_q_id"] = int(group["cpu_q_id"])

            # CPU Q Name                     : CPU_Q_TRANSIT_TRAFFIC
            m = p2.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["cpu_q_name"] = group["cpu_q_name"]

            # Packets received from ASIC     : 64564
            m = p3.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["packets_received_from_asic"] = int(group["packets_received_from_asic"])

            # Send to IOSd total attempts    : 64564
            m = p4.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["send_to_iosd_total_attempts"] = int(group["send_to_iosd_total_attempts"])

            # Send to IOSd failed count      : 0
            m = p5.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["send_to_iosd_failed_count"] = int(group["send_to_iosd_failed_count"])

            # RX suspend count               : 0
            m = p6.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["rx_suspend_count"] = int(group["rx_suspend_count"])

            # RX unsuspend count             : 0
            m = p7.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["rx_unsuspend_count"] = int(group["rx_unsuspend_count"])

            # RX unsuspend send count        : 0
            m = p8.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["rx_unsuspend_send_count"] = int(group["rx_unsuspend_send_count"])

            # RX unsuspend send failed count : 0
            m = p9.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["rx_unsuspend_send_failed_count"] = int(group["rx_unsuspend_send_failed_count"])

            # RX consumed count              : 0
            m = p10.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["rx_consumed_count"] = int(group["rx_consumed_count"])

            # RX dropped count               : 0
            m = p11.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["rx_dropped_count"] = int(group["rx_dropped_count"])

            # RX non-active dropped count    : 0
            m = p12.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["rx_non_active_dropped_count"] = int(group["rx_non_active_dropped_count"])

            # RX conversion failure dropped  : 0
            m = p13.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["rx_conversion_failure_dropped"] = int(group["rx_conversion_failure_dropped"])

            # RX INTACK count                : 15377
            m = p14.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["rx_intack_count"] = int(group["rx_intack_count"])

            # RX packets dq'd after intack   : 0
            m = p15.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["rx_packets_dq_d_after_intack"] = int(group["rx_packets_dq_d_after_intack"])

            # Active RxQ event               : 16723
            m = p16.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["active_rxq_event"] = int(group["active_rxq_event"])

            # RX spurious interrupt          : 1831
            m = p17.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["rx_spurious_interrupt"] = int(group["rx_spurious_interrupt"])

            # RX phy_idb fetch failed: 0
            m = p18.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["rx_phy_idb_fetch_failed"] = int(group["rx_phy_idb_fetch_failed"])

            # RX table_id fetch failed: 0
            m = p19.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics['rx_table_id_fetch_failed'] = int(group["rx_table_id_fetch_failed"])

            # RX invalid punt cause: 0
            m = p20.match(line)
            if m:
                group = m.groupdict()
                punt_cpu_q_statistics["rx_invalid_punt_cause"] = int(group["rx_invalid_punt_cause"])

            # Replenish Stats for all rxq:
            m = p21.match(line)
            if m:
                replenish_stats_for_all_rxq = ret_dict.setdefault('replenish_stats_for_all_rxq', {})

            # Number of replenish            : 20055
            m = p22.match(line)
            if m:
                group = m.groupdict()
                replenish_stats_for_all_rxq["number_of_replenish"] = int(group["number_of_replenish"])

            # Number of replenish suspend    : 0
            m = p23.match(line)
            if m:
                group = m.groupdict()
                replenish_stats_for_all_rxq["number_of_replenish_suspend"] = int(group["number_of_replenish_suspend"])

            # Number of replenish un-suspend : 0
            m = p24.match(line)
            if m:
                group = m.groupdict()
                replenish_stats_for_all_rxq["number_of_replenish_unsuspend"] = int(group["number_of_replenish_unsuspend"])

        return ret_dict

# =============================================================================================================================
# Schema for 'show platform hardware fed switch active fwd-asic resource tcam table pbr record 0 format 0 | begin {nat_region}'
# =============================================================================================================================
class ShowPlatformTcamPbrSchema(MetaParser):
    """Schema for show platform hardware fed switch active fwd-asic resource tcam table pbr record 0 format 0 | begin {nat_region}"""

    schema = {
                 'index':{
                     Any():{
                         'mask':{
                             Any(): str,},
                         'key':{
                             Any(): str,},
                         'ad': str,
                     }
                 }
             }

# ============================================================================================================================
#  Parser for show platform hardware fed switch active fwd-asic resource tcam table pbr record 0 format 0 | begin {nat_region}
# ============================================================================================================================
class ShowPlatformTcamPbr(ShowPlatformTcamPbrSchema):
    """
    show platform hardware fed switch active fwd-asic resource tcam table pbr record 0 format 0 | begin {nat_region}
    """

    cli_command = ['show platform hardware fed {switch} active fwd-asic resource tcam table pbr record 0 format 0 | begin {nat_region}',
                   'show platform hardware fed active fwd-asic resource tcam table pbr record 0 format 0 | begin {nat_region}']

    def cli(self, nat_region, switch="", output=None):

        if output is None:
            if switch:
                cmd = self.cli_command[0].format(switch=switch,nat_region=nat_region)
            else:
                 cmd = self.cli_command[1].format(nat_region=nat_region)

            output = self.device.execute(cmd)

        # initial variables
        ret_dict = {}

        #TAQ-1 Index-352 (A:0,C:0) Valid StartF-1 StartA-1 SkipF-0 SkipA-0
        p0 = re.compile(r'^TAQ-\d+\sIndex-(?P<index>\d+)\s\([A-Z]\:\d,[A-Z]\:\d\)\sValid\sStart[A-Z]-\d\sStart[A-Z]-\d\sSkip[A-Z]-\d\sSkip[A-Z]-\d$')

        # Mask1 00ffff00:00000000:00000000:00000000:00000000:00000000:00000000:00000000
        p1 = re.compile(r'^(?P<mask_name>Mask\d+) +(?P<mask1>\S+)$')

        # Key1  00800400:00000000:00000000:00000000:00000000:00000000:00000000:00000000
        p2 = re.compile(r'^(?P<key_name>Key\d+) +(?P<key1>\S+)$')

        # AD 10082000:00000001
        p3 = re.compile(r'^AD +(?P<ad>[\da-f:]+)$')

        for line in output.splitlines():
            line = line.strip()
            #TAQ-1 Index-352 (A:0,C:0) Valid StartF-1 StartA-1 SkipF-0 SkipA-0
            m = p0.match(line)
            if m:
                group = m.groupdict()
                index = group['index']
                index_dict = ret_dict.setdefault('index', {}).setdefault(index,{})
                mask_dict = index_dict.setdefault('mask',{})
                key_dict = index_dict.setdefault('key',{})

            # Mask1 3300f000:0f030000:00000000:00000000:00000000:00000000:00000000:ffffffff
            m = p1.match(line)
            if m:
                group = m.groupdict()
                mask_name = group['mask_name']
                mask_dict[mask_name] = group['mask1']

            # Key1  11009000:01020000:00000000:00000000:00000000:00000000:00000000:c0000002
            m = p2.match(line)
            if m:
                group = m.groupdict()
                key_name = group['key_name']
                key_dict[key_name] = group['key1']

            # AD 10087000:000000b6:00000000
            m = p3.match(line)
            if m:
                group = m.groupdict()
                index_dict['ad'] = group['ad']

        return ret_dict

# =============================================================
# Schema for 'show platform nat translations active statistics'
# =============================================================
class ShowPlatformNatTranslationsStatisticsSchema(MetaParser):
    """Schema for show platform nat translations active statistics"""

    schema = {
                  'nat_type': str,
                  'netflow_type': str,
                  'flow_record': str,
                  'dynamic_nat_entries': str,
                  'static_nat_entries': str,
                  'total_nat_entries': str,
                  'total_hw_resource_tcam': str
             }

# ============================================================
#  Parser for show platform nat translations active statistics
# ============================================================
class ShowPlatformNatTranslationsStatistics(ShowPlatformNatTranslationsStatisticsSchema):
    """
    show platform nat translations active statistics
    """

    cli_command = 'show platform nat translations active statistics'

    def cli(self, output=None):

        if output is None:

           output = self.device.execute(self.cli_command)

        # initial variables
        ret_dict = {}

        # NAT Type                : Static
        p0 = re.compile(r'^NAT Type +: +(?P<nat_type>-+|Static|Dynamic)$')

        # Netflow Type            : NA
        p1 = re.compile(r'^Netflow Type +: +(?P<netflow_type>\S+)$')

        # Flow Record             : Disabled
        p2 = re.compile(r'^Flow Record  +: +(?P<flow_record>-+|Disabled|Enabled)$')

        # Dynamic NAT entries     : 0 entries
        p3 = re.compile(r'^Dynamic NAT entries  +: +(?P<dynamic_nat_entries>\d+ entries)$')

        # Static NAT entries      : 0 entries
        p4 = re.compile(r'^Static NAT entries +: +(?P<static_nat_entries>\d+ entries)$')

        # Total NAT entries       : 0 entries
        p5 = re.compile(r'^Total NAT entries +: +(?P<total_nat_entries>\d+ entries)$')

        # Total HW Resource (TCAM): 26 of 27648 /0 .09% utilization
        p6 = re.compile(r'^Total HW Resource \(TCAM\)+: +(?P<total_hw_resource_tcam>\d+ of \d+ /\d+ \.\d+% utilization)$')

        for line in output.splitlines():
            line = line.strip()

            # NAT Type                : Static
            m = p0.match(line)
            if m:
                group = m.groupdict()
                ret_dict["nat_type"] = group["nat_type"]

            # Netflow Type            : NA
            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict["netflow_type"] = group["netflow_type"]

            # Flow Record             : Disabled
            m = p2.match(line)
            if m:
                group = m.groupdict()
                ret_dict["flow_record"] = group["flow_record"]

            # Dynamic NAT entries     : 0 entries
            m = p3.match(line)
            if m:
                group = m.groupdict()
                ret_dict["dynamic_nat_entries"] = group["dynamic_nat_entries"]

            # Static NAT entries      : 0 entries
            m = p4.match(line)
            if m:
                group = m.groupdict()
                ret_dict["static_nat_entries"] = group["static_nat_entries"]

            # Total NAT entries       : 0 entries
            m = p5.match(line)
            if m:
                group = m.groupdict()
                ret_dict["total_nat_entries"] = group["total_nat_entries"]

            # Total HW Resource (TCAM): 26 of 27648 /0 .09% utilization
            m = p6.match(line)
            if m:
                group = m.groupdict()
                ret_dict["total_hw_resource_tcam"] = group["total_hw_resource_tcam"]

        return ret_dict

# ==================================================
# Schema for 'show platform nat translations active'
# ==================================================
class ShowPlatformNatTranslationsSchema(MetaParser):
    """Schema for show platform nat translations active"""

    schema = {
                 'index':{
                     Any():{
                         'protocol': str,
                         'inside_global': str,
                         'inside_local': str,
                         'outside_local': str,
                         'outside_global': str
                     }
                  }
             }

# =================================================
#  Parser for show platform nat translations active
# =================================================
class ShowPlatformNatTranslations(ShowPlatformNatTranslationsSchema):
    """
    show platform nat translations active
    """

    cli_command = 'show platform nat translations active'

    def cli(self, output=None):

        if output is None:
            output = self.device.execute(self.cli_command)

        # initial variables
        ret_dict = {}
        index_dict = {}
        index = 1

        # Pro Inside global Inside local Outside local Outside global
        # TCP 135.0.0.2:0   192.0.0.2:0  193.0.0.2:0   193.0.0.2:0
        p1 = re.compile(r'^(?P<protocol>-+|UDP|TCP) +'
                        r'(?P<inside_global>[\d.]+:+\d+) +'
                        r'(?P<inside_local>[\d.]+:+\d+) +'
                        r'(?P<outside_local>[\d.]+:+\d+) +'
                        r'(?P<outside_global>[\d.]+:+\d+)$')

        for line in output.splitlines():
            line = line.strip()

            # Pro Inside global Inside local Outside local Outside global
            # TCP 135.0.0.2:0   192.0.0.2:0  193.0.0.2:0   193.0.0.2:0
            m = p1.match(line)
            if m:
                group = m.groupdict()
                index_dict = ret_dict.setdefault('index', {}).setdefault(index,{})
                index_dict['protocol'] = group['protocol']
                index_dict['inside_global'] = group['inside_global']
                index_dict['inside_local'] = group['inside_local']
                index_dict['outside_local'] = group['outside_local']
                index_dict['outside_global'] = group['outside_global']
                index += 1

        return ret_dict


# ==========================================================================================================
# Schema for 'show platform hardware fed switch active fwd-asic resource tcam table acl | begin {INPUT_NAT}'
# ==========================================================================================================
class ShowPlatformTcamAclSchema(MetaParser):
    """Schema for show platform hardware fed switch active fwd-asic resource tcam table acl | begin {INPUT_NAT}"""

    schema = {
                 'index':{
                     Any():{
                         'labels': {
                             Any(): {
                                 'vcu_results': int,
                                 'l3len': int,
                                 'l3pro': int,
                                 'l3tos': int,
                                 'srcaddr': int,
                                 'dstaddr': int,
                                 'mtrid': int,
                                 'vrfid': int,
                                 'sh': int,
                                 'mvid': int,
                                 'l3err': int
                              },
                         },
                        'nat_result_rm': int,
                        'nat_static_rule': int,
                        'nat_dynamic_rule': int
                        }
                   }
             }

# =========================================================================================================
#  Parser for show platform hardware fed switch active fwd-asic resource tcam table acl | begin {INPUT_NAT}
# =========================================================================================================
class ShowPlatformTcamAcl(ShowPlatformTcamAclSchema):
    """
    show platform hardware fed switch active fwd-asic resource tcam table acl | begin {INPUT_NAT}
    """

    cli_command = 'show platform hardware fed switch active fwd-asic resource tcam table acl | begin {INPUT_NAT}'

    def cli(self, INPUT_NAT, output=None):

        cmd = self.cli_command.format(INPUT_NAT=INPUT_NAT)

        if output is None:
            output = self.device.execute(cmd)

        # initial variables
        ret_dict = {}

        # Index-1152
        p0 = re.compile(r'Index-+(?P<index>\d+)$')

        # Labels vcuResults l3Len l3Pro l3Tos SrcAddr  DstAddr  mtrid vrfid  SH Mvid  l3Err
        # M:  00000000   0000  00    00  00000000 00000000  00   0000   0000 000   00
        # V:  00000000   0000  00    00  00000000 00000000  00   0000   0000 000   00
        p1 = re.compile(r'^(?P<labels>\S+) +'
                        r'(?P<vcu_results>\d+) +'
                        r'(?P<l3len>\d+) +'
                        r'(?P<l3pro>\d+) +'
                        r'(?P<l3tos>\d+) +'
                        r'(?P<srcaddr>\d+) +'
                        r'(?P<dstaddr>\d+) +'
                        r'(?P<mtrid>\d+) +'
                        r'(?P<vrfid>\d+) +'
                        r'(?P<sh>\d+) +'
                        r'(?P<mvid>\d+) +'
                        r'(?P<l3err>\d+)$')

        # natResultRm    natStaticRule     natDynamicRule
        # 1                1                  0
        p2 = re.compile(r'^(?P<nat_result_rm>\d+) +(?P<nat_static_rule>\d+) +(?P<nat_dynamic_rule>\d+)$')

        for line in output.splitlines():
            line = line.strip()

            # Index-1152
            m = p0.match(line)
            if m:
                group = m.groupdict()
                index = group['index']
                index_dict = ret_dict.setdefault('index', {}).setdefault(index, {})

            # Labels vcuResults l3Len l3Pro l3Tos SrcAddr  DstAddr  mtrid vrfid  SH Mvid  l3Err
            # M:  00000000   0000  00    00  00000000 00000000  00   0000   0000 000   00
            # V:  00000000   0000  00    00  00000000 00000000  00   0000   0000 000   00
            m = p1.match(line)
            if m:
                group = m.groupdict()
                labels = group['labels']
                label_dict = index_dict.setdefault('labels', {}).setdefault(labels, {})
                label_dict['vcu_results'] = int(group['vcu_results'])
                label_dict['l3len'] = int(group['l3len'])
                label_dict['l3pro'] = int(group['l3pro'])
                label_dict['l3tos'] = int(group['l3tos'])
                label_dict['srcaddr'] = int(group['srcaddr'])
                label_dict['dstaddr'] = int(group['dstaddr'])
                label_dict['mtrid'] = int(group['mtrid'])
                label_dict['vrfid'] = int(group['vrfid'])
                label_dict['sh'] = int(group['sh'])
                label_dict['mvid'] = int(group['mvid'])
                label_dict['l3err'] = int(group['l3err'])

            # natResultRm    natStaticRule     natDynamicRule
            # 1                1                  0
            m = p2.match(line)
            if m:
                group = m.groupdict()
                index_dict ['nat_result_rm'] = int(group['nat_result_rm'])
                index_dict ['nat_static_rule'] = int(group['nat_static_rule'])
                index_dict ['nat_dynamic_rule'] = int(group['nat_dynamic_rule'])

        return ret_dict

class ShowPlatformSoftwareCpmSwitchB0ControlInfoSchema(MetaParser):
    """
    Schema for show platform software cpm switch {mode} B0 control-info
    """
    schema = {
        'system_port': int,
        'svl_control_interface': {
            Any():{
                Any(): {
                'ec_if_id': str,
                'system_port': int,
                'if_type': str,
                },
            },
        },
    }

class ShowPlatformSoftwareCpmSwitchB0ControlInfo(ShowPlatformSoftwareCpmSwitchB0ControlInfoSchema):
    """ Parser for show platform software cpm switch {mode} B0 control-info"""

    cli_command = 'show platform software cpm switch {mode} B0 control-info'

    def cli(self, mode, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(mode=mode))

        # initial variables
        ret_dict = {}

        # System port: 98
        p1 = re.compile('^System port: (?P<system_port>\d+)$')

        # SVL Control Interface: HundredGigE1/0/2
        p2 = re.compile('^SVL Control Interface: (?P<svl_control_interface>\S+)$')

        # 27                  FiftyGigE1/0/56
        p1_2 = re.compile('^(?P<system_port>\s*\d+)\s+(?P<svl_control_interface>\S+)$')

        # 0x2c       0x2c     28       etherchannel
        p3 = re.compile('^(?P<if_id>\S+)\s+(?P<ec_if_id>\S+)\s+(?P<system_port>\d+)\s+(?P<if_type>\S+)$')

        for line in output.splitlines():
            line=line.strip()

            # System port: 98
            m=p1.match(line)
            if m:
                group=m.groupdict()
                ret_dict['system_port'] = int(group['system_port'])
                continue

            # SVL Control Interface: HundredGigE1/0/2
            m=p2.match(line)
            if m:
                group = m.groupdict()
                root_dict = ret_dict.setdefault('svl_control_interface',{})
                root_dict1 =root_dict.setdefault(group['svl_control_interface'],{})
                continue

            # 27                     FiftyGigE1/0/56
            m=p1_2.match(line)
            if  m:
                group=m.groupdict()
                ret_dict['system_port'] = int(group['system_port'])
                root_dict = ret_dict.setdefault('svl_control_interface',{})
                root_dict1 =root_dict.setdefault(group['svl_control_interface'],{})
                continue

            # 0x2c       0x2c     28       etherchannel
            m = p3.match(line)
            if m:
                group = m.groupdict()
                root_dict = root_dict1.setdefault(group['if_id'],{})
                root_dict['ec_if_id']=group['ec_if_id']
                root_dict['system_port']=int(group['system_port'])
                root_dict['if_type']=group['if_type']
                continue

        return ret_dict


class ShowPlatformSoftwareCpmSwitchB0ResourceSchema(MetaParser):
    """
    Schema for show platform software cpm switch {mode} B0 resource
    """
    schema = {
        'device_status':{
                'oobnd1': str,
                'leaba0_3': str,
                'leaba0_5': str
        },
    }

class ShowPlatformSoftwareCpmSwitchB0Resource(ShowPlatformSoftwareCpmSwitchB0ResourceSchema):
    """ Parser for show platform software cpm switch {mode} B0 resource"""

    cli_command = 'show platform software cpm switch {mode} B0 resource'

    def cli(self, mode, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(mode=mode))

        # initial variables
        ret_dict = {}

        # oobnd1          UP
        p1 = re.compile('^oobnd1\s+(?P<oobnd1>UP|DOWN)$')

        # leaba0_3        UP
        p2 = re.compile('^leaba0_3\s+(?P<leaba0_3>UP|DOWN)$')

        # leaba0_5        UP
        p3 = re.compile('^leaba0_5\s+(?P<leaba0_5>UP|DOWN)$')

        for line in output.splitlines():
            line = line.strip()

            # oobnd1          UP
            m = p1.match(line)
            if m:
                group = m.groupdict()
                root_dict=ret_dict.setdefault('device_status',{})
                root_dict['oobnd1']=group['oobnd1']
                continue

            # leaba0_3        UP
            m = p2.match(line)
            if m:
                group = m.groupdict()
                root_dict['leaba0_3']=group['leaba0_3']
                continue

            # leaba0_5        UP
            m = p3.match(line)
            if m:
                group = m.groupdict()
                root_dict['leaba0_5']=group['leaba0_5']
                continue

        return ret_dict


class ShowPlatformSoftwareFedSwitchActiveQosPolicyTargetSchema(MetaParser):
    ''' schema for
        * show platform software fed switch active qos policy target brief
    '''

    schema = {
        'tcg_sum_for_policy': {
            Any(): {
                'interface': {
                    Any(): {
                        'loc': str,
                        'iif_id': str,
                        'direction': str,
                        'tccg': int,
                        'child': int,
                        'mpq': str,
                        'state_cfg': str,
                        'state_opr': str,
                        'address': str
                    },
                }
            },
        }
    }

class ShowPlatformSoftwareFedSwitchActiveQosPolicyTarget(ShowPlatformSoftwareFedSwitchActiveQosPolicyTargetSchema):
    ''' parser for
            * show platform software fed switch active qos policy target brief
    '''

    cli_command = 'show platform software fed switch active qos policy target brief'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        ret_dict = {}

        # TCG summary for policy: system-cpp-policy
        p1 = re.compile(r'TCG\ssummary\sfor\spolicy:\s+(?P<policy>\S+)')
        # L:2 GigabitEthernet4/0/9  0x00000000000056  IN    4     0 3/2/0   VALID,SET_INHW  0x7fe0a79f0b88
        p2 = re.compile(
            r'(?P<loc>\S+)\s+(?P<interface>[\w\-\/\s]+)\s+(?P<iif_id>\S+)\s+(?P<direction>(OUT|IN))\s+(?P<tccg>\d+)\s+(?P<child>\d+)\s+(?P<mpq>[\w//]+)\s+(?P<state_cfg>\w+),(?P<state_opr>\S+)\s+(?P<address>\S+)')

        for line in output.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                if 'tcg_sum_for_policy' not in ret_dict:
                    sum_dict = ret_dict.setdefault('tcg_sum_for_policy', {})
                policy = str(group['policy'])
                sum_dict[policy] = {}
                sum_dict[policy]['interface'] = {}
                continue

            m = p2.match(line)
            if m:
                group = m.groupdict()
                interface = str(group['interface'])
                interface = interface.strip()
                sum_dict[policy]['interface'][interface] = {}
                sum_dict[policy]['interface'][interface]['loc'] = str(group['loc'])
                sum_dict[policy]['interface'][interface]['iif_id'] = str(group['iif_id'])
                sum_dict[policy]['interface'][interface]['direction'] = str(group['direction'])
                sum_dict[policy]['interface'][interface]['tccg'] = int(group['tccg'])
                sum_dict[policy]['interface'][interface]['child'] = int(group['child'])
                sum_dict[policy]['interface'][interface]['mpq'] = str(group['mpq'])
                sum_dict[policy]['interface'][interface]['state_cfg'] = str(group['state_cfg'])
                sum_dict[policy]['interface'][interface]['state_opr'] = str(group['state_opr'])
                sum_dict[policy]['interface'][interface]['address'] = str(group['address'])
                continue

        return ret_dict


# =====================================================================================
# Schema for 'show platform software object-manager switch active FP active statistics'
# =====================================================================================
class ShowPlatformSoftwareObjectManagerFpActiveStatisticsSchema(MetaParser):
    """ Schema for the commands:
            * show platform software object-manager switch {switchstate} {serviceprocessor} active statistics
            * show platform software object-manager FP active statistics
    """

    schema = {
                 'object_update':{
                     'pending_issue': int,
                     'pending_acknowledgement': int
                  },
                  'batch_begin':{
                      'pending_issue': int,
                      'pending_acknowledgement': int
                  },
                  'batch_end':{
                      'pending_issue': int,
                      'pending_acknowledgement': int
                  },
                  'command':{
                      'pending_acknowledgement': int
                  },
                  'total_objects': int,
                  'stale_objects': int,
                  'resolve_objects': int,
                  'childless_delete_objects': int,
                  'backplane_objects': int,
                  'error_objects': int,
                  'number_of_bundles': int,
                  'paused_types': int
             }

# ====================================================================================
#  Parser for show platform software object-manager switch active FP active statistics
# ====================================================================================
class ShowPlatformSoftwareObjectManagerFpActiveStatistics(ShowPlatformSoftwareObjectManagerFpActiveStatisticsSchema):
    """
    show platform software object-manager switch {switchstate} {serviceprocessor} active statistics
    show platform software object-manager FP active statistics
    """

    cli_command = ['show platform software object-manager switch {switchstate} {serviceprocessor} active statistics',
                   'show platform software object-manager FP active statistics']

    def cli(self, switchstate="", serviceprocessor="", output=None):

        if output is None:
            if switchstate:
                cmd = self.cli_command[0].format(switchstate=switchstate,serviceprocessor=serviceprocessor)
            else:
                cmd = self.cli_command[1]

            output = self.device.execute(cmd)

        # initial variables
        ret_dict = {}

        #Object update: Pending-issue: 7083, Pending-acknowledgement: 14101
        p0 = re.compile(r'^Object update: +Pending-issue: +(?P<pending_issue>\d+), +Pending-acknowledgement: +(?P<pending_acknowledgement>\d+)$')

        # Batch begin:   Pending-issue: 0, Pending-acknowledgement: 0
        p1 = re.compile(r'^Batch begin: + Pending-issue: +(?P<pending_issue>\d)+, +Pending-acknowledgement: +(?P<pending_acknowledgement>\d+)$')

        # Batch end:     Pending-issue: 0, Pending-acknowledgement: 0
        p2 = re.compile(r'^Batch end: + Pending-issue: +(?P<pending_issue>\d)+, +Pending-acknowledgement: +(?P<pending_acknowledgement>\d+)$')

        # Command:       Pending-acknowledgement: 54
        p3 = re.compile(r'^Command: + Pending-acknowledgement: +(?P<pending_acknowledgement>\d+)$')

        # Total-objects: 30105
        p4 = re.compile(r'^Total-objects: +(?P<total_objects>\d+)$')

        # Stale-objects: 0
        p5 = re.compile(r'^Stale-objects: +(?P<stale_objects>\d+)$')

        # Resolve-objects: 0
        p6 = re.compile(r'^Resolve-objects: +(?P<resolve_objects>\d+)$')

        # Childless-delete-objects: 0
        p7 = re.compile(r'^Childless-delete-objects: +(?P<childless_delete_objects>\d+)$')

        # Backplane-objects: 0
        p8 = re.compile(r'^Backplane-objects: +(?P<backplane_objects>\d+)$')

        # Error-objects: 0
        p9 = re.compile(r'^Error-objects: +(?P<error_objects>\d+)$')

        # Number of bundles: 0
        p10 = re.compile(r'^Number of bundles: +(?P<number_of_bundles>\d+)$')

        # Paused-types: 0
        p11 = re.compile(r'^Paused-types: +(?P<paused_types>\d+)$')

        for line in output.splitlines():
            line = line.strip()

            # Object update: Pending-issue: 7083, Pending-acknowledgement: 14101
            m = p0.match(line)
            if m:
                group = m.groupdict()
                object_update = ret_dict.setdefault('object_update', {})
                object_update['pending_issue'] = int(group['pending_issue'])
                object_update['pending_acknowledgement'] = int(group['pending_acknowledgement'])

            # Batch begin:   Pending-issue: 0, Pending-acknowledgement: 0
            m = p1.match(line)
            if m:

                group = m.groupdict()
                batch_begin = ret_dict.setdefault('batch_begin', {})
                batch_begin['pending_issue'] = int(group['pending_issue'])
                batch_begin['pending_acknowledgement'] = int(group['pending_acknowledgement'])

            # Batch end:     Pending-issue: 0, Pending-acknowledgement: 0
            m = p2.match(line)
            if m:
                 group = m.groupdict()
                 batch_end = ret_dict.setdefault('batch_end', {})
                 batch_end['pending_issue'] = int(group['pending_issue'])
                 batch_end['pending_acknowledgement'] = int(group['pending_acknowledgement'])

            # Command:       Pending-acknowledgement: 54
            m = p3.match(line)
            if m:
               group = m.groupdict()
               command = ret_dict.setdefault('command', {})
               command['pending_acknowledgement'] = int(group['pending_acknowledgement'])

            # Total-objects: 30105
            m = p4.match(line)
            if m:
                group = m.groupdict()
                ret_dict['total_objects'] = int(group['total_objects'])

            # Stale-objects: 0
            m = p5.match(line)
            if m:
                group = m.groupdict()
                ret_dict['stale_objects'] = int(group['stale_objects'])

            # Resolve-objects: 0
            m = p6.match(line)
            if m:
                group = m.groupdict()
                ret_dict['resolve_objects'] = int(group['resolve_objects'])

            # Childless-delete-objects: 0
            m = p7.match(line)
            if m:
                group = m.groupdict()
                ret_dict['childless_delete_objects'] = int(group['childless_delete_objects'])

            # Backplane-objects: 0
            m = p8.match(line)
            if m:
                group = m.groupdict()
                ret_dict['backplane_objects'] = int(group['backplane_objects'])

            # Error-objects: 0
            m = p9.match(line)
            if m:
                group = m.groupdict()
                ret_dict['error_objects'] = int(group['error_objects'])

            # Number of bundles: 0
            m = p10.match(line)
            if m:
                group = m.groupdict()
                ret_dict['number_of_bundles'] = int(group['number_of_bundles'])

            # Paused-types: 0
            m = p11.match(line)
            if m:
                group = m.groupdict()
                ret_dict['paused_types'] = int(group['paused_types'])

        return ret_dict


class ShowPlatformSoftwareInstallManagerRpActiveOperationHistorySummarySchema(MetaParser):
    """
    Schema for show platform software install-manager RP active operation history summary
    """
    schema = {
        'operation_summary': {
                Any(): {
                    'uuid': str,
                    'op_id': int,
                    'command': str,
                    'status': str,
                    'duration': str,
                    'start_date': str,
                    'start_time': str,
                    'end_date': str,
                    'end_time': str,
                }
        },
    }


class ShowPlatformSoftwareInstallManagerRpActiveOperationHistorySummary(ShowPlatformSoftwareInstallManagerRpActiveOperationHistorySummarySchema):
    """
    Parser for show platform software install-manager RP active operation history summary
    """

    cli_command = 'show platform software install-manager RP active operation history summary'

    def cli(self, output=None):

        if output is None:
            output = self.device.execute(self.cli_command)

        # initial return dictionary
        ret_dict = {}
        index = 0
        # 2021_11_02_06_50_44_op_rollback  1        rollback     Fail    00:00:04   [2021-11-02 06:50:44 - 2021-11-02 06:50:48]
        p1 = re.compile(r'(?P<uuid>\S*)\s*(?P<op_id>\d+)\s*(?P<command>\S*)\s*(?P<status>\w+)\s*(?P<duration>\d+:\d+:\d+)\s*'
                        r'\[(?P<start_date>\d+-\d+-\d+)\s*(?P<start_time>\d+:\d+:\d+)\s*-\s*(?P<end_date>\d+-\d+-\d+)\s*'
                        r'(?P<end_time>\d+:\d+:\d+)\]')

        for line in output.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                index += 1
                uuid_dict = ret_dict.setdefault('operation_summary', {}).setdefault(index, {})
                uuid_dict.update({'uuid': group['uuid']})
                uuid_dict.update({'op_id': int(group['op_id'])})
                uuid_dict.update({'command': group['command']})
                uuid_dict.update({'status': group['status']})
                uuid_dict.update({'duration': group['duration']})
                uuid_dict.update({'start_date': group['start_date']})
                uuid_dict.update({'start_time': group['start_time']})
                uuid_dict.update({'end_date': group['end_date']})
                uuid_dict.update({'end_time': group['end_time']})

        return ret_dict


class ShowPlatformSoftwareInstallManagerSwitchActiveR0OperationHistorySummarySchema(MetaParser):
    """
    Schema for show platform software install-manager switch active r0 operation history summary
    """
    schema = {
        'operation_summary': {
                Any(): {
                    'uuid': str,
                    'op_id': int,
                    'command': str,
                    'status': str,
                    'duration': str,
                    'start_date': str,
                    'start_time': str,
                    'end_date': str,
                    'end_time': str,
                }
        },
    }


class ShowPlatformSoftwareInstallManagerSwitchActiveR0OperationHistorySummary(ShowPlatformSoftwareInstallManagerSwitchActiveR0OperationHistorySummarySchema):
    """
    Parser for show platform software install-manager switch active r0 operation history summary
    """

    cli_command = 'show platform software install-manager switch active r0 operation history summary'

    def cli(self, output=None):

        if output is None:
            output = self.device.execute(self.cli_command)

        # initial return dictionary
        ret_dict = {}
        index = 0
        # 2021_11_02_06_50_44_op_rollback  1        rollback     Fail    00:00:04   [2021-11-02 06:50:44 - 2021-11-02 06:50:48]
        p1 = re.compile(r'(?P<uuid>\S*)\s*(?P<op_id>\d+)\s*(?P<command>\S*)\s*(?P<status>\w+)\s*(?P<duration>\d+:\d+:\d+)\s*'
                        r'\[(?P<start_date>\d+-\d+-\d+)\s*(?P<start_time>\d+:\d+:\d+)\s*-\s*(?P<end_date>\d+-\d+-\d+)\s*'
                        r'(?P<end_time>\d+:\d+:\d+)\]')

        for line in output.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                index += 1
                uuid_dict = ret_dict.setdefault('operation_summary', {}).setdefault(index, {})
                uuid_dict.update({'uuid': group['uuid']})
                uuid_dict.update({'op_id': int(group['op_id'])})
                uuid_dict.update({'command': group['command']})
                uuid_dict.update({'status': group['status']})
                uuid_dict.update({'duration': group['duration']})
                uuid_dict.update({'start_date': group['start_date']})
                uuid_dict.update({'start_time': group['start_time']})
                uuid_dict.update({'end_date': group['end_date']})
                uuid_dict.update({'end_time': group['end_time']})

        return ret_dict


class ShowVersionRunningSchema(MetaParser):
    """show version running."""

    schema = {
       'version_running': {
           Any(): {
               'package': str,
               'version': str,
               'status': str,
               'role': str,
               'file': str,
               'on': str,
               'built': str,
               'by': str,
               'file_sha_checksum': str
           }
       }
    }


class ShowVersionRunning(ShowVersionRunningSchema):
    """show version running"""

    cli_command = ["show version running"]

    def cli(self, output=None):
        if output is None:
            # get output from device
            output = self.device.execute(self.cli_command[0])

        # initial return dictionary
        ret_dict = {}
        index = 0

        # initial regexp pattern
        # Package: Provisioning File, version: n/a, status: active
        p1 = re.compile(r'^Package: +(?P<package>[\w+\s+\w]+)+, +version: (?P<version>\S+)+, status: (?P<status>\S+)$')

        # Role: provisioning file
        p2 = re.compile(r'^Role: +(?P<role>[\w+\s+\w]+)$')

        # File: bootflash:cat9k-rpbase.BLD_POLARIS_DEV_LATEST_20211115_013205.SSA.pkg, on: RP0
        p3 = re.compile(r'^File: +(?P<file>\S+)+, on: (?P<on>\S+)$')

        # Built: 2021-11-14_18.31, by: mcpre
        p4 = re.compile(r'^Built: +(?P<built>\S+)+, by: (?P<by>\S+)$')

        # File SHA1 checksum: 69c0fe122c9f0885021f874875caeba46a2c6d07
        p5 = re.compile(r'^File SHA1 checksum: +(?P<file_sha_checksum>\S+)$')

        for line in output.splitlines():
            line = line.strip()

            # Last configuration file parsed
            m = p1.match(line)
            if m:
                group = m.groupdict()
                index += 1
                ver = ret_dict.setdefault('version_running', {}).setdefault(index, {})
                ver.update({'package': group['package']})
                ver.update({'version': group['version']})
                ver.update({'status': group['status']})
                continue

            m = p2.match(line)
            if m:
                group = m.groupdict()
                ver.update({'role': group['role']})
                continue

            m = p3.match(line)
            if m:
                group = m.groupdict()
                ver.update({'file': group['file']})
                ver.update({'on': group['on']})
                continue

            m = p4.match(line)
            if m:
                group = m.groupdict()
                ver.update({'built': group['built']})
                ver.update({'by': group['by']})
                continue

            m = p5.match(line)
            if m:
                group = m.groupdict()
                ver.update({'file_sha_checksum': group['file_sha_checksum']})
                continue

        return ret_dict

# ==========================================
# Schema for
#   'show call admission statistics'
#   'show call admission statistics detailed'
# ===========================================

class ShowCallAdmissionStatisticsSchema(MetaParser):
    """
    Schema for
        * 'show call admission statistics'
        * 'show call admission statistics detailed'
    """

    schema = {
        'cac_status': str,
        'cac_state': str,
        'calls_rejected': int,
        'cac_duration': int,
        'calls_accepted': int,
        Optional('total_call_session_charges'): int,
        Optional('call_limit'): int,
        Optional('current_actual_cpu'): int,
        Optional('cpu_limit'): int,
        Optional('fsol_packet_drop'): int,
        Optional('cac_events'): {
            Optional("reject_reason"): {
                Optional('cpu_limit'): {
                    Optional('times_of_activation'): int,
                    Optional('duration_of_activation'): int,
                    Optional('rejected_calls'): int
                },
                Optional('session_charges'): {
                    Optional('times_of_activation'): int,
                    Optional('duration_of_activation'): int,
                    Optional('rejected_calls'): int
                },
                Optional('low_platform_resources'): {
                    Optional('times_of_activation'): int,
                    Optional('duration_of_activation'): int,
                    Optional('rejected_calls'): int
                },
                Optional('session_limit'): {
                    Optional('times_of_activation'): int,
                    Optional('duration_of_activation'): int,
                    Optional('rejected_calls'): int
                }
            }
        }
    }

class ShowCallAdmissionStatistics(ShowCallAdmissionStatisticsSchema):
    """
    Parser for
        * 'show call admission statistics'
        * 'show call admission statistics detailed'
    """
    cli_command = ['show call admission statistics']

    def cli(self, output=None):
        cmd = self.cli_command[0]

        if output is None:
            output = self.device.execute(self.cli_command[0])

        res_dict = {}
        # CAC New Model (SRSM) is ACTIVE
        p1 = re.compile(r'^CAC New Model \(SRSM\) is (?P<state>\w+)$')

        # CAC statistics duration:  2(seconds)
        p2 = re.compile(r'^CAC statistics duration:  (?P<duration>\d+)'
                        r'\(seconds\)$')

        # Total calls rejected 0, accepted 0
        p3 = re.compile(r'^Total calls rejected (?P<rejected>\d+), '
                        r'accepted (?P<accepted>\d+)$')

        # Current hardware CAC status is: Not Dropping
        p4 = re.compile(r'^Current hardware CAC status is: '
                        r'(?P<status>\w+\s?\w+)$')

        # Total call Session charges: 0, limit 350
        p5 = re.compile(r'^Total call Session charges: (?P<total_call_session_charges>'
                        r'\d+), limit (?P<call_limit>\d+)$')

        # CPU utilization: Five Sec Average CPU Load, Current actual CPU: 3%, Limit: 80%
        p6 = re.compile(r'^CPU utilization: Five Sec Average CPU Load, Current actual '
                        r'CPU: (?P<current_actual_cpu>\d+)%, Limit: (?P<cpu_limit>\d+)%$')

        # CPU-limit:              3354                116                  33541234
        p7 = re.compile(r'^CPU-limit:\s+(?P<times_of_activation>\d+)\s+'
                        r'(?P<duration_of_activation>\d+)\s+(?P<rejected_calls>\d+)$')

        # SessionCharges:          27                  0                    27
        p8 = re.compile(r'^SessionCharges:\s+(?P<times_of_activation>\d+)\s+'
                        r'(?P<duration_of_activation>\d+)\s+(?P<rejected_calls>\d+)$')

        # LowPlatformResource:     0                   0                     0
        p9 = re.compile(r'^LowPlatformResource:\s+(?P<times_of_activation>\d+)\s+'
                        r'(?P<duration_of_activation>\d+)\s+(?P<rejected_calls>\d+)$')

        # Session Limit:         9876543               0                     0
        p10 = re.compile(r'^Session Limit:\s+(?P<times_of_activation>\d+)\s+'
                         r'(?P<duration_of_activation>\d+)\s+(?P<rejected_calls>\d+)$')

        # Total dropped FSOL packets at data plane: 0
        p11 = re.compile(r'^Total dropped FSOL packets at data plane: (?P<fsol_drop>\d+)$')
        for line in output.splitlines():
            line = line.strip()

            # CAC New Model (SRSM) is ACTIVE
            m = p1.match(line)
            if m:
                groups = m.groupdict()
                res_dict['cac_state'] = groups['state']
                continue

            # CAC statistics duration:  2(seconds)
            m = p2.match(line)
            if m:
                groups = m.groupdict()
                res_dict['cac_duration'] = int(groups['duration'])
                continue

            # Total calls rejected 0, accepted 0
            m = p3.match(line)
            if m:
                groups = m.groupdict()
                res_dict['calls_rejected'] = int(groups['rejected'])
                res_dict['calls_accepted'] = int(groups['accepted'])
                continue

            # Total calls rejected 0, accepted 0
            m = p4.match(line)
            if m:
                groups = m.groupdict()
                res_dict['cac_status'] = groups['status']
                continue

            # Total call Session charges: 0, limit 350
            m = p5.match(line)
            if m:
                groups = m.groupdict()
                res_dict['total_call_session_charges'] = int(groups['total_call_session_charges'])
                res_dict['call_limit'] = int(groups['call_limit'])
                continue

            # CPU utilization: Five Sec Average CPU Load, Current actual CPU: 3%, Limit: 80%
            m = p6.match(line)
            if m:
                groups = m.groupdict()
                res_dict['current_actual_cpu'] = int(groups['current_actual_cpu'])
                res_dict['cpu_limit'] = int(groups['cpu_limit'])
                continue

            # CPU-limit:         3354            116                3354
            m = p7.match(line)
            if m:
                res_dict.setdefault('cac_events', {})
                res_dict['cac_events'].setdefault('reject_reason', {})
                res_dict['cac_events']['reject_reason'].setdefault('cpu_limit', {})
                groups = m.groupdict()
                res_dict['cac_events']['reject_reason']['cpu_limit'] \
                    ['times_of_activation'] = int(groups['times_of_activation'])
                res_dict['cac_events']['reject_reason']['cpu_limit'] \
                    ['duration_of_activation'] = int(groups['duration_of_activation'])
                res_dict['cac_events']['reject_reason']['cpu_limit'] \
                    ['rejected_calls'] = int(groups['rejected_calls'])

            # SessionCharges:                  27                     0                          27
            m = p8.match(line)
            if m:
                res_dict.setdefault('cac_events', {})
                res_dict['cac_events'].setdefault('reject_reason', {})
                res_dict['cac_events']['reject_reason'].setdefault('session_charges', {})
                groups = m.groupdict()
                res_dict['cac_events']['reject_reason']['session_charges'] \
                    ['times_of_activation'] = int(groups['times_of_activation'])
                res_dict['cac_events']['reject_reason']['session_charges'] \
                    ['duration_of_activation'] = int(groups['duration_of_activation'])
                res_dict['cac_events']['reject_reason']['session_charges'] \
                    ['rejected_calls'] = int(groups['rejected_calls'])

            # LowPlatformResource:             0                      0                          0
            m = p9.match(line)
            if m:
                res_dict.setdefault('cac_events', {})
                res_dict['cac_events'].setdefault('reject_reason', {})
                res_dict['cac_events']['reject_reason'].setdefault('low_platform_resources', {})
                groups = m.groupdict()
                res_dict['cac_events']['reject_reason']['low_platform_resources'] \
                    ['times_of_activation'] = int(groups['times_of_activation'])
                res_dict['cac_events']['reject_reason']['low_platform_resources'] \
                    ['duration_of_activation'] = int(groups['duration_of_activation'])
                res_dict['cac_events']['reject_reason']['low_platform_resources'] \
                    ['rejected_calls'] = int(groups['rejected_calls'])

            # Session Limit:                   0                      0                          0
            m = p10.match(line)
            if m:
                res_dict.setdefault('cac_events', {})
                res_dict['cac_events'].setdefault('reject_reason', {})
                res_dict['cac_events']['reject_reason'].setdefault('session_limit', {})
                groups = m.groupdict()
                res_dict['cac_events']['reject_reason']['session_limit'] \
                    ['times_of_activation'] = int(groups['times_of_activation'])
                res_dict['cac_events']['reject_reason']['session_limit'] \
                    ['duration_of_activation'] = int(groups['duration_of_activation'])
                res_dict['cac_events']['reject_reason']['session_limit'] \
                    ['rejected_calls'] = int(groups['rejected_calls'])

            # Total dropped FSOL packets at data plane: 0
            m = p11.match(line)
            if m:
                groups = m.groupdict()
                res_dict['fsol_packet_drop'] = int(groups['fsol_drop'])

        return res_dict

class ShowCallAdmissionStatisticsDetailed(ShowCallAdmissionStatistics):
    ''' Parser for:
           * show call admission statistics detailed
    '''
    cli_command = ['show call admission statistics detailed']

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command[0])

        return super().cli(output=output)

# =======================================================================================================
#  Schema for:
#  * 'show platform software fed switch {switch_no} security-fed dhcp-snoop vlan vlan-id {vlan_id}'
# =======================================================================================================

class ShowPlatformSoftwareFedSwitchSecurityfedDhcpsnoopVlanVlanidSchema(MetaParser):

    """Schema for show platform software fed switch {switch_no} security-fed dhcp-snoop vlan vlan-id {vlan_id}"""

    schema = {
        'trust_status': str,
        'vlan' : int,
        'snooping_handle' : str,
        Optional('interfaces') : {
            Any() : {
                Optional('port') : str,
                Optional('mode') : str
            },
        }
    }

# =======================================================================================================
#  parser for:
#  *'show platform software fed switch {switch_no} security-fed dhcp-snoop vlan vlan-id {vlan_id}'
# =======================================================================================================

class ShowPlatformSoftwareFedSwitchSecurityfedDhcpsnoopVlanVlanid(

    ShowPlatformSoftwareFedSwitchSecurityfedDhcpsnoopVlanVlanidSchema):

    """Parser for show platform software fed switch {switch_no} security-fed dhcp-snoop vlan vlan-id {vlan_id}"""

    cli_command = 'show platform software fed switch {switch_no} security-fed dhcp-snoop vlan vlan-id {vlan_id}'

    def cli(self, switch_no, vlan_id, output=None):

        if output is None:

            output = self.device.execute(self.cli_command.format(switch_no=switch_no,vlan_id=vlan_id))

        ret_dict = {}

        # DHCP Snooping disabled on vlan: 100
        p = re.compile(r'DHCP\s+Snooping\s+disabled\s+on\s+vlan\s*:\s*(?P<vlan>\d+)')

        # Valid Snooping DI handle:none
        p1 = re.compile(r'Valid\s+Snooping\s+DI\s+handle\s*:\s*(?P<snooping_handle>\S+)')

        # No trust ports for this vlan
        p2 = re.compile(r'No\s+trust\s+ports\s+for\s+this\s+vlan')

        # GigabitEthernet1/0/3             trust
        p3 = re.compile(r'(?P<port>.*\d+\/\d+\/\d+)\s+(?P<mode>\S+)')

        for line in output.splitlines():
            line = line.strip()

            # DHCP Snooping disabled on vlan: 100
            m = p.match(line)
            if m:
                ret_dict['vlan'] = int(m.group(1))
                continue

            # Valid Snooping DI handle:none
            m1 = p1.match(line)
            if m1:
                ret_dict['snooping_handle'] = m1.group(1)
                continue

            # No trust ports for this vlan
            m2 = p2.match(line)
            if m2:
                ret_dict['trust_status'] = 'no'
                return ret_dict

            #  GigabitEthernet1/0/3             trust
            m3 = p3.match(line)
            if m3:
                group   = m3.groupdict()
                intf_dict = ret_dict.setdefault('interfaces', {}).setdefault(group.pop('port'),{})
                intf_dict.update({k: v for k, v in group.items()})
                ret_dict['trust_status'] = 'yes'
                continue

        return ret_dict

# ====================================================
#  Schema for :
#  * 'show rep topology segment {no}'
# ====================================================

class ShowRepTopologySegmentSchema(MetaParser):
    """Schema for show rep topology segment {no}"""
    schema = {
        'interfaces' : {
            Any() : {
                'port' : str,
                'bridge' : str,
                'edge' : str,
                'role' : str
            },
        }
    }

# ====================================================
#  Parser for :
#  * 'show rep topology segment {no}'
# ====================================================

class ShowRepTopologySegment(ShowRepTopologySegmentSchema):

    """Parser for show rep topology segment {no}"""

    cli_command = 'show rep topology segment {no}'

    def cli(self, no, output=None):

        if output is None:
            output = self.device.execute(self.cli_command.format(no=no))

        ret_dict = {}

        # fr1                              Tw2/0/3    Pri* Alt
        # fr1                              Gi1/0/3    Sec* Open
        p1 = re.compile(r'(?P<bridge>\S+)\s+(?P<interface>[a-z|A-Z]+\d+\/\d+\/\d+)\s+(?P<edge>\S+)\s+(?P<role>\S+)')

        for line in output.splitlines():

            line = line.strip()

            # fr1                              Tw2/0/3    Pri* Alt
            # fr1                              Gi1/0/3    Sec* Open
            m = p1.match(line)
            if m:
                group = m.groupdict()
                intf = Common.convert_intf_name(group.pop('interface'))

                intf_dict = ret_dict.setdefault('interfaces', {}).setdefault(intf, {})

                intf_dict['port'] = intf
                intf_dict.update({k: v for k, v in group.items()})

                continue

        return ret_dict

class ShowPlatformHardwareFedActiveVlanIngressSchema(MetaParser):

    """Schema for show platform hardware fed active vlan {num} ingress"""
    schema = {
        'vlan_id' : int,
        'forwarding_state' : {
            'tagged_list' : list,
            'untagged_list' : list
        },
        'flood_list':list
    }

class ShowPlatformHardwareFedActiveVlanIngress(

    ShowPlatformHardwareFedActiveVlanIngressSchema):

    """Parser for show platform hardware fed active vlan {num} ingress"""

    cli_command = 'show platform hardware fed active vlan {num} ingress'

    def cli(self, num, output=None):

        if output is None:
            output = self.device.execute(self.cli_command.format(num=num))
        ret_dict = {}

        # vlan id is:: 1
        p1 = re.compile(r'^vlan\s+id\s+is::\s* (?P<vlan_id>\d+)')

        # Interfaces in forwarding state: : Gi1/0/15(Tagged), Fo5/0/9(Untagged)
        p2 = re.compile(r'^Interfaces\s+in\s+forwarding state\s*:\s*:\s*(?P<forwarding_state>[\w\/\.\s\(\w\)\,]+)$')

        # flood list: : Gi1/0/15, Fo5/0/9
        p3 = re.compile(r'^flood\s+list\s*:\s+:\s+(?P<flood_list>([\w\/\.\s\,]+)$)')

        # Gi1/0/15
        p4 = re.compile(r'^(?P<intf>([\w\/\.\s]+))')

        for line in output.splitlines():
            line = line.strip()

            # vlan id is:: 1
            m1 = p1.match(line)
            if m1:
                group = m1.groupdict()
                ret_dict["vlan_id"] = int(group["vlan_id"])

            # Interfaces in forwarding state: : Gi1/0/15(Tagged), Fo5/0/9(Untagged)
            m2 = p2.match(line)
            if m2:
                group = m2.groupdict()
                for intf in group['forwarding_state'].split(', '):
                    intf_match = p4.match(intf)
                    ret_dict.setdefault('forwarding_state', {}).setdefault('tagged_list',[])
                    ret_dict['forwarding_state'].setdefault('untagged_list',[])

                    ret_dict['forwarding_state'].setdefault('untagged_list',[])
                    if ('Tagged' in intf) and (intf_match):
                        ret_dict['forwarding_state']['tagged_list'].append(Common.convert_intf_name(intf_match["intf"]))
                    if ('Untagged' in intf) and (intf_match):
                        ret_dict['forwarding_state']['untagged_list'].append(Common.convert_intf_name(intf_match["intf"]))

            # flood list: : Gi1/0/15, Fo5/0/9
            m3 = p3.match(line)
            if m3:
                flood_list_group = m3.groupdict()
                for interface in flood_list_group['flood_list'].split(', '):
                    intf_match = p4.match(interface)
                    ret_dict.setdefault('flood_list',[])
                    if intf_match:
                        ret_dict['flood_list'].append(Common.convert_intf_name(intf_match['intf']))
        return ret_dict

class ShowPlatformSoftwareFedActiveSecurityFedSchema(MetaParser):

    ''' Schema for "show platform software fed {switch} active security-fed sis-redirect firewall all"
        show platform software fed active security-fed sis-redirect firewall all'''

    schema = {
        'service_ip': {
            Any(): {
                'service_id': int,
                'vrf_id': int,
                'firewall_ip': str,
                'redirect_hd1': str,
                'hmt_hd1': str,
            }
        }
    }

class ShowPlatformSoftwareFedActiveSecurityFed(ShowPlatformSoftwareFedActiveSecurityFedSchema):
    """Schema for show platform software fed {switch} active security-fed sis-redirect firewall all"""

    cli_command = ['show platform software fed {switch} active security-fed sis-redirect firewall all',
                   'show platform software fed active security-fed sis-redirect firewall all']

    def cli(self, switch='', output=None):
        if output is None:
            if not switch:
                cmd = self.cli_command[1]
            else:
                cmd = self.cli_command[0].format(switch=switch)
            output = self.device.execute(cmd)

        parsed_dict = {}
        # Printing firewall information
        # ---------------------------------------------------------------------------
        # | Service ID  | VRF ID  | IP            | Redirect Hdl    | HTM Hdl       |
        # ---------------------------------------------------------------------------
        #  3861840337    0         172.18.0.2      0x7fe0bb341f38    0x7fe0bb2f27d8
        #  3861840137    2         172.18.0.6      0x7fe0bb334788    0x7fe0bb67c118
        # ---------------------------------------------------------------------------

        #  3861840337    0         172.18.0.2      0x7fe0bb341f38    0x7fe0bb2f27d8
        p1 = re.compile(r"^(?P<service_id>\d+)\s+(?P<vrf_id>\d+)\s+(?P<firewall_ip>[\d.]+)\s+(?P<redirect_hd1>0x[\da-f]+)\s+(?P<hmt_hd1>0x[\da-f]+)$")

        for line in output.splitlines():
            line = line.strip()

            #  3861840337    0         172.18.0.2      0x7fe0bb341f38    0x7fe0bb2f27d8
            m = p1.match(line)
            if m:
                groups = m.groupdict()
                service_id = int(groups['service_id'])
                vrf_id = int(groups['vrf_id'])
                firewall_ip = groups['firewall_ip']
                redirect_hd1 = groups['redirect_hd1']
                hmt_hd1 = groups['hmt_hd1']
                service_ip_dict = parsed_dict.setdefault('service_ip', {})

                firewall_ip_dict=service_ip_dict.setdefault(firewall_ip, {})
                firewall_ip_dict.update({
                    'service_id': service_id,
                    'vrf_id': vrf_id,
                    'firewall_ip': firewall_ip,
                    'redirect_hd1': redirect_hd1,
                    'hmt_hd1': hmt_hd1
                })
                continue

        return parsed_dict

class ShowPlatformSoftwareFedActiveSecurityFedAclAllSchema(MetaParser):

    ''' Schema for "show platform software fed {switch} active security-fed sis-redirect acl all" '''

    schema = {
        'firewall_id': {
            Any(): {
                'seq_no': {
                    Any(): {
                        'acl_id': int,
                        'firewall_id': int,
                        'stats_handle': str,
                        'frame_count': int,
                        'hardware_count': int,
                    },
                },
            }
        },
        'number_of_aces': int,
        'number_of_acls': int,
    }

class ShowPlatformSoftwareFedActiveSecurityFedAclAll(ShowPlatformSoftwareFedActiveSecurityFedAclAllSchema):
    """Schema for show platform software fed {switch} active security-fed sis-redirect acl all"""

    cli_command = ['show platform software fed {switch} active security-fed sis-redirect acl all',
                   'show platform software fed active security-fed sis-redirect acl all']

    def cli(self, switch='', output=None):
        if output is None:
            if not switch:
                cmd = self.cli_command[1]
            else:
                cmd = self.cli_command[0].format(switch=switch)
            output = self.device.execute(cmd)

        parsed_dict = {}

        # ------------------------------------------------------------------------------------------------
        # | ACL ID    | Seq no  | Firewall ID | Stats Handle |     Frame Count     |     Hw-Stats        |
        # ------------------------------------------------------------------------------------------------
        #  1405908841   1         1252352985    0x370000cb                   9862                   9862
        # ------------------------------------------------------------------------------------------------
        # Number of ACE's: 1
        # Number of ACL's: 1

        #  1405908841   1         1252352985    0x370000cb                   9862                   9862
        p1 = re.compile(r"^(?P<acl_id>\d+)\s+(?P<seq_number>\d+)\s+(?P<firewall_id>[\d.]+)\s+(?P<stats_handle>0x[\da-f]+)\s+(?P<frame_count>\d+)\s+(?P<hardware_count>\d+)$")

        # Number of ACE's: 1
        p2 = re.compile(r"^Number of ACE's\s*:\s*(?P<number_of_aces>\d+)$")

        # Number of ACL's: 1
        p3 = re.compile(r"^Number of ACL's\s*:\s*(?P<number_of_acls>\d+)$")

        for line in output.splitlines():
            line = line.strip()

            #  1405908841   1         1252352985    0x370000cb                   9862                   9862
            m = p1.match(line)
            if m:
                groups = m.groupdict()
                acl_id = int(groups['acl_id'])
                seq_number = int(groups['seq_number'])
                firewall_id = int(groups['firewall_id'])
                stats_handle = groups['stats_handle']
                frame_count = int(groups['frame_count'])
                hardware_count = int(groups['hardware_count'])
                firewall_id_dict = parsed_dict.setdefault('firewall_id', {})
                acl_dict = firewall_id_dict.setdefault(firewall_id, {}).setdefault('seq_no', {})
                seq_dict=acl_dict.setdefault(seq_number, {})
                seq_dict.update({
                    'acl_id': acl_id,
                    'firewall_id': firewall_id,
                    'stats_handle': stats_handle,
                    'frame_count': frame_count,
                    'hardware_count': hardware_count
                })
                continue

            # Number of ACE's: 1
            m = p2.match(line)
            if m:
                groups = m.groupdict()
                parsed_dict['number_of_aces'] = int(groups['number_of_aces'])
                continue

            # Number of ACL's: 1
            m = p3.match(line)
            if m:
                groups = m.groupdict()
                number_of_acls = int(groups['number_of_acls'])
                parsed_dict['number_of_acls'] = number_of_acls
                continue

        return parsed_dict

class ShowPlatformSoftwareFedActiveSecurityFedServiceDetailSchema(MetaParser):

    ''' Schema for "show platform software fed {switch} active security-fed sis-redirect firewall service-id {service_id} detail" '''

    schema = {
        'service_id': str,
        'vrf_id': str,
        'firewall_ip': str,
        'redirect_hd1': str,
        'hmt_hd1': str,
        'router_prefix': str,
        'next_hop': str,
        'adj_last_modified': str,
        'adj_oce_type': str,
        'adj_oce_sub_type': str,

    }

class ShowPlatformSoftwareFedActiveSecurityFedServiceDetail(ShowPlatformSoftwareFedActiveSecurityFedServiceDetailSchema):
    """Schema for show platform software fed {switch} active security-fed sis-redirect firewall service-id {service_id} detail"""

    cli_command = ['show platform software fed {switch} active security-fed sis-redirect firewall service-id {service_id} detail',
                   'show platform software fed active security-fed sis-redirect firewall service-id {service_id} detail']

    def cli(self, service_id, switch='', output=None):
        if output is None:
            if not switch:
                cmd = self.cli_command[1].format(service_id=service_id)
            else:
                cmd = self.cli_command[0].format(service_id=service_id,switch=switch)
            output = self.device.execute(cmd)

        parsed_dict = {}

        # Service ID               : 3861840337
        # VRF ID                   : 0
        # IP                       : 172.18.0.2/32
        # Redirect Hdl             : 0x7fe0bb341f38
        # HTM Hdl                  : 0x7fe0bb2f27d8
        # Route Prefix             : 172.18.0.0/30
        # Next Hop                 : 60.60.60.62
        # Adj Last Modified        : 2021-10-17,06:43:16
        # Adj OCE Type             : ADJ
        # Adj OCE Sub-Type         : NONE

        # Service ID               : 3861840337
        p1 = re.compile(r"^Service ID\s+:\s+(?P<service_id>\d+)$")

        # VRF ID                   : 0
        p2 = re.compile(r"^VRF ID\s*:\s*(?P<vrf_id>\d+)$")

        # IP                       : 172.18.0.2/32
        p3 = re.compile(r"^IP\s*:\s*(?P<firewall_ip>[\d/.]+)$")

        # Redirect Hdl             : 0x7fe0bb341f38
        p4 = re.compile(r"^Redirect Hdl\s*:\s*(?P<redirect_hd1>\w+)$")

        # HTM Hdl                  : 0x7fe0bb2f27d8
        p5 = re.compile(r"^HTM Hdl\s*:\s*(?P<hmt_hd1>\w+)$")

        # Route Prefix             : 172.18.0.0/30
        p6 = re.compile(r"^Route Prefix\s*:\s*(?P<router_prefix>[\d/.]+)$")

        # Next Hop                 : 60.60.60.62
        p7 = re.compile(r"^Next Hop\s*:\s*(?P<next_hop>[\d/.]+)$")

        # Adj Last Modified        : 2021-10-17,06:43:16
        p8 = re.compile(r"^Adj Last Modified\s*:\s*(?P<adj_last_modified>[\w-]+,[\w:]+)$")

        # Adj OCE Type             : ADJ
        p9 = re.compile(r"^Adj OCE Type\s*:\s*(?P<adj_oce_type>\w+)$")

        # Adj OCE Sub-Type         : NONE
        p10 = re.compile(r"^Adj OCE Sub-Type\s*:\s*(?P<adj_oce_sub_type>\w+)$")

        for line in output.splitlines():
            line = line.strip()

            # Service ID               : 3861840337
            m = p1.match(line)
            if m:
                groups = m.groupdict()
                service_id = groups['service_id']
                parsed_dict['service_id'] = service_id
                continue

            m = p2.match(line)
            if m:
                groups = m.groupdict()
                vrf_id = groups['vrf_id']
                parsed_dict['vrf_id'] = vrf_id
                continue

            m = p3.match(line)
            if m:
                groups = m.groupdict()
                firewall_ip = groups['firewall_ip']
                parsed_dict['firewall_ip'] = firewall_ip
                continue

            m = p4.match(line)
            if m:
                groups = m.groupdict()
                redirect_hd1 = groups['redirect_hd1']
                parsed_dict['redirect_hd1'] = redirect_hd1
                continue

            m = p5.match(line)
            if m:
                groups = m.groupdict()
                hmt_hd1 = groups['hmt_hd1']
                parsed_dict['hmt_hd1'] = hmt_hd1
                continue

            m = p6.match(line)
            if m:
                groups = m.groupdict()
                router_prefix = groups['router_prefix']
                parsed_dict['router_prefix'] = router_prefix
                continue

            m = p7.match(line)
            if m:
                groups = m.groupdict()
                next_hop = groups['next_hop']
                parsed_dict['next_hop'] = next_hop
                continue

            m = p8.match(line)
            if m:
                groups = m.groupdict()
                adj_last_modified = groups['adj_last_modified']
                parsed_dict['adj_last_modified'] = adj_last_modified
                continue

            m = p9.match(line)
            if m:
                groups = m.groupdict()
                adj_oce_type = groups['adj_oce_type']
                parsed_dict['adj_oce_type'] = adj_oce_type
                continue

            m = p10.match(line)
            if m:
                groups = m.groupdict()
                adj_oce_sub_type = groups['adj_oce_sub_type']
                parsed_dict['adj_oce_sub_type'] = adj_oce_sub_type
                continue

        return parsed_dict

class ShowPlatformSoftwareSteeringCellInfoSchema(MetaParser):

    ''' Schema for "show platform software steering-policy forwarding-manager switch {switch} F0 cell-info" '''

    schema = {
        'sgt': {
            Any(): {
                'sgt': int,
                'dgt': int,
                'template_name': str,
                'number_of_policies': int,
                'policy_id': int,
            },
        }
    }

class ShowPlatformSoftwareSteeringCellInfo(ShowPlatformSoftwareSteeringCellInfoSchema):
    """Schema for show platform software steering-policy forwarding-manager F0 cell-info"""

    cli_command = ['show platform software steering-policy forwarding-manager switch {switch} F0 cell-info',
                   'show platform software steering-policy forwarding-manager F0 cell-info']

    def cli(self, switch=None, output=None):
        if output is None:
            if not switch:
                cmd = self.cli_command[1]
            else:
                cmd = self.cli_command[0].format(switch=switch)
            output = self.device.execute(cmd)

        parsed_dict = {}


        # SGT: 2057, DGT: 3003
        # Template name: V4GRPPLC9;00, No.of Policies: 1
        #   Policy IDs
        #   -----------
        #   3861840057


        # SGT: 2057, DGT: 3003
        p1 = re.compile(r"^SGT\s*:\s*(?P<sgt>\d+)\s*,\s*DGT\s*:\s*(?P<dgt>\d+)$")

        # Template name: V4GRPPLC9;00, No.of Policies: 1
        p2 = re.compile(r"^Template name\s*:\s*(?P<template_name>.+)\s*,\s*No.of Policies\s*:\s*(?P<number_of_policies>\d+)$")

        #   3861840057
        p3 = re.compile(r"^(?P<policy_id>\d+)$")

        for line in output.splitlines():
            line = line.strip()

            # SGT: 2057, DGT: 3003
            m = p1.match(line)
            if m:
                groups = m.groupdict()
                sgt = int(groups['sgt'])
                dgt = int(groups['dgt'])
                sgt_dict = parsed_dict.setdefault('sgt', {})
                sgt_detailed_dict = sgt_dict.setdefault(sgt, {})
                sgt_detailed_dict.update({
                                            'sgt': sgt,
                                            'dgt': dgt
                                            })
                continue

            # Template name: V4GRPPLC9;00, No.of Policies: 1
            m = p2.match(line)
            if m:
                groups = m.groupdict()
                template_name = groups['template_name']
                number_of_policies = int(groups['number_of_policies'])
                sgt_detailed_dict.update({
                                            'template_name': template_name,
                                            'number_of_policies': number_of_policies
                                        })
                continue

            #   3861840057
            m = p3.match(line)
            if m:
                groups = m.groupdict()
                policy_id = int(groups['policy_id'])
                sgt_detailed_dict.update({
                                            'policy_id': policy_id
                                        })
                continue

        return parsed_dict

class ShowPlatformSoftwareSteeringPolicyPermissionsSchema(MetaParser):

    ''' Schema for "show platform software steering-policy forwarding-manager {switch} R0 permissions ipV4 {sgt} {dgt}" '''

    schema = {
        'policy_permissions': {
            'sgt': {
                Any(): {
                    'source_sgt': int,
                    'destination_sgt': int,
                    'policy_id': int,
                },
            }
        }
    }

class ShowPlatformSoftwareSteeringPolicyPermissions(ShowPlatformSoftwareSteeringPolicyPermissionsSchema):
    """Schema for show platform software steering-policy forwarding-manager {switch} R0 permissions ipV4 {sgt} {dgt}"""

    cli_command = ['show platform software steering-policy forwarding-manager switch {switch} R0 permissions ipv4 {sgt} {dgt}',
                   'show platform software steering-policy forwarding-manager R0 permissions ipv4 {sgt} {dgt}']

    def cli(self, sgt, dgt, switch=None, output=None):
        if output is None:
            if not switch:
                cmd = self.cli_command[1].format(sgt=sgt,dgt=dgt)
            else:
                cmd = self.cli_command[0].format(sgt=sgt,dgt=dgt,switch=switch)
            output = self.device.execute(cmd)
        parsed_dict = {}

        sgt_dict = parsed_dict.setdefault('policy_permissions', {})
        policy_permissions_dict = oper_fill_tabular(
                     header_fields=['sgt', 'dgt', 'Policy ID'],
                     label_fields= ['source_sgt', 'destination_sgt', 'policy_id'],
                     device_output=output,
                     device_os='iosxe',
                     index=[0]).entries

        sgt_dict.update({'sgt': policy_permissions_dict})

        for key1 in parsed_dict['policy_permissions']['sgt']:
            for key2 in parsed_dict['policy_permissions']['sgt'][key1]:
                parsed_dict['policy_permissions']['sgt'][key1][key2] = int(parsed_dict['policy_permissions']['sgt'][key1][key2])

        return parsed_dict

class ShowPlatformSoftwareSteeringPolicyServiceSchema(MetaParser):

    ''' Schema for "show platform software steering-policy forwarding-manager switch {switch} r0 service-id {service_id}" '''

    schema = {
        'policy_service': {
            'vnid': {
                Any(): {
                    'priority': int,
                    'weightage': int,
                    'vnid': int,
                    'rloc_ip': str,
                }
            }
        }
    }


# ==================================================
# Parser for 'show platfrm packet-trace'
# ==================================================
class ShowPlatformPktTraceStatsSchema(MetaParser):
    """schema for show packet-trace statistics"""
    schema = {
        'packets_summary': {
            Optional('matched'): int,
            'traced': int
        },
        'packets_recieved': {
            'ingress': int,
            'inject': int
        },
        'packets_processed': {
            'forward': int,
            'punt': int,
            'drop': int,
            'consume': int
        }
    }

class ShowPlatformPacketStats(ShowPlatformPktTraceStatsSchema):
    """
    parser for show platform packet-trace statistics
    """
    cli_command = ['show platform packet-trace statistics']

    def cli(self, output=None):
        if output is None:
            cmd = self.cli_command[0]
            output = self.device.execute(cmd)

        ret_dict = {}

        # Packets Summary
        #   Matched  1
        p1 = re.compile(r'\s+Matched\s+(?P<count>\d+)')
        # Packets Traced: 5
        #    or (different version)
        #   Traced   11
        p2 = re.compile(r'.*Traced:?\s+(?P<count>\d+)')

        # Packets Received
        #   Ingress  12
        #   Inject   13
        p3 = re.compile(r'^\s+(?P<pkt_type>(Ingress|Inject))\s+(?P<count>\d+)$')

        # Packets Processed
        #   Forward  14
        #   Punt     15
        #   Drop     16
        #   Consume  17
        p4 = re.compile(r'^\s+(?P<pkt_type>(Forward|Punt|Drop|Consume))\s+(?P<count>\d+)$')

        for line in output.splitlines():

            # Packets Summary
            #   Matched  1
            m = p1.match(line)
            if m:
                groups = m.groupdict()
                ret_dict.setdefault('packets_summary', {})['matched'] = int(groups['count'])
                continue
            # Packets Traced: 5
            #    or (different version)
            #   Traced   11
            m = p2.match(line)
            if m:
                groups = m.groupdict()
                ret_dict.setdefault('packets_summary', {})['traced'] = int(groups['count'])
                continue

            # Packets Received
            #   Ingress  12
            #   Inject   13
            m = p3.match(line)
            if m:
                groups = m.groupdict()
                key = groups['pkt_type'].lower()
                ret_dict.setdefault('packets_recieved', {})[key] = int(groups['count'])
                continue

            # Packets Processed
            #   Forward  14
            #   Punt     15
            #   Drop     16
            #   Consume  17
            m = p4.match(line)
            if m:
                groups = m.groupdict()
                key = groups['pkt_type'].lower()
                ret_dict.setdefault('packets_processed', {})[key] = int(groups['count'])
                continue

        return ret_dict


class ShowPlatformPktTraceSummarySchema(MetaParser):
    """schema for show platform packet-trace summary"""

    schema = {
        'packets': {
            int: {
                'input_intf': str,
                'output_intf': str,
                'state': str,
                Optional('reason'): {
                    'code': int,
                    'text': str
                }
            }
        }
    }


class ShowPlatformPacketSumm(ShowPlatformPktTraceSummarySchema):
    """
    parser for show platform packet-trace statistics
    """
    cli_command = ['show platform packet-trace summary']

    def cli(self, output=None):
        if output is None:
            cmd = self.cli_command[0]
            output = self.device.execute(cmd)

        ret_dict = {}

        # Pkt   Input            Output           State  Reason
        # 0     Gi0/0/1          Gi0/0/0          FWD     97  (Packets to LFTS)
        p = re.compile(r'\s*(?P<pkt>\d+)\s+(?P<input>\S+)\s+(?P<output>\S+)'
                       r'\s+(?P<state>\S+)(\s+(?P<reason_code>\d+)\s+(?P<reason_str>.*$))?')

        for line in output.splitlines():
            m = p.match(line)
            if m:
                groups = m.groupdict()
                pkt_num = int(groups['pkt'])
                ret_dict.setdefault('packets', {}).update({
                    pkt_num: {
                        'input_intf': groups['input'],
                        'output_intf': groups['output'],
                        'state': groups['state']
                    }
                })

                # add the reason code if matched
                reason_code = groups['reason_code'] or None
                if reason_code is not None:
                    reason_code = int(reason_code)
                    ret_dict['packets'][pkt_num].update({
                        'reason': {
                            'code': reason_code,
                            'text': groups['reason_str']
                        },
                    })
        return ret_dict


class ShowPlatformPacketTracePacketSchema(MetaParser):
    """schema for show platform packet-trace packet all|packet_num"""

    schema = {
        'packets': {
            int: {
                'cbug_id': int,
                'summary': {
                    'input': str,
                    'output': str,
                    'state': str,
                    'start_timestamp_ns': int,
                    'stop_timestamp_ns': int,
                    'start_timestamp': str,
                    'stop_timestamp': str,
                },
                'path_trace': {
                    Optional('ipv4_input'): {
                        'input': str,
                        'output': str,
                        'source': str,
                        'destination': str,
                        'protocol': str,
                        Optional('src_port'): str,
                        Optional('dst_port'): str
                    },
                    Optional('ipv4_output'): {
                        'input': str,
                        'output': str,
                        'source': str,
                        'destination': str,
                        'protocol': str,
                        Optional('src_port'): str,
                        Optional('dst_port'): str
                    },
                    Optional('icmpv4_input'): {
                        'input': str,
                        'output': str,
                        'type': str,
                        'code': str
                    },
                    Optional('icmpv4_output'): {
                        'input': str,
                        'output': str,
                        'type': str,
                        'code': str
                    },
                    Optional('cft'): {
                        'api': str,
                        'packet_capabilities': str,
                        'input_vrf_idx': str,
                        'calling_feature': str,
                        'direction': str,
                        'triplet_vrf_idx': str,
                        'triplet_network_start': str,
                        'triplet_triplet_flags': str,
                        'triplet_counter': str,
                        'cft_bucket_number': str,
                        'cft_l3_payload_size': str,
                        'cft_pkt_ind_flags': str,
                        'cft_pkt_ind_valid': str,
                        'tuple_src_ip': str,
                        'tuple_dst_ip': str,
                        'tuple_src_port': str,
                        'tuple_dst_port': str,
                        'tuple_vrfid': str,
                        'tuple_l4_protocol': str,
                        'tuple_l3_protocol': str,
                        'pkt_sb_state': str,
                        'pkt_sb_num_flows': str,
                        'pkt_sb_tuple_epoch': str,
                        'returned_cft_error': str,
                        'returned_fid': str
                    },
                    Optional('nbar'): {
                        'packet_number_in_flow': str,
                        'classification_state': str,
                        'classification_name': str,
                        'classification_id': str,
                        'classification_source': str,
                        'number_of_matched_sub_classifications': str,
                        'number_of_extracted_fields': str,
                        'is_pa_split_packet': str,
                        'tph_mqc_bitmask_value': str
                    },
                    Optional('qos'): {
                        'direction': str,
                        'action': str,
                        'fields': str
                    },
                    Optional('ipsec'): {
                        'action': str,
                        'sa_handle': str,
                        'spi': str,
                        'peer_addr': str,
                        'local_addr': str
                    },
                    Optional('nat'): {
                        'direction': str,
                        'from': str,
                        'action': str,
                        'fwd_point': str,
                        'vrf': str,
                        'table_id': str,
                        'protocol': str,
                        'src_addr': str,
                        'dest_addr': str,
                        'src_port': str,
                        'dst_port': str
                    }

                },
                Optional('iosd_flow'): {
                    Optional('infra'): {
                        'pkt_direction': str,
                        'packet_rcvd_from': str
                    },
                    Optional('ip'): {
                        'pkt_direction': str,
                        'packet_enqueued_in': str,
                        'source': str,
                        'destination': str,
                        'interface': str
                    },
                    Optional('tcp'): {
                        'pkt_direction': str,
                        'tcp0': str
                    },
                    Optional('udp'):  {
                        'pkt_direction': str,
                        'src': str,
                        'dst': str,
                        'length': str
                    }
                }
            }
        }
    }

class ShowPlatformPacketTracePacket(ShowPlatformPacketTracePacketSchema):
    """
    parser for `show platform packet-trace packet all|packet_id`
    """
    cli_command = ['show platform packet-trace packet all',
                   'show platform packet-trace packet {packet_id}']

    FIRST_CAP_REGEX = re.compile('(.)([A-Z][a-z]+)')
    ALL_CAP_REGEX = re.compile('([a-z0-9])([A-Z])')
    SLUGIFY_P = re.compile(r'[^a-z0-9]+')

    def _field_name_normalize(self, name):
        """
        convert field name to snake_case (.e.g CamleCase to snake_case) and remove unwanted special chars.
        :param name: str
        :return:str
        """
        # convert to snake_case
        string_one = self.FIRST_CAP_REGEX.sub(r'\1_\2', name)
        name = self.ALL_CAP_REGEX.sub(r'\1_\2', string_one).lower()
        # slugify
        name = re.sub(self.SLUGIFY_P, '_', name)
        name = re.sub(r'_{2,}', '_', name).strip('_')
        return name

    def cli(self, output=None, packet_id=None):
        if output is None:
            if packet_id is None:
                cmd = self.cli_command[0]
            else:
                cmd = self.cli_command[0].format(packet_id=packet_id)
            output = self.device.execute(cmd)

        # Packet: 0           CBUG ID: 104
        p_packet_start = re.compile(r'Packet:\s+(?P<packet_id>\d+)\s+CBUG\s+ID:\s(?P<cbug_id>\d+)')
        # Summary
        p_summary_start = re.compile(r'Summary$')
        #  Timestamp
        #   Start   : 19591546248064016 ns (07/27/2021 09:34:28.261898 UTC)
        #   Stop    : 19591546248087028 ns (07/27/2021 09:34:28.261921 UTC)
        p_timestamp = re.compile(
            r'\s+(?P<field>(Start)|(Stop))\s+:\s(?P<time_ns>\d+)\s+ns\s+'
            r'\((?P<date_str>\d+/\d+/\d+\s+\d+:\d+:\d+\.\d+)\s+\w+\)')
        #   Feature: IPV4(Output)
        p_feature_start = re.compile(r'\s+Feature:\s(?P<feature_name>[\w\\()]+)')
        # Path Trace
        p_path_trace_start = re.compile(r'Path\s+Trace$')
        # IOSd Path Flow: Packet: 1    CBUG ID: 105
        p_iosd_flow_start = re.compile(r'IOSd\sPath\sFlow:\sPacket:')

        p_from_plane = re.compile(r'\s+Packet\s+Rcvd\s+From\s+(?P<from_plane>\w+)')
        p_layer = re.compile(r'\s+Packet\s+Enqueued\s+in\s+(?P<layer>.*)')

        ret_dict = {}

        for line in output.splitlines():
            # start a with new packet
            # Packet: 0           CBUG ID: 104
            m = p_packet_start.match(line)
            if m:
                groups = m.groupdict()
                packet_id = int(groups['packet_id'])
                packet_dict = ret_dict.setdefault('packets', {}).setdefault(packet_id, {})
                packet_dict['cbug_id'] = int(groups['cbug_id'])
                continue

            # Summary
            m = p_summary_start.match(line)
            if m:
                current_dict = packet_dict.setdefault('summary', {})
                continue

            # Path Trace
            m = p_path_trace_start.match(line)
            if m:
                current_features_key = 'path_trace'
                continue
            # IOSd Path Flow: Packet: 1    CBUG ID: 105
            m = p_iosd_flow_start.match(line)
            if m:
                current_features_key = 'iosd_flow'
                continue

            #   Feature: IPV4(Output)
            m = p_feature_start.match(line)
            if m:
                groups = m.groupdict()
                current_feature = self._field_name_normalize(groups['feature_name'])
                current_dict = packet_dict.setdefault(current_features_key, {}).setdefault(current_feature, {})
                continue

            #  Timestamp
            #   Start   : 19591546248064016 ns (07/27/2021 09:34:28.261898 UTC)
            #   Stop    : 19591546248087028 ns (07/27/2021 09:34:28.261921 UTC)
            m = p_timestamp.match(line)
            if m:
                groups = m.groupdict()
                current_dict.update({
                    groups['field'].lower() + '_timestamp_ns': int(groups['time_ns']),
                    groups['field'].lower() + '_timestamp': groups['date_str']
                })
                continue

            #     Packet Rcvd From DATAPLANE
            m = p_from_plane.match(line)
            if m:
                groups = m.groupdict()
                current_dict['packet_rcvd_from'] = groups['from_plane']
                continue

            #     Packet Enqueued in IP layer
            m = p_layer.match(line)
            if m:
                groups = m.groupdict()
                current_dict['packet_enqueued_in'] = groups['layer']
                continue

            # from here on we match all lines by splitting by :
            #
            # current_dict is set to summary or the respective feature based on earlier
            # matches

            # Summary
            #   Input     : GigabitEthernet1
            #   Output    : internal0/0/rp:0
            #   State     : PUNT 11  (For-us data)

            # Path Trace
            #     Input       : GigabitEthernet1
            #     <snippt>
            #     Protocol    : 6 (TCP)
            #       SrcPort   : 43520
            #       DstPort   : 22
            #     API                   : cft_handle_pkt
            #     packet capabilities   : 0x000000af
            #     <snip>
            #     triplet.triplet_flags : 0x00000000
            #     triplet.counter       : 0

            line = line.split(':', maxsplit=1)
            if len(line) == 2:
                current_dict[self._field_name_normalize(line[0])] = line[1].strip()
                continue

        return ret_dict

class ShowPlatformSoftwareSteeringPolicyService(ShowPlatformSoftwareSteeringPolicyServiceSchema):
    """Schema for show platform software steering-policy forwarding-manager switch {switch} r0 service-id {service_id}"""

    cli_command = ['show platform software steering-policy forwarding-manager switch {switch} r0 service-id {service_id}',
                   'show platform software steering-policy forwarding-manager r0 service-id {service_id}']

    def cli(self, service_id, switch='', output=None):
        if output is None:
            if not switch:
                cmd = self.cli_command[1].format(service_id=service_id)
            else:
                cmd = self.cli_command[0].format(switch=switch,service_id=service_id)
            output = self.device.execute(cmd)

        parsed_dict = {}
        vnid_dict = parsed_dict.setdefault('policy_service', {})
        policy_service_dict = oper_fill_tabular(
                     header_fields=['Priority', 'Weightage', 'VNID', 'RLOC IP address'],
                     label_fields= ['priority', 'weightage', 'vnid', 'rloc_ip'],
                     device_output=output,
                     device_os='iosxe',
                     index=[2]).entries

        vnid_dict.update({'vnid': policy_service_dict})

        for key1 in parsed_dict['policy_service']['vnid']:
            for key2 in parsed_dict['policy_service']['vnid'][key1]:
                if key2 != 'rloc_ip':
                    parsed_dict['policy_service']['vnid'][key1][key2] = int(parsed_dict['policy_service']['vnid'][key1][key2])

        return parsed_dict

class ShowPlatformSoftwareSteeringPolicyServiceAllSchema(MetaParser):

    ''' Schema for "show platform software steering-policy forwarding-manager switch {switch} F0 service-all" '''

    schema = {
        'services_ip': {
            Any(): {
                'service_id': int,
                'service_vrf': int,
                'firewall_mode': str,
                'service_selector': int,
                'service_ip': str,
                'number_of_rlocs': int,
            }
        }
    }

class ShowPlatformSoftwareSteeringPolicyServiceAll(ShowPlatformSoftwareSteeringPolicyServiceAllSchema):
    """Schema for show platform software steering-policy forwarding-manager switch {switch} F0 service-all"""

    cli_command = ['show platform software steering-policy forwarding-manager switch {switch} F0 service-all',
                   'show platform software steering-policy forwarding-manager F0 service-all']

    def cli(self, switch='', output=None):
        if output is None:
            if not switch:
                cmd = self.cli_command[1]
            else:
                cmd = self.cli_command[0].format(switch=switch)
            output = self.device.execute(cmd)

        parsed_dict = {}
        services_dict = oper_fill_tabular(
                     header_fields=['Service ID', 'Service VRF', 'Firewall mode', 'Service Selector', 'Service IP', 'No. Of RLOCs'],
                     label_fields= ['service_id', 'service_vrf', 'firewall_mode','service_selector','service_ip','number_of_rlocs'],
                     device_output=output,
                     device_os='iosxe',
                     index=[4]).entries

        parsed_dict.update({'services_ip':services_dict})

        for key1 in parsed_dict['services_ip']:
            for key2 in parsed_dict['services_ip'][key1]:
                if key2 != 'firewall_mode' and key2 != 'service_ip':
                    parsed_dict['services_ip'][key1][key2] = int(parsed_dict['services_ip'][key1][key2])

        return parsed_dict

class ShowPlatformSoftwareSteeringPolicySummarySchema(MetaParser):

    ''' Schema for "show platform software steering-policy forwarding-manager switch {switch} F0 policy-summary" '''

    schema = {
        'policy_index': {
            Any(): {
                'policy': str,
                'index': int,
                'num_ref': int,
                'num_entries': int,
            },
        }
    }

class ShowPlatformSoftwareSteeringPolicySummary(ShowPlatformSoftwareSteeringPolicySummarySchema):
    """Schema for show platform software steering-policy forwarding-manager switch {switch} F0 policy-summary"""

    cli_command = ['show platform software steering-policy forwarding-manager switch {switch} F0 policy-summary',
                   'show platform software steering-policy forwarding-manager F0 policy-summary']

    def cli(self, switch=None, output=None):
        if output is None:
            if not switch:
                cmd = self.cli_command[1]
            else:
                cmd = self.cli_command[0].format(switch=switch)
            output = self.device.execute(cmd)

        parsed_dict = {}
        policy_index_dict = oper_fill_tabular(
                     header_fields=['Policy', 'Index', 'Num Ref', 'Num Entries'],
                     label_fields= ['policy', 'index', 'num_ref','num_entries'],
                     device_output=output,
                     device_os='iosxe',
                     index=[1]).entries

        parsed_dict.update({'policy_index':policy_index_dict})

        for key1 in parsed_dict['policy_index']:
            for key2 in parsed_dict['policy_index'][key1]:
                if key2 != 'policy':
                    parsed_dict['policy_index'][key1][key2] = int(parsed_dict['policy_index'][key1][key2])
        return parsed_dict


class ShowPlatformIfmMappingSchema(MetaParser):
    """Schema for show platform software fed switch active ifm mappings"""

    schema = {
        'interface': {
             Any(): {
                'if_id': str,
                'inst': int,
                'asic': int,
                'core': int,
                Optional('ifg_id'): int,
                'port': int,
                'subport': int,
                'mac' : int,
                Optional('first_serdes'): int,
                Optional('last_serdes'): int,
                'cntx': int,
                'lpn' : int,
                'gpn' : int,
                'type': str,
                'active': str,
              },
           },
       }


# ============================================================
#  Parser for 'show platform software fed active ifm mappings'
# ============================================================
class ShowPlatformIfmMapping(ShowPlatformIfmMappingSchema):

    """ Parser for show platform software fed switch active ifm mappings"""

    cli_command = ['show platform software fed switch {state} ifm mappings',
                   'show platform software fed active ifm mappings']

    def cli(self, state= None, output=None):

        if output is None:
            if state:
                cmd = self.cli_command[0].format(state=state)
            else:
                cmd = self.cli_command[1]

            # Execute command to get output from device
            output = self.device.execute(cmd)

        # HundredGigE2/0/1          0x3      0   0    5      1    0      0     1    0            1            0    1    769  NIF    Y
        p1 = re.compile(r'^(?P<interface>\S+)\s+(?P<if_id>\S+)\s+(?P<inst>\d+)\s+(?P<asic>\d+)\s+(?P<core>\d+)\s+(?P<ifg_id>\d+)?\s+(?P<port>\d+)\s+(?P<subport>\d+)\s+(?P<mac>\d+)\s+(?P<first_serdes>\d+)?\s+(?P<last_serdes>\d+)?\s+(?P<cntx>\d+)\s+(?P<lpn>\d+)\s+(?P<gpn>\d+)\s+(?P<type>\w+)\s+(?P<active>\w+)\s*$')

        # initial variables
        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()

            # HundredGigE2/0/1          0x3      0   0    5      1    0      0     1    0            1            0    1    769  NIF    Y
            m = p1.match(line)
            if m:
                group = m.groupdict()
                interface_dict = ret_dict.setdefault('interface',{}).setdefault(group['interface'],{})
                interface_dict['if_id'] = group['if_id']
                interface_dict['inst'] = int(group['inst'])
                interface_dict['asic'] = int(group['asic'])
                interface_dict['core'] = int(group['core'])
                if group['ifg_id'] is not None:
                    interface_dict['ifg_id']  = int(group['ifg_id'])
                interface_dict['port'] = int(group['port'])
                interface_dict['subport'] = int(group['subport'])
                interface_dict['mac'] = int(group['mac'])
                if group['first_serdes'] is not None:
                    interface_dict['first_serdes'] = int(group['first_serdes'])
                if group['last_serdes'] is not None:
                    interface_dict['last_serdes'] = int(group['last_serdes'])
                interface_dict['cntx'] = int(group['cntx'])
                interface_dict['lpn']  = int(group['lpn'])
                interface_dict['gpn']  = int(group['gpn'])
                interface_dict['type'] = group['type']
                interface_dict['active'] = group['active']
                continue

        return ret_dict

class ShowPlatformHardwareFedActiveQosScheduleSchema(MetaParser):
       """Parser for show platform hardware fed active qos schedule for interface and sub_interface"""
       schema = {
        'interface':{
            Any():{
                'port_Scheduler':{
                         'Interface_SCH_OID' : int,
                         'System_Port_SCH_OID' : int,
                         'Priority_Propagation' : str,
                         'Sub_interface_Q_Mode' : str,
                         'Logical_Port'         : str,
                          'TC_Profile':{
                                'SDK_OID' : int,
                                'TC':{
                                    'TC0':int,
                                    'TC1':int,
                                     'TC2':int,
                                     'TC3':int,
                                     'TC4':int,
                                     'TC5':int,
                                     'TC6':int,
                                     'TC7':int,
                                    }

                                }
                        },
                     'Interface_Scheduler':{
                        'CIR':{
                             'Credit' : int,
                             'Transmit' : int,
                             'Weight' : int
                            },
                        'PIR':{
                             'Credit' : int,
                             'Transmit': int,
                             'Weight' : int
                            }
                        },
                     'Interface_Scheduler_OQPG':{
                         'PG_TYPE':{
                            Any():{
                                Optional('OQPG_0'): str,
                                Optional('OQPG_1'):str,
                                Optional('OQPG_2'):str,
                                Optional('OQPG_3'):str,
                                Optional('OQPG_4'):str,
                                Optional('OQPG_5'):str,
                                Optional('OQPG_6'):str,
                                Optional('OQPG_7'):str,
                                },
                            }
                        },
                     'OQPG':{
                        Any():{
                             'LPSE_OQ_0' : str,
                              'LPSE_OQ_1' : str,
                              Optional('OQ_2'): str,
                              Optional('OQ_3'): str,
                              Optional('OQ_4'): str,
                              Optional('OQ_5'): str,
                              Optional('OQ_6'): str,
                              Optional('OQ_7'): str,
                             },
                        },

                     'LPSE_OID':int,
                     Optional('LPSE_CIR_Rate'):int,
                     Optional('LPSE_CIR_Burst'):str,
                     Optional('LPSE_PIR_Rate'):int,
                     Optional('LPSE_PIR_Burst'):str,
                     Optional('LPSE_Main_Int'):int,
                     Optional('LPSE_OQSE_CIR'):int,
                     Optional('LPSE_OQSE_CIR_Burst'):str,
                     Optional('LPSE_OQSE_PIR'):int,
                     Optional('LPSE_OQSE_PIR_Burst'):str,
                     Optional('LPSE_Total'): int,
                     'oqse_oid':int,
                     'oq_id':int,
                     'oq_scheduling_mode':str,
                     Optional('oq_credit_cir'):int,
                     Optional('oq_credit_cir_burst'):str,
                     'oq_credit_pir':int,
                     'oq_credit_pir_burst':str,
                     Optional('oq_transmit_pir'):int,
                     Optional('oq_transmit_pir_burst'):str
                    }
                 }
             }

class ShowPlatformHardwareFedActiveQosScheduleInterface(ShowPlatformHardwareFedActiveQosScheduleSchema):
    """
    Parser for:
        * show platform hardware fed active qos schedule interface
    """
    cli_command = ['show platform hardware fed switch {switch_var} qos schedule interface {interface}',
    'show platform hardware fed active qos schedule interface {interface}']

    def cli(self, interface,output=None,switch_var=None):
        if output is None:
            if switch_var is None:
                cmd = self.cli_command[1].format(interface=interface)
            else:
                cmd = self.cli_command[0].format(switch_var=switch_var,interface=interface)

            output = self.device.execute(cmd)

        ret_dict = {}
        list1=['Credit PIR    ','Credit Burst  ','Transmit PIR  ','Transmit Burst']

        #Interface  : Gi1/0/2
        p1 = re.compile(r'^Interface +: (?P<intf>[\w+\/\.\-]+)')

        #| Interface SCH OID     : 3125
        p2 = re.compile(r'\| Interface SCH OID +: (?P<Interface_SCH_OID>\d+)')

        #System Port SCH OID   : 3129
        p3 = re.compile(r'\| System Port SCH OID +: (?P<System_Port_SCH_OID>\d+)')

        #Priority Propagation  : Disabled
        p4=re.compile(r'\| Priority Propagation +: (?P<Priority_Propagation>\w+)')

        #Sub-interface Q Mode  : Enabled - Priority Propagation
        p5=re.compile(r'\| Sub-interface Q Mode +: (?P<Sub_interface_Q>[\w+-]+)')

        #Logical Port          : Enabled
        p6=re.compile(r'\| Logical Port +: (?P<Logical_Port>\w+)')

        #TC Profile            : SDK OID    :   110
        p7=re.compile(r'\| TC Profile +: SDK OID +: +(?P<SDK_OID>\d+)$')

        #|                       : VOQ Offset :   0 |   0 |   0 |   0 |   0 |   0 |   0 |   2
        p8=re.compile(r'\| +: VOQ Offset : +(?P<TC0>\d+) \| +(?P<TC1>\d+) \| +(?P<TC2>\d+) \| +(?P<TC3>\d+) \| +(?P<TC4>\d+) \| +(?P<TC5>\d+) \| +(?P<TC6>\d+) \| +(?P<TC7>\d+)$')

        #|           | Credit        : 20000000000
        p9=re.compile(r'\| +\| Credit +: (?P<Credit>\d+)')

        #| CIR [RR]  | Transmit      : 20000000000
        p10=re.compile(r'\| CIR \[RR\] +\| Transmit +: (?P<Transmit>\d+)')

        #|           | Weight        : 1
        p11=re.compile(r'\|           \| Weight        : (?P<Weight>\d+)')

        #| PIR [WFQ] | Transmit      : 20000000000
        p12=re.compile(r'\| PIR \[WFQ\] +\| Transmit +: (?P<Transmit>\d+)')

        #|    |Credit CIR    || 0                | 0                | 0                | 0                | 0                | 0                | 0                | 60000000000      |
        #| RR |Credit Burst  || 0                | 0                | 0                | 0                | 0                | 0                | 0                | SDK Default      |
        p13=re.compile(r'\| (\w+ | +)\|(?P<PG_TYPE>[\w+ ]+) +\|\| (?P<OQPG_0>\d+) +\| (?P<OQPG_1>\d+) +\| (?P<OQPG_2>\d+) +\| (?P<OQPG_3>\d+) +\| (?P<OQPG_4>\d+) +\| (?P<OQPG_5>\d+) +\| (?P<OQPG_6>\d+) +\| (?P<OQPG_7>[a-zA-z0-9 ]{1,11})')


        #| OQ List           || 0                | 1                |                  | 3                | 4                | 5                | 6                | 2 7              |
        p13_1=re.compile(r'\| (?P<PG_TYPE>[\w+ ]+) +\|\| (?P<OQPG_0>[\d+ ]) +\| (?P<OQPG_1>[\d+ ]) +\| (?P<OQPG_2>[\d+ ]) +\| (?P<OQPG_3>[\d+ ]) +\| (?P<OQPG_4>[\d+ ]) +\| (?P<OQPG_5>[\d+ ]) +\| (?P<OQPG_6>[\d+ ]) +\| (?P<OQPG_7>[a-zA-z0-9 ]{1,11})')

        #| Credit PIR        || 60000000000      | 60000000000      | 4000000000       | 60000000000      | 60000000000      | 60000000000      | 60000000000      | 60000000000      |
        #| Credit Burst      || SDK Default      | SDK Default      | SDK Default      | SDK Default      | SDK Default      | SDK Default      | SDK Default      | SDK Default      |
        #| Transmit PIR      || 60000000000      | 60000000000      | 4000000000       | 60000000000      | 60000000000      | 60000000000      | 60000000000      | 60000000000      |
        #| Transmit Burst    || SDK Default      | SDK Default      | SDK Default      | SDK Default      | SDK Default      | SDK Default      | SDK Default      | SDK Default      |
        #| Weights : UC : MC ||      8 : 2       |      8 : 2       |      8 : 2       |      8 : 2       |      8 : 2       |      8 : 2       |      8 : 2       |      8 : 2       |
        #| OQSE OID          || LPSE OID : 3138 (0xC42  )           | 3132 (0xC3C  )   | 3133 (0xC3D  )   | 3134 (0xC3E  )   | 3135 (0xC3F  )   | 3136 (0xC40  )   | 3137 (0xC41  )   |

        p14=re.compile(r'\| (?P<OQ_Number>[\w+ ]{1,14}) +\|\| (?P<LPSE_OQ_0>[a-zA-Z0-9 ]{1,11}) +\| (?P<LPSE_OQ_1>[a-zA-Z0-9 ]{1,11}) +\| (?P<OQ_2>[a-zA-Z0-9 ]{1,11}) +\| (?P<OQ_3>[a-zA-Z0-9 ]{1,11}) +\| (?P<OQ_4>[a-zA-Z0-9 ]{1,11}) +\| (?P<OQ_5>[a-zA-Z0-9 ]{1,11}) +\| (?P<OQ_6>[a-zA-Z0-9 ]{1,11}) +\| (?P<OQ_7>[a-zA-Z0-9 ]{1,11})')

        #| Credit PIR        || 20000000000      | 20000000000      |
        #| Credit Burst      || SDK Default      | SDK Default      |
        #| Transmit PIR      || 20000000000      | 20000000000      |
        #| Transmit Burst    || SDK Default      | SDK Default      |
        #| LPSE OID          || 3138 (0xC42  )                      |
        p14_1=re.compile(r'\| (?P<OQ_Number>[\w+ ]{1,14}) +\|\| (?P<LPSE_OQ_0>[a-zA-Z0-9 ]{1,11}) +\| (?P<LPSE_OQ_1>[a-zA-Z0-9 ]{1,11})')

        #| LPSE OID          || 3138 (0xC42  )
        p15=re.compile(r'\| LPSE OID +\|\| (?P<LPSE_OID>\d+)')

        #| LPSE OID                            : 3138 (  0xC42)
        p16=re.compile(r'\| LPSE OID +: (?P<LPSE_OID>\d+)')

        #| LPSE CIR (Priority Queue) Rate      : 2000000000
        p17=re.compile(r'\| LPSE CIR \(Priority Queue\) Rate +: (?P<LPSE_CIR_Rate>\d+)')

        #| LPSE CIR (Priority Queue) Burst     : SDK Default
        p18=re.compile(r'\| LPSE CIR \(Priority Queue\) Burst +: (?P<LPSE_CIR_Burst>[\w+ ]{1,11})')

        #| LPSE PIR (Sub-Interface Port) Rate  : 2000000000
        p19=re.compile(r'\| LPSE PIR \(Sub-Interface Port\) Rate  : (?P<LPSE_PIR_Rate>\d+)')

        #| LPSE PIR (Sub-Interface Port) Burst : SDK Default
        p20=re.compile(r'\| LPSE PIR (Sub-Interface Port) Burst : (?P<LPSE_PIR_Burst>[\w+ ]{1,11})')

        #| LPSE Main Interface OQSE  : 3130 (0xC3A  )   | 3131 (0xC3B  )   |
        p21=re.compile(r'\| LPSE Main Interface OQSE  : (?P<LPSE_Main_Int>\d+)')

        #| LPSE OQSE Credit CIR      : 60000000000      | 60000000000      |
        p22=re.compile(r'\| LPSE OQSE Credit CIR +: (?P<LPSE_OQSE_CIR>\d+)')

        #| LPSE OQSE Credit CIR Burst: SDK Default      | SDK Default      |
        p23=re.compile(r'\| LPSE OQSE Credit CIR Burst: (?P<LPSE_OQSE_CIR_Burst>[\w+ ]{1,11})')

        #| LPSE OQSE Credit PIR      : 60000000000      | 60000000000      |
        p24=re.compile(r'\| LPSE OQSE Credit PIR +: (?P<LPSE_OQSE_PIR>\d+)')

        #| LPSE OQSE Credit PIR Burst: SDK Default      | SDK Default      |
        p25=re.compile(r'\| LPSE OQSE Credit PIR Burst: (?P<LPSE_OQSE_PIR_Burst>[\w+ ]{1,11})')

        #| LPSE Total Attached OQSEs : 2
        p26=re.compile(r'\| LPSE Total Attached OQSEs : (?P<LPSE_Total>\d+)')
        #| OQSE OID              : 4234
        p27=re.compile(r'\| OQSE OID\s+: (?P<oqse_oid>\d+)')

        #| OQ    ID              : 0
        p28=re.compile(r'\| OQ    ID\s+: (?P<oq_id>\d+)')

        #| Scheduling Mode       : Logical Port SP WFQ
        p29=re.compile(r'\| Scheduling Mode\s+: (?P<oq_scheduling_mode>\w+)')

        #| Credit CIR            : 2000000000
        p30=re.compile(r'\| Credit CIR\s+: (?P<oq_credit_cir>\d+)')

        #| Credit CIR Burst      : SDK Default
        p31=re.compile(r'\| Credit CIR Burst\s+:(?P<oq_credit_cir_burst>\w+)')

        #| Credit PIR            : 2000000000
        p32=re.compile(r'\| Credit PIR\s+: (?P<oq_credit_pir>\w+)')

        #| Credit PIR Burst      : SDK Default
        p33=re.compile(r'\| Credit PIR Burst\s+: (?P<oq_credit_pir_burst>\w+)')

        #| Transmit PIR          : 60000000000
        p34=re.compile(r'\| Transmit PIR\s+: (?P<oq_transmit_pir>\d+)')

        #| Transmit PIR Burst    : SDK Default
        p35=re.compile(r'\| Transmit PIR Burst\s+: (?P<oq_transmit_pir_burst>\d+)')

        flag_CIR=0
        for line in output.splitlines():
            line = line.strip()

            #Interface  : Gi1/0/2
            m=p1.match(line)
            if m:
               interface=m.groupdict()['intf']
               interface_dict=ret_dict.setdefault('interface', {})
               interface_dict1=interface_dict.setdefault(interface, {})
               Port_Scheduler_dict=interface_dict1.setdefault('port_Scheduler', {})
               continue

            #| Interface SCH OID     : 3125
            m=p2.match(line)
            if m:
                Port_Scheduler_dict['Interface_SCH_OID']=int(m.groupdict()['Interface_SCH_OID'])
                continue

            #System Port SCH OID   : 3129
            m=p3.match(line)
            if m:
                Port_Scheduler_dict['System_Port_SCH_OID']=int(m.groupdict()['System_Port_SCH_OID'])
                continue

            #Priority Propagation  : Disabled
            m=p4.match(line)
            if m:
                Port_Scheduler_dict['Priority_Propagation']=m.groupdict()['Priority_Propagation']
                continue

            #Sub-interface Q Mode  : Enabled - Priority Propagation
            m=p5.match(line)
            if m:
                Port_Scheduler_dict['Sub_interface_Q_Mode']=m.groupdict()['Sub_interface_Q']
                continue

            #Logical Port          : Enabled
            m=p6.match(line)
            if m:
                Port_Scheduler_dict['Logical_Port']=m.groupdict()['Logical_Port']
                continue

            #TC Profile            : SDK OID    :   110
            m=p7.match(line)
            if m:
                Tc_profile_dict=Port_Scheduler_dict.setdefault('TC_Profile', {})
                Tc_profile_dict['SDK_OID']=int(m.groupdict()['SDK_OID'])
                continue

            #|                       : VOQ Offset :   0 |   0 |   0 |   0 |   0 |   0 |   0 |   2
            m=p8.match(line)
            if m:
                TC_dict=Tc_profile_dict.setdefault('TC',{})
                TC_dict['TC0']=int(m.groupdict()['TC0'])
                TC_dict['TC1']=int(m.groupdict()['TC1'])
                TC_dict['TC2']=int(m.groupdict()['TC2'])
                TC_dict['TC3']=int(m.groupdict()['TC3'])
                TC_dict['TC4']=int(m.groupdict()['TC4'])
                TC_dict['TC5']=int(m.groupdict()['TC5'])
                TC_dict['TC6']=int(m.groupdict()['TC6'])
                TC_dict['TC7']=int(m.groupdict()['TC7'])
                continue

            #|           | Credit        : 20000000000
            m=p9.match(line)
            if m and flag_CIR < 1:
                Interface_Scheduler_dict=interface_dict1.setdefault('Interface_Scheduler', {})
                CIR_dict=Interface_Scheduler_dict.setdefault('CIR',{})
                CIR_dict['Credit']=int(m.groupdict()['Credit'])
                flag_CIR=1
                continue

            #| CIR [RR]  | Transmit      : 20000000000
            m=p10.match(line)
            if m and flag_CIR < 2:
                CIR_dict['Transmit']=int(m.groupdict()['Transmit'])
                flag_CIR=2
                continue

            #|           | Weight        : 1
            m=p11.match(line)
            if m and flag_CIR < 3 and flag_CIR > 1:
               CIR_dict['Weight']=int(m.groupdict()['Weight'])
               flag_CIR=3
               continue

            #| PIR [WFQ] | Transmit      : 20000000000
            m=p9.match(line)
            if m:
                PIR_dict=Interface_Scheduler_dict.setdefault('PIR',{})
                PIR_dict['Credit']=int(m.groupdict()['Credit'])
                continue

            #|    |Credit CIR    || 0                | 0                | 0                | 0                | 0                | 0                | 0                | 60000000000      |
            m=p12.match(line)
            if m:
                PIR_dict['Transmit']=int(m.groupdict()['Transmit'])
                continue

            #|           | Weight        : 1
            m=p11.search(line)
            if m:
                PIR_dict['Weight']=int(m.groupdict()['Weight'])
                continue

            #|    |Credit CIR    || 0                | 0                | 0                | 0                | 0                | 0                | 0                | 60000000000      |
            m=p13.match(line)
            if m:
               Interface_Scheduler_OQPG_dict=interface_dict1.setdefault('Interface_Scheduler_OQPG', {})
               PG_TYPE_dict=Interface_Scheduler_OQPG_dict.setdefault('PG_TYPE', {})
               PG_TYPE_Name=m.groupdict()['PG_TYPE'].strip()
               OQPG_dict=PG_TYPE_dict.setdefault(PG_TYPE_Name, {})
               OQPG_dict['OQPG_0']=m.groupdict()['OQPG_0']
               OQPG_dict['OQPG_1']=m.groupdict()['OQPG_1']
               OQPG_dict['OQPG_2']=m.groupdict()['OQPG_2']
               OQPG_dict['OQPG_3']=m.groupdict()['OQPG_3']
               OQPG_dict['OQPG_4']=m.groupdict()['OQPG_4']
               OQPG_dict['OQPG_5']=m.groupdict()['OQPG_5']
               OQPG_dict['OQPG_6']=m.groupdict()['OQPG_6']
               OQPG_dict['OQPG_7']=m.groupdict()['OQPG_7'].strip()
               continue

            #| OQ List           || 0                | 1                |                  | 3                | 4                | 5                | 6                | 2 7              |
            m=p13_1.match(line)
            if m:
               PG_TYPE_Name=m.groupdict()['PG_TYPE'].strip()
               OQPG_dict=PG_TYPE_dict.setdefault(PG_TYPE_Name, {})
               if not m.groupdict()['OQPG_0'].isspace():
                   OQPG_dict['OQPG_0']=m.groupdict()['OQPG_0']
               if not m.groupdict()['OQPG_1'].isspace():
                   OQPG_dict['OQPG_1']=m.groupdict()['OQPG_1']
               if not m.groupdict()['OQPG_2'].isspace():
                   OQPG_dict['OQPG_2']=m.groupdict()['OQPG_2']
               if not m.groupdict()['OQPG_3'].isspace():
                   OQPG_dict['OQPG_3']=m.groupdict()['OQPG_3']
               if not m.groupdict()['OQPG_4'].isspace():
                   OQPG_dict['OQPG_4']=m.groupdict()['OQPG_4']
               if not m.groupdict()['OQPG_5'].isspace():
                   OQPG_dict['OQPG_5']=m.groupdict()['OQPG_5']
               if not m.groupdict()['OQPG_0'].isspace():
                   OQPG_dict['OQPG_6']=m.groupdict()['OQPG_6']
               if not m.groupdict()['OQPG_0'].isspace():
                   OQPG_dict['OQPG_7']=m.groupdict()['OQPG_7'].strip()
               continue

            #| Credit PIR        || 60000000000      | 60000000000      | 4000000000       | 60000000000      | 60000000000      | 60000000000      | 60000000000      | 60000000000      |
            m=p14.match(line)
            if m :
                LPSE_OQPG_dict=interface_dict1.setdefault('OQPG', {})
                OQ_Number=m.groupdict()['OQ_Number'].strip()
                LPSE_dict=LPSE_OQPG_dict.setdefault(OQ_Number, {})
                LPSE_dict['LPSE_OQ_0'] = m.groupdict()['LPSE_OQ_0']
                LPSE_dict['LPSE_OQ_1'] = m.groupdict()['LPSE_OQ_1']
                LPSE_dict['OQ_2']  = m.groupdict()['OQ_2']
                LPSE_dict['OQ_3']  = m.groupdict()['OQ_3']
                LPSE_dict['OQ_4']  = m.groupdict()['OQ_4']
                LPSE_dict['OQ_5']  = m.groupdict()['OQ_5']
                LPSE_dict['OQ_6']  = m.groupdict()['OQ_6']
                LPSE_dict['OQ_7']  = m.groupdict()['OQ_7']
                continue

            #| Credit PIR        || 20000000000      | 20000000000      |
            m=p14_1.match(line)
            if m and m.groupdict()['OQ_Number'] in list1:
                LPSE_OQPG_dict=interface_dict1.setdefault('OQPG', {})
                OQ_Number=m.groupdict()['OQ_Number'].strip()
                LPSE_dict=LPSE_OQPG_dict.setdefault(OQ_Number, {})
                LPSE_dict['LPSE_OQ_0'] = m.groupdict()['LPSE_OQ_0']
                LPSE_dict['LPSE_OQ_1'] = m.groupdict()['LPSE_OQ_1']
                continue

            #| LPSE OID
            m=p16.match(line)
            if m:
                 interface_dict1['LPSE_OID']=int(m.groupdict()['LPSE_OID'])
                 continue
            #| LPSE CIR (Priority Queue) Rate      : 2000000000
            m=p17.match(line)
            if m:
                interface_dict1['LPSE_CIR_Rate']=int(m.groupdict()['LPSE_CIR_Rate'])
                continue

            #| LPSE CIR (Priority Queue) Burst     : SDK Default
            m=p18.match(line)
            if m:
                interface_dict1['LPSE_CIR_Burst']=m.groupdict()['LPSE_CIR_Burst']
                continue

            #| LPSE PIR (Sub-Interface Port) Rate  : 2000000000
            m=p19.match(line)
            if m:
                interface_dict1['LPSE_PIR_Rate']=int(m.groupdict()['LPSE_PIR_Rate'])
                continue

            #| LPSE PIR (Sub-Interface Port) Burst : SDK Default
            m=p20.match(line)
            if m:
                interface_dict1['LPSE_PIR_Burst']=m.groupdict()['LPSE_PIR_Burst']
                continue

            #| LPSE Main Interface OQSE  : 3130 (0xC3A  )   | 3131 (0xC3B  )   |
            m=p21.match(line)
            if m:
                interface_dict1['LPSE_Main_Int']=int(m.groupdict()['LPSE_Main_Int'])
                continue

            #| LPSE OQSE Credit CIR      : 60000000000      | 60000000000      |
            m=p22.match(line)
            if m:
                interface_dict1['LPSE_OQSE_CIR']=int(m.groupdict()['LPSE_OQSE_CIR'])
                continue

            #| LPSE OQSE Credit CIR Burst: SDK Default      | SDK Default      |
            m=p23.match(line)
            if m:
                interface_dict1['LPSE_OQSE_CIR_Burst']=m.groupdict()['LPSE_OQSE_CIR_Burst']
                continue

            #| LPSE OQSE Credit PIR      : 60000000000      | 60000000000      |
            m=p24.match(line)
            if m:
                interface_dict1['LPSE_OQSE_PIR']=int(m.groupdict()['LPSE_OQSE_PIR'])
                continue

            #| LPSE OQSE Credit PIR Burst: SDK Default      | SDK Default      |
            m=p25.match(line)
            if m:
                interface_dict1['LPSE_OQSE_PIR_Burst']=m.groupdict()['LPSE_OQSE_PIR_Burst']
                continue

            #| LPSE Total Attached OQSEs : 2
            m=p26.match(line)
            if m:
                interface_dict1['LPSE_Total']=int(m.groupdict()['LPSE_Total'])
                continue

            #| OQSE OID              : 4234
            m=p27.match(line)
            if m:
                 interface_dict1['oqse_oid']=int(m.groupdict()['oqse_oid'])
                 continue

            #| OQ    ID              : 0
            m=p28.match(line)
            if m:
                 interface_dict1['oq_id']=int(m.groupdict()['oq_id'])
                 continue

            #| Scheduling Mode       : Logical Port SP WFQ
            m=p29.match(line)
            if m:
                 interface_dict1['oq_scheduling_mode']=m.groupdict()['oq_scheduling_mode']
                 continue

            #| Credit CIR            : 2000000000
            m=p30.match(line)
            if m:
                 interface_dict1['oq_credit_cir']=int(m.groupdict()['oq_credit_cir'])
                 continue

            #| Credit CIR Burst      : SDK Default
            m=p31.match(line)
            if m:
                 interface_dict1['oq_credit_cir_burst']=m.groupdict()['oq_credit_cir_burst']
                 continue

            #| Credit PIR            : 2000000000
            m=p32.match(line)
            if m:
                 interface_dict1['oq_credit_pir']=int(m.groupdict()['oq_credit_pir'])
                 continue

            #| Credit PIR Burst      : SDK Default
            m=p33.match(line)
            if m:
                 interface_dict1['oq_credit_pir_burst']=m.groupdict()['oq_credit_pir_burst']
                 continue

            #| Transmit PIR          : 60000000000
            m=p34.match(line)
            if m:
                 interface_dict1['oq_transmit_pir']=int(m.groupdict()['oq_transmit_pir'])
                 continue

            #| Transmit PIR Burst    : SDK Default
            m=p35.match(line)
            if m:
                 interface_dict1['oq_transmit_pir_burst']=m.groupdict()['oq_transmit_pir_burst']

                 continue
        return ret_dict

class ShowPlatformSoftwareFedIfmSchema(MetaParser):

    schema = {
            'interfaces': {
                Any(): {
                    'if_id': str,
                    'state': str
                }
             }
    }

class ShowPlatformSoftwareFedIfm(ShowPlatformSoftwareFedIfmSchema):

    cli_command = 'show platform software fed switch active ifm interfaces tunnel'

    def cli(self, output=None):
        if output is None:
            out = self.device.execute(self.cli_command)
        else:
            out = output

        parsed_dict = {}

        # Tunnel1 0x0000005d READY
        p1=re.compile(r'^(?P<interface>(^[a-zA-Z]+[0-9])) +(?P<if_id>\w+) +(?P<state>[\w\s]+)$')
        for line in out.splitlines():
            line = line.strip()

            # Tunnel1 0x0000005d READY
            m=p1.match(line)
            if m:
                group = m.groupdict()
                interface = group['interface']
                interface_dict = parsed_dict.setdefault('interfaces', {}).setdefault(interface, {})
                interface_dict['if_id'] = group['if_id']
                interface_dict['state'] = str(group['state'])

                continue
        return parsed_dict

class ShowSystemMtuSchema(MetaParser):
    """
    Schema for show system mtu
    """
    schema = {
            'mtu_in_bytes': int
                }

class ShowSystemMtu(ShowSystemMtuSchema):
    """ Parser for show system mtu"""

    cli_command = 'show system mtu'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        # initial variables
        ret_dict = {}

        # Global Ethernet MTU is 1500 bytes
        p1 = re.compile(r'^Global\s+Ethernet\s+MTU\s+is\s+(?P<mtu_in_bytes>\d+)\s+bytes\.$')


        for line in output.splitlines():
            line = line.strip()

            # Global Ethernet MTU is 1500 bytes
            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict['mtu_in_bytes'] =int(group['mtu_in_bytes'])
                continue
        return ret_dict

class ShowPlatformSoftwareFedIpsecCounterSchema(MetaParser):
    """Schema for show platform software fed switch active ipsec counters if-id all"""

    schema = {
    'if-id': str,
    Or('inbound_flow', 'outbound_flow'): {
        'flow_id': int,
        'sa_index': int,
        'asic_instance': str,
        'packet_format_check_error': int,
        'invalid_sa': int,
        'auth_fail': int,
        'sequence_number_overflows': int,
        'anti_replay_fail': int,
        'packet_count': int,
        'byte_count': int
    }
}

class ShowPlatformSoftwareFedIpsecCounter(ShowPlatformSoftwareFedIpsecCounterSchema):
    """ Parser for
       show platform software fed switch active ipsec counters if-id all
    """

    cli_command = 'show platform software fed switch active ipsec counters if-id all'
    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        ret_dict = {}
        inbound_flag = True

        # Flow Stats for if-id 0x62
        p1 = re.compile(r'^[Ff]low +[Ss]tats +for +if-id +(?P<if_id>\w+)$')

        # Inbound Flow Info for flow id: 44
        p2 = re.compile(r'^[Ii]nbound +[Ff]low +[Ii]nfo +for +flow +id+\: +(?P<flow_id>\d+)$')

        # SA Index: 3
        p3 = re.compile(r'^SA +Index+\: +(?P<sa_index>\d+)$')

        # Asic Instance 0: SA Stats
        p4 = re.compile(r'^[Aa]sic +Instance +0+\: +(?P<asic_instance>[\w\s]+)$')

        # Packet Format Check Error: 0
        p5 = re.compile(r'^[Pp]acket +[Ff]ormat +[Cc]heck +[Ee]rror+\: +(?P<packet_format_check_error>\d+)$')

        # Invalid SA: 0
        p6 = re.compile(r'^[Ii]nvalid +SA+\: +(?P<invalid_sa>\d+)$')

        # Auth Fail: 0
        p7 = re.compile(r'^[Aa]uth +[Ff]ail+\: +(?P<auth_fail>\d+)$')

        # Sequence Number Overflows: 0
        p8 = re.compile(r'^[Ss]equence +[Nn]umber +[Oo]verflows+\: +(?P<sequence_number_overflows>\d+)$')

        # Anti-Replay Fail: 0
        p9 = re.compile(r'^[Aa]nti\-+[Rr]eplay +[Ff]ail+\: +(?P<anti_replay_fail>\d+)$')

        # Packet Count: 2056
        p10 = re.compile(r'^[Pp]acket +[Cc]ount+\: +(?P<packet_count>\d+)$')

        # Byte Count: 177076
        p11 = re.compile(r'^[Bb]yte +[Cc]ount+\: +(?P<byte_count>\d+)$')

        # Outbound Flow Info for flow id: 43
        p12 = re.compile(r'^[Oo]utbound +[Ff]low +[Ii]nfo +for +flow +id+\: +(?P<flow_id>\d+)$')

        for line in output.splitlines():
            line = line.strip()
            inbound_dict = ret_dict.setdefault('inbound_flow', {})
            outbound_dict = ret_dict.setdefault('outbound_flow', {})

            # Flow Stats for if-id 0x62
            m = p1.match(line)
            if m:
                ret_dict['if-id'] = m.groupdict()['if_id']

            #Inbound Flow Info for flow id: 44
            m = p2.match(line)
            if m:
                inbound_flag = True
                inbound_dict['flow_id'] = int(m.groupdict()['flow_id'])
                expected_dict = inbound_dict
                continue

            # SA Index: 3
            m = p3.match(line)
            if m:
                expected_dict['sa_index'] = int(m.groupdict()['sa_index'])
                continue

            # Asic Instance 0: SA Stats
            m = p4.match(line)
            if m:
                expected_dict['asic_instance'] = m.groupdict()['asic_instance']
                continue

            # Packet Format Check Error: 0
            m = p5.match(line)
            if m:
                expected_dict['packet_format_check_error'] = int(m.groupdict()['packet_format_check_error'])
                continue

            # Invalid SA: 0
            m = p6.match(line)
            if m:
                expected_dict['invalid_sa'] = int(m.groupdict()['invalid_sa'])
                continue

            # Auth Fail: 0
            m = p7.match(line)
            if m:
                expected_dict['auth_fail'] = int(m.groupdict()['auth_fail'])
                continue

            # Sequence Number Overflows: 0
            m = p8.match(line)
            if m:
                expected_dict['sequence_number_overflows'] = int(m.groupdict()['sequence_number_overflows'])
                continue

            # Anti-Replay Fail: 0
            m = p9.match(line)
            if m:
                expected_dict['anti_replay_fail'] = int(m.groupdict()['anti_replay_fail'])
                continue

            # Packet Count: 2056
            m = p10.match(line)
            if m:
                expected_dict['packet_count'] = int(m.groupdict()['packet_count'])
                continue

            # Byte Count: 177076
            m = p11.match(line)
            if m:
                expected_dict['byte_count'] = int(m.groupdict()['byte_count'])
                continue

            # Outbound Flow Info for flow id: 43
            m = p12.match(line)
            if m:
                inbound_flag = False
                outbound_dict['flow_id'] = int(m.groupdict()['flow_id'])
                expected_dict = outbound_dict
                continue

            # SA Index: 3
            m = p3.match(line)
            if m:
                expected_dict['sa_index'] = int(m.groupdict()['sa_index'])
                continue

            # Asic Instance 0: SA Stats
            m = p4.match(line)
            if m:
                expected_dict['asic_instance'] = m.groupdict()['asic_instance']
                continue

            # Packet Format Check Error: 0
            m = p5.match(line)
            if m:
                expected_dict['packet_format_check_error'] = int(m.groupdict()['packet_format_check_error'])
                continue

            # Invalid SA: 0
            m = p6.match(line)
            if m:
                expected_dict['invalid_sa'] = int(m.groupdict()['invalid_sa'])
                continue

            # Auth Fail: 0
            m = p7.match(line)
            if m:
                expected_dict['auth_fail'] = int(m.groupdict()['auth_fail'])
                continue

            # Sequence Number Overflows: 0
            m = p8.match(line)
            if m:
                expected_dict['sequence_number_overflows'] = int(m.groupdict()['sequence_number_overflows'])
                continue

            # Anti-Replay Fail: 0
            m = p9.match(line)
            if m:
                expected_dict['anti_replay_fail'] = int(m.groupdict()['anti_replay_fail'])
                continue

            # Packet Count: 2056
            m = p10.match(line)
            if m:
                expected_dict['packet_count'] = int(m.groupdict()['packet_count'])
                continue

            # Byte Count: 177076
            m = p11.match(line)
            if m:
                expected_dict['byte_count'] = int(m.groupdict()['byte_count'])
                continue

        return ret_dict

class ShowPlatformHardwareQfpIpsecDropSchema(MetaParser):
    """
    Schema for show platform hardware qfp active feature ipsec data drop
    """
    schema = {
            'drops': {
                Any(): {
                    'drop_type': int,
                    'packets': int
                    },
                }
            }

class ShowPlatformHardwareQfpIpsecDrop(ShowPlatformHardwareQfpIpsecDropSchema):
    """ Parser for show platform hardware qfp active feature ipsec data drop"""

    cli_command = 'show platform hardware qfp active feature ipsec data drop'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        # 4  IN_US_V4_PKT_SA_NOT_FOUND_SPI                           67643
        p1 = re.compile(r"^(?P<drop_type>\d+).* +(?P<drop_name>[\w\_]+).* +(?P<packets>\d+)$")

        master_dict={}
        for line in output.splitlines():
            line=line.strip()

            # 4  IN_US_V4_PKT_SA_NOT_FOUND_SPI                           67643
            m = p1.match(line)
            if m:
                group = m.groupdict()
                drop_dict = master_dict.setdefault("drops", {}).setdefault(group['drop_name'], {})
                drop_dict.update({'drop_type':int(group['drop_type']), 'packets':int(group['packets'])})
                continue

        return master_dict

class ShowPlatformHardwareFedActiveQosQueueStatsSchema(MetaParser):
    """Schema for show platform hardware fed active qos queue stats"""
    schema = {
        'enqueue_counters':{
            int: {
                'buffers_count': int,
                'enqueue_th0': int,
                'enqueue_th1': int,
                'enqueue_th2': int,
                'q_policer': int,
            },
        },
        'drop_counters':{
            int:  {
                'drop_th0': int,
                'drop_th1': int,
                'drop_th2': int,
                's_buf_drop': int,
                'q_eb_drop': int,
                'q_policer_drop': int,
            },
        },
    }

class ShowPlatformHardwareFedActiveQosQueueStats(ShowPlatformHardwareFedActiveQosQueueStatsSchema):
    """
    Parser for:
        * show platform hardware fed active qos queue stats interface
        * show platform hardware fed switch 1 qos queue stats interface
    """

    cli_command = ['show platform hardware fed active qos queue stats interface {interface}',
            'show platform hardware fed switch {switch_num} qos queue stats interface {interface}']

    def cli(self, interface,output=None,switch_num=None):
        if output is None:
            if switch_num is None:
                cmd = self.cli_command[0].format(interface=interface)
            else:
                cmd = self.cli_command[1].format(switch_num=switch_num,interface=interface)

            output = self.device.execute(cmd)

        ret_dict = {}

        '''
        ----------------------------------------------------------------------------------------------
        Q Buffers          Enqueue-TH0          Enqueue-TH1          Enqueue-TH2             Qpolicer
        (Count)              (Bytes)              (Bytes)              (Bytes)              (Bytes)
        -- ------- -------------------- -------------------- -------------------- --------------------
        0       0                    0                13114            129171972                    0
        1       0                    0                    0            546062296                    0
        2       0                    0                    0                    0                    0
        3       0                    0                    0                    0                    0
        4       0                    0                    0                    0                    0
        5       0                    0                    0                    0                    0
        6       0                    0                    0                    0                    0
        7       0                    0                    0                    0                    0
       '''

        p1 = re.compile(r'(?P<Q>\d)\s+(?P<buffers_count>\d+)\s+(?P<enqueue_th0>\d+)\s+(?P<enqueue_th1>\d+)\s+(?P<enqueue_th2>\d+)\s+(?P<qpolicer>\d+)$')


        '''
        --------------------------------------------------------------------------------------------------------------------------------
        Q             Drop-TH0             Drop-TH1             Drop-TH2             SBufDrop              QebDrop         QpolicerDrop
                      (Bytes)              (Bytes)              (Bytes)              (Bytes)              (Bytes)              (Bytes)
        -- -------------------- -------------------- -------------------- -------------------- -------------------- --------------------
        0                    0                    0                    0                    0                    0                    0
        1                    0                    0                    0                    0                    0                    0
        2                    0                    0                    0                    0                    0                    0
        3                    0                    0                    0                    0                    0                    0
        4                    0                    0                    0                    0                    0                    0
        5                    0                    0                    0                    0                    0                    0
        6                    0                    0                    0                    0                    0                    0
        7                    0                    0                    0                    0                    0                    0
        '''

        p2 = re.compile(r'(?P<Q>\d)\s+(?P<drop_th0>\d+)\s+(?P<drop_th1>\d+)\s+(?P<drop_th2>\d+)\s+(?P<sbufDrop>\d+)\s+(?P<qebDrop>\d+)\s+(?P<qpolicerDrop>\d+)$')

        #AQM Global counters
        p3 = re.compile(r'AQM Global counters')

        for line in output.splitlines():
            line = line.strip()

            m=p3.match(line)
            if m:
                enqueue_counters=ret_dict.setdefault('enqueue_counters', {})
                drop_counters=ret_dict.setdefault('drop_counters', {})

            '''
            ----------------------------------------------------------------------------------------------
            Q Buffers          Enqueue-TH0          Enqueue-TH1          Enqueue-TH2             Qpolicer
            (Count)              (Bytes)              (Bytes)              (Bytes)              (Bytes)
            -- ------- -------------------- -------------------- -------------------- --------------------
            0       0                    0                13114            129171972                    0
            1       0                    0                    0            546062296                    0
            2       0                    0                    0                    0                    0
            3       0                    0                    0                    0                    0
            4       0                    0                    0                    0                    0
            5       0                    0                    0                    0                    0
            6       0                    0                    0                    0                    0
            7       0                    0                    0                    0                    0
            '''

            #AQM Global counters
            m=p1.match(line)
            if m:
               group = m.groupdict()
               q=int(group['Q'])
               enqueue_dict=enqueue_counters.setdefault(q,{})
               enqueue_dict.update({
                   'buffers_count': int(group['buffers_count']),
                   'enqueue_th0': int(group['enqueue_th0']),
                   'enqueue_th1': int(group['enqueue_th1']),
                   'enqueue_th2': int(group['enqueue_th2']),
                   'q_policer': int(group['qpolicer'])
               })
               continue

            '''
            --------------------------------------------------------------------------------------------------------------------------------
            Q             Drop-TH0             Drop-TH1             Drop-TH2             SBufDrop              QebDrop         QpolicerDrop
                      (Bytes)              (Bytes)              (Bytes)              (Bytes)              (Bytes)              (Bytes)
            -- -------------------- -------------------- -------------------- -------------------- -------------------- --------------------
            0                    0                    0                    0                    0                    0                    0
            1                    0                    0                    0                    0                    0                    0
            2                    0                    0                    0                    0                    0                    0
            3                    0                    0                    0                    0                    0                    0
            4                    0                    0                    0                    0                    0                    0
            5                    0                    0                    0                    0                    0                    0
            6                    0                    0                    0                    0                    0                    0
            7                    0                    0                    0                    0                    0                    0
            '''

            m=p2.match(line)
            if m:
               group = m.groupdict()
               q=int(group['Q'])
               drop_dict=drop_counters.setdefault(q,{})
               drop_dict.update({
                   'drop_th0':int(group['drop_th0']),
                   'drop_th1':int(group['drop_th1']),
                   'drop_th2':int(group['drop_th2']),
                   's_buf_drop':int(group['sbufDrop']),
                   'q_eb_drop':int(group['qebDrop']),
                   'q_policer_drop':int(group['qpolicerDrop'])
                  })
               continue

        return ret_dict

class ShowPlatformHardwarelabel2qmapQmapegressdataSchema(MetaParser):
    """Schema for show platform hardware fed active qos queue stats"""
    schema = {
        Any(): {
            'queue': int,
            'threshold': int,
            'v_queue': int,
        },
    }

class ShowPlatformHardwareFedActiveQosQueuelabel2qmapQmapegressdataInterface(ShowPlatformHardwarelabel2qmapQmapegressdataSchema):

    """
    Parser for:
        * show platform hardware fed active qos queue label2qmap qmap-egress-data interface
        * show platform hardware fed switch 1 qos queue label2qmap qmap-egress-data interface
    """

    cli_command = ['show platform hardware fed active qos queue label2qmap qmap-egress-data interface {interface}',
            'show platform hardware fed switch {switch_num} qos queue label2qmap qmap-egress-data interface {interface}']


    def cli(self, interface,output=None,switch_num=None):
        if output is None:
            if switch_num is None:
                cmd = self.cli_command[0].format(interface=interface)
            else:
                cmd = self.cli_command[1].format(switch_num=switch_num,interface=interface)

            output = self.device.execute(cmd)

        ret_dict = {}

        '''
        Egress DATA Queue Mapping  -  Asic/Core/Port: 0/0/0

        ===============================================================================
        Label   Q Threshold  VQ  |  Label   Q Threshold  VQ  |  Label   Q Threshold  VQ
        ===== === ========= ===  |  ===== === ========= ===  |  ===== === ========= ===
        0   1         2   0         1   1         2   0         2   1         2   0
        3   1         2   0         4   1         2   0         5   1         2   0
        '''
        p1=re.compile(r'(?P<Label>\d+)\s+(?P<Q>\d+)\s+(?P<Threshold>\d+)\s+(?P<VQ>\d+)\s+'+r'(?P<Label1>\d+)\s+(?P<Q1>\d+)\s+(?P<Threshold1>\d+)\s+(?P<VQ1>\d+)\s+'+r'(?P<Label2>\d+)\s+(?P<Q2>\d+)\s+(?P<Threshold2>\d+)\s+(?P<VQ2>\d+)')

        for line in output.splitlines():
            line = line.strip()
            '''
            Egress DATA Queue Mapping  -  Asic/Core/Port: 0/0/0
            ===============================================================================
            Label   Q Threshold  VQ  |  Label   Q Threshold  VQ  |  Label   Q Threshold  VQ
            ===== === ========= ===  |  ===== === ========= ===  |  ===== === ========= ===
              0   1         2   0         1   1         2   0         2   1         2   0
              3   1         2   0         4   1         2   0         5   1         2   0
            '''

            m=p1.match(line)
            if m:
                group=m.groupdict()
                label=int(group['Label'])
                label_dic=ret_dict.setdefault(label,{})
                label_dic['queue']=int(group['Q'])
                label_dic['threshold']=int(group['Threshold'])
                label_dic['v_queue']=int(group['VQ'])
                label1=int(group['Label1'])
                label_dic1=ret_dict.setdefault(label1,{})
                label_dic1['queue']=int(group['Q1'])
                label_dic1['threshold']=int(group['Threshold1'])
                label_dic1['v_queue']=int(group['VQ1'])
                label2=int(group['Label2'])
                label_dic2=ret_dict.setdefault(label2,{})
                label_dic2['queue']=int(group['Q2'])
                label_dic2['threshold']=int(group['Threshold2'])
                label_dic2['v_queue']=int(group['VQ2'])
                continue
        return ret_dict

# =======================================================
# Parser for 'Show Platform Software Fed Matm MacTable'
# =======================================================
class ShowPlatformSoftwareFedMatmMacTableSchema(MetaParser):
    """Schema for show Platform Software Fed matm MacTable"""

    schema = {
        'mac':{
             Any(): {
                Optional('mac'): str,
                Optional('vlanport'): int,
                Optional('type'): str,
                Optional('sequence'): int,
                Optional('ecbi'): int,
                Optional('flag'): int,
                Optional('machandle'):str,
                Optional('sihandle'):str,
                Optional('rihandle'):str,
                Optional('dihandle'):str,
                Optional('atime'):int,
                Optional('etime'):int,
                Optional('port'):str,
                Optional('con'):str
            }
        }
    }

class ShowPlatformSoftwareFedMatmMacTable(ShowPlatformSoftwareFedMatmMacTableSchema):
    """Parser for show Platform Software Fed matm mactable"""

    cli_command = 'show platform software fed {state} matm macTable vlan {vlan}'
    def cli(self, state='', vlan='', output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(state=state, vlan=vlan))
        platform_dict = {}

       # VLAN   MAC                  Type  Seq#    EC_Bi  Flags  machandle           siHandle            riHandle            diHandle              *a_time  *e_time  ports                                                         Con
       # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
       # 10     3c57.3104.6b42  0x5000001       0      0     64  0x7f61dd192978      0x7f61dcfb58a8      0x7f61dd1259e8      0x0                         0      798  VTEP 40.40.40.40 adj_id 1011                                  No

        p = re.compile(r'(?P<vlanport>\d+) +(?P<mac>[\w\.]+) + '
                r'(?P<type>\w+) +(?P<sequence>\d+) +'
                r'(?P<ecbi>\d+) +(?P<flag>\d+) +'
                r'(?P<machandle>\w+) +(?P<sihandle>\w+) +'
                r'(?P<rihandle>\w+) +(?P<dihandle>\w+) +'
                r'(?P<atime>\d+) + (?P<etime>[\d\s]+) +'
                r'(?P<port>[\w\.\_\/\s\s]+) + (?P<con>[\s\w\s]+)$')

        for line in output.splitlines():
            line = line.strip()
            m = p.match(line)
            if m:
                mac = m.groupdict()['mac']
                mac_dict = platform_dict.setdefault('mac', {}).setdefault(mac, {})
                value = ['mac','type','machandle','sihandle','rihandle','dihandle','port','con']
                mac_dict.update({k:v.replace(' ', '') if k in value else int(v) for (k,v) in m.groupdict().items()})

        return platform_dict

# ====================================================
# Parser for show Platform Software Fed igmp snooping'
# ====================================================
class ShowPlatformSoftwareFedIgmpSnoopingSchema(MetaParser):
    """Schema for show Platform Software Fed igmp snooping"""

    schema = {
        'vlan':{
             Any(): {
                Optional('igmp_en'): str,
                Optional('pimsn_en'): str,
                Optional('flood_md'): str,
                Optional('op_state'): str,
                Optional('stp_tcn_flood'): str,
                Optional('route_en'):str,
                Optional('pim_en'):str,
                Optional('pvlan'):str,
                Optional('in_retry'):str,
                Optional('cck_ep') : str,
                Optional('iosd_md') : str,
                Optional('evpn_en')  : str,
                Optional('l3m_adj')  : str,
                Optional('mroute_port')  : list,
                Optional('flood_port')  : list,
                Optional('rep_han')  : str,
            }
        }
    }

class ShowPlatformSoftwareFedIgmpSnooping(ShowPlatformSoftwareFedIgmpSnoopingSchema):
    """Parser for show Platform Software Fed igmp snooping"""

    cli_command = 'show platform software fed {state} ip igmp snooping vlan {vlan}'

    def cli(self, state='', vlan='', output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(state=state, vlan=vlan))
        platform_dict = {}

        # Vlan 20
        # ---------
        # IGMPSN Enabled : On

        # Vlan 20
        p0 = re.compile(r'^Vlan\s+(?P<vlan>\d+)$')

        # IGMPSN Enabled : On
        p1 = re.compile('^IGMPSN\s+Enabled\s+:\s+(?P<igmp_en>[\s\w\s]+)$')

        # PIMSN Enabled : Off
        p2 = re.compile('^PIMSN\s+Enabled\s+:\s+(?P<pimsn_en>[\s\w\s]+)$')

        # Flood Mode : Off
        p3 = re.compile('^Flood\s+Mode\s+:\s+(?P<flood_md>[\s\w\s]+)$')

        # Oper State : Up
        p4 = re.compile('^Oper\s+State\s+:\s+(?P<op_state>[\s\w\s]+)$')

        # STP TCN Flood : Off
        p5 = re.compile('^STP\s+TCN\s+Flood\s+:\s+(?P<stp_tcn_flood>[\s\w\s]+)$')

        # Routing Enabled : On
        p6 = re.compile('^Routing\s+Enabled\s+:\s+(?P<route_en>[\s\w\s]+)$')

        # PIM Enabled : On
        p7 = re.compile('^PIM\s+Enabled\s+:\s+(?P<pim_en>[\s\w\s]+)$')

        # PVLAN : No
        p8 = re.compile('^PVLAN\s+:\s+(?P<pvlan>[\s\w\s]+)$')

        # In Retry : 0x0
        p9 = re.compile('^In\s+Retry\s+:\s+(?P<in_retry>[\s\w\s]+)$')

        # CCK Epoch : 0x17
        p10 = re.compile('^CCK\s+Epoch\s+:\s+(?P<cck_ep>[\s\w\s]+)$')

        # IOSD Flood Mode : Off
        p11 = re.compile('^IOSD\s+Flood\s+Mode\s+:\s+(?P<iosd_md>[\s\w\s]+)$')

        # EVPN Proxy Enabled : On
        p12 = re.compile('^EVPN\s+Proxy\s+Enabled\s+:\s+(?P<evpn_en>[\s\w\s]+)$')

        # L3mcast Adj :
        p13 = re.compile('L3mcast\\s+Adj\\s+:(?P<l3m_adj>.*)')

        # Mrouter PortQ :
        p14 = re.compile('^Mrouter\s+PortQ\s+:\s*')
        # nve1.VNI60020(0x200000071)
        p14_1 = re.compile("([A-Za-z]*\d[-().]*){10,}")

        # Flood PortQ :
        p15 = re.compile('^Flood PortQ\s+:\s*')
        # TenGigabitEthernet7/0/13
        # FiveGigabitEthernet1/0/2
        # GigabitEthernet2/0/31
        p15_1 = re.compile('^[A-Za-z]+[\d\/]+$')

        # REP RI handle : 0x0
        p16 = re.compile('^REP\s+RI\s+handle\s+:\s+(?P<rep_han>[\s\w\s]+)$')

        mroute_port_flag = 0
        mroute_list = []
        floodport_flag = 0
        floodport_list = []
        for line in output.splitlines():
            line = line.strip()

            # Vlan 20
            m = p0.match(line)
            if m:
                vlan = int(m.groupdict()['vlan'])
                mac_dict = platform_dict.setdefault('vlan', {}).setdefault(vlan, {})

            # IGMPSN Enabled : On
            m = p1.match(line)
            if m:
                mac_dict['igmp_en'] = m.groupdict()['igmp_en']
                continue

            # PIMSN Enabled : Off
            m = p2.match(line)
            if m:
                mac_dict['pimsn_en'] = m.groupdict()['pimsn_en']
                continue

            # Flood Mode : Off
            m = p3.match(line)
            if m:
                mac_dict['flood_md'] = m.groupdict()['flood_md']
                continue

            # Oper State : Up
            m = p4.match(line)
            if m:
                mac_dict['op_state'] = m.groupdict()['op_state']
                continue

            # STP TCN Flood : Off
            m = p5.match(line)
            if m:
                mac_dict['stp_tcn_flood'] = m.groupdict()['stp_tcn_flood']
                continue

            # Routing Enabled : On
            m = p6.match(line)
            if m:
                mac_dict['route_en'] = m.groupdict()['route_en']
                continue

            # PIM Enabled : On
            m = p7.match(line)
            if m:
                mac_dict['pim_en'] = m.groupdict()['pim_en']
                continue

            # PVLAN : No
            m = p8.match(line)
            if m:
                mac_dict['pvlan'] = m.groupdict()['pvlan']
                continue

            # In Retry : 0x0
            m = p9.match(line)
            if m:
                mac_dict['in_retry'] = m.groupdict()['in_retry']
                continue

            # CCK Epoch : 0x17
            m = p10.match(line)
            if m:
                mac_dict['cck_ep'] = m.groupdict()['cck_ep']
                continue

            # IOSD Flood Mode : Off
            m = p11.match(line)
            if m:
                mac_dict['iosd_md'] = m.groupdict()['iosd_md']
                continue

            # EVPN Proxy Enabled : On
            m = p12.match(line)
            if m:
                mac_dict['evpn_en'] = m.groupdict()['evpn_en']
                continue

            # L3mcast Adj :
            m = p13.match(line)
            if m:
                mac_dict['l3m_adj'] = m.groupdict()['l3m_adj']
                continue
            # else:
            #     mac_dict['l3m_adj'] = ''
            #     continue

            # Mrouter PortQ :
            m = p14.match(line)
            if m:
                mac_dict['mroute_port'] = mroute_list
                mroute_port_flag = 1
                continue

            # nve1.VNI60020(0x200000071)
            m = p14_1.match(line)
            if m:
                if mroute_port_flag == 1:
                    mroute_list.append(m.group(0))
                elif floodport_flag == 1:
                    floodport_list.append(m.group(0))


            # TenGigabitEthernet7/0/13
            # FiveGigabitEthernet1/0/2
            # GigabitEthernet2/0/31
            m = p15_1.match(line)
            if m:
                if mroute_port_flag == 1:
                    mroute_list.append(m.group(0))
                elif floodport_flag == 1:
                    floodport_list.append(m.group(0))

            # Flood PortQ :
            m = p15.match(line)
            if m:
                mroute_port_flag = 0
                floodport_flag = 1
                mac_dict['flood_port'] = floodport_list
                continue

            # REP RI handle : 0x0
            m = p16.match(line)
            if m:
                mac_dict['rep_han'] = m.groupdict()['rep_han']
                continue

        return platform_dict

# ===================================================================
# Parser for show Platform Software Fed ip igmp snooping groups vlan'
# ===================================================================
class ShowPlatformSoftwareFedIgmpSnoopingGroupsSchema(MetaParser):
    """Schema for show Platform Software Fed ip igmp snooping groups vlan """
    schema = {
        'vlan':{
             Any(): {
                Optional('group'): str,
                Optional('mem_port'): list,
                Optional('cck_ep'): int,
                Optional('fail_flag'): int,
                Optional('di_hand'):str,
                Optional('rep_ri'):str,
                Optional('si_hand'):str,
                Optional('htm_hand'):str,
            }
        }
    }

class ShowPlatformSoftwareFedIgmpSnoopingGroups(ShowPlatformSoftwareFedIgmpSnoopingGroupsSchema):
    """Parser for show Platform Software Fed ip igmp snooping groups vlan"""

    cli_command = 'show platform software fed {state} ip igmp snooping groups vlan {vlan}'

    def cli(self, state='', vlan='', output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(state=state, vlan=vlan))
        platform_dict = {}

        # Vlan:20 Group:229.1.1.1
        # ---------------------------------
        # Member ports :
        # TenGigabitEthernet7/0/13
        # nve1.VNI60020(0x200000062)

        # Vlan:20 Group:229.1.1.1
        p0 = re.compile(r'(^Vlan+:+(?P<vlan>\d+))+\s+(Group:+(?P<group>\w.*))')

        # Member ports :
        p1 = re.compile(r'(^Member +ports   :(?P<mem_port>.*))')
        # TenGigabitEthernet7/0/13
        p1_1 = re.compile("([A-Za-z]*\d[-().]*){10,}")
        # nve1.VNI60020(0x200000062)
        p1_2 = re.compile('^[A-Za-z]+[\d\/]+$')

        # CCK_epoch : 1
        p2 = re.compile(r'(^CCK_epoch+ +:+ +(?P<cck_ep>\d.*)$)')

        # Failure Flags : 0
        p3 = re.compile(r'(^Failure+ +Flags+ +:+ +(?P<fail_flag>\d.*)$)')

        # DI handle : 0x7f95a2320408
        p4 = re.compile(r'(^DI+ +handle+ +:+ +(?P<di_hand>\w.*)$)')

        # REP RI handle : 0x7f95a2320718
        p5 = re.compile(r'(^REP+ +RI+ +handle+ +:+ +(?P<rep_ri>\w.*)$)')

        # SI handle : 0x7f95a2321998
        p6 = re.compile(r'(^SI+ +handle+ +:+ +(?P<si_hand>\w.*)$)')

        # HTM handle : 0x7f95a2321c28
        p7 = re.compile(r'(^HTM+ +handle+ +:+ +(?P<htm_hand>\w.*)$)')

        member_port_flag = 0
        member_list = []
        for line in output.splitlines():
            line = line.strip()

            # Vlan:20 Group:229.1.1.1
            m = p0.match(line)
            if m:
                vlan = m.groupdict()['vlan']
                mac_dict = platform_dict.setdefault('vlan', {}).setdefault(vlan, {})
                mac_dict['group'] = m.groupdict()['group']

            # Member ports :
            m = p1.match(line)
            if m:
                mac_dict['mem_port'] = member_list
                member_port_flag = 1
                continue
            # TenGigabitEthernet7/0/13
            m = p1_1.match(line)
            if m:
                if member_port_flag == 1:
                    member_list.append(m.group(0))
            # nve1.VNI60020(0x200000062)
            m = p1_2.match(line)
            if m:
                if member_port_flag == 1:
                    member_list.append(m.group(0))

            # CCK_epoch : 1
            m = p2.match(line)
            if m:
                mac_dict['cck_ep'] = int(m.groupdict()['cck_ep'])
                continue

            # Failure Flags : 0
            m = p3.match(line)
            if m:
                mac_dict['fail_flag'] = int(m.groupdict()['fail_flag'])
                continue

            # DI handle : 0x7f95a2320408
            m = p4.match(line)
            if m:
                mac_dict['di_hand'] = m.groupdict()['di_hand']
                continue

            # REP RI handle : 0x7f95a2320718
            m = p5.match(line)
            if m:
                mac_dict['rep_ri'] = m.groupdict()['rep_ri']
                continue

            # SI handle : 0x7f95a2321998
            m = p6.match(line)
            if m:
                mac_dict['si_hand'] = m.groupdict()['si_hand']
                continue

            # HTM handle : 0x7f95a2321c28
            m = p7.match(line)
            if m:
                mac_dict['htm_hand'] = m.groupdict()['htm_hand']
                continue

        return platform_dict

# ================================================================
# Parser for show Platform Software Fed ipv6 mld snooping groups'
# ================================================================
class ShowPlatformSoftwareFedIpv6MldSnoopingGroupsVlanSchema(MetaParser):
    """Schema for show Platform Software Fed ipv6 mld snooping groups"""
    schema = {
        'vlan':{
             Any(): {
                Optional('group'): str,
                Optional('mem_port'): list,
                Optional('cck_ep'): int,
                Optional('fail_flag'): int,
                Optional('di_hand'):str,
                Optional('rep_ri'):str,
                Optional('si_hand'):str,
                Optional('htm_hand'):str,
            }
        }
    }

class ShowPlatformSoftwareFedIpv6MldSnoopingGroupsVlan(ShowPlatformSoftwareFedIpv6MldSnoopingGroupsVlanSchema):
    """Parser for show Platform Software Fed ipv6 mld snooping groups"""

    cli_command = 'show platform software fed {state} ipv6 mld snooping groups vlan {vlan}'

    def cli(self, state='', vlan='', output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(state=state, vlan=vlan))
        platform_dict = {}

        # Vlan:20 Group:ff1e::50
        # ---------------------------------
        # Member ports   :
        #     TenGigabitEthernet1/0/1
        #     nve1.VNI60020(0x200000063)

        # Vlan:20 Group:ff1e::50
        p0 = re.compile(r'(^Vlan:+(?P<vlan>\d+))+\s+(Group:+(?P<group>\w.*))')

        # Member ports :
        p1 = re.compile(r'(^Member+ +ports+   :+(?P<mem_port>.*))')
        # TenGigabitEthernet1/0/1
        p1_1 = re.compile("([A-Za-z]*\d[-().]*){10,}")
        # nve1.VNI60020(0x200000063)
        p1_2 = re.compile('^[A-Za-z]+[\d\/]+$')

        # CCK_epoch : 1
        p2 = re.compile(r'(^CCK_epoch+ +:+ +(?P<cck_ep>\d.*)$)')

        # Failure Flags : 0
        p3 = re.compile(r'(^Failure+ +Flags+ +:+ +(?P<fail_flag>\d.*)$)')

        # DI handle      : 0x7f4f6eb86dd8
        p4 = re.compile(r'(^DI+ +handle+ +:+ +(?P<di_hand>\w.*)$)')

        # REP RI handle  : 0x7f4f6eb87218
        p5 = re.compile(r'(^REP+ +RI+ +handle+ +:+ +(?P<rep_ri>\w.*)$)')

        # SI handle      : 0x7f4f6eb880b8
        p6 = re.compile(r'(^SI+ +handle+ +:+ +(?P<si_hand>\w.*)$)')

        # HTM handle     : 0x7f4f6eb883c8
        p7 = re.compile(r'(^HTM+ +handle+ +:+ +(?P<htm_hand>\w.*)$)')

        member_port_flag = 0
        member_list = []
        for line in output.splitlines():
            line = line.strip()

            # Vlan:20 Group:ff1e::50
            m = p0.match(line)
            if m:
                vlan = m.groupdict()['vlan']
                mac_dict = platform_dict.setdefault('vlan', {}).setdefault(vlan, {})
                mac_dict['group'] = m.groupdict()['group']

            # Member ports :
            m = p1.match(line)
            if m:
                mac_dict['mem_port'] = member_list
                member_port_flag = 1
                continue
            # TenGigabitEthernet1/0/1
            m = p1_1.match(line)
            if m:
                if member_port_flag == 1:
                    member_list.append(m.group(0))
            # nve1.VNI60020(0x200000063)
            m = p1_2.match(line)
            if m:
                if member_port_flag == 1:
                    member_list.append(m.group(0))

            # CCK_epoch : 1
            m = p2.match(line)
            if m:
                mac_dict['cck_ep'] = int(m.groupdict()['cck_ep'])
                continue

            # Failure Flags : 0
            m = p3.match(line)
            if m:
                mac_dict['fail_flag'] = int(m.groupdict()['fail_flag'])
                continue

            # DI handle      : 0x7f4f6eb86dd8
            m = p4.match(line)
            if m:
                mac_dict['di_hand'] = m.groupdict()['di_hand']
                continue

            # REP RI handle  : 0x7f4f6eb87218
            m = p5.match(line)
            if m:
                mac_dict['rep_ri'] = m.groupdict()['rep_ri']
                continue

            # SI handle      : 0x7f4f6eb880b8
            m = p6.match(line)
            if m:
                mac_dict['si_hand'] = m.groupdict()['si_hand']
                continue

            # HTM handle     : 0x7f4f6eb883c8
            m = p7.match(line)
            if m:
                mac_dict['htm_hand'] = m.groupdict()['htm_hand']
                continue

        return platform_dict

# ======================================================================
# Parser for show Platform Software Fed active ipv6 mld snooping vlan'
# ======================================================================
class ShowPlatformSoftwareFedActiveIpv6MldSnoopingVlanSchema(MetaParser):
    """Schema for show Platform Software Fed active ipv6 mld snooping vlan"""
    schema = {
        'vlan':{
             Any(): {
                Optional('mldsn_en'): str,
                Optional('pimsn_en'): str,
                Optional('flood_md'): str,
                Optional('op_state'): str,
                Optional('stp_tcn_flood'): str,
                Optional('route_en'):str,
                Optional('pim_en'):str,
                Optional('pvlan'):str,
                Optional('in_retry'):str,
                Optional('cck_ep') : str,
                Optional('iosd_md') : str,
                Optional('evpn_en')  : str,
                Optional('l3m_adj')  : str,
                Optional('mroute_port')  : list,
                Optional('flood_port')  : list,
                Optional('rep_han')  : str,
            }
        }
    }
class ShowPlatformSoftwareFedActiveIpv6MldSnoopingVlan(ShowPlatformSoftwareFedActiveIpv6MldSnoopingVlanSchema):
    """Parser for show Platform Software Fed active ipv6 mld snooping vlan"""

    cli_command = 'show platform software fed {state} ipv6 mld snooping vlan {vlan}'

    def cli(self, state='', vlan='', output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(state=state, vlan=vlan))
        platform_dict = {}

        # Vlan 20
        # ---------
        # MLDSN Enabled : On
        # PIMSN Enabled : Off

        # Vlan 20
        p0 = re.compile(r'^Vlan\s+(?P<vlan>\d+)$')
        # MLDSN Enabled : On
        p1 = re.compile('MLDSN+  +Enabled  +: +(?P<mldsn_en>\w+)')

        # PIMSN Enabled : Off
        p2  = re.compile('PIMSN+ +Enabled+   +:+ +(?P<pimsn_en>\w+)')

        # Flood Mode : Off
        p3= re.compile('Flood+ +Mode+      +:+(?P<flood_md>.*)')

        # Oper State : Up
        p4= re.compile('Oper+ +State+    +:+ +(?P<op_state>\w+)')

        # STP TCN Flood : Off
        p5= re.compile('STP+ +TCN+ +Flood+   +:+ +(?P<stp_tcn_flood>\w+)')

        # Routing Enabled : On
        p6= re.compile('Routing+ +Enabled+ +:+ +(?P<route_en>\w+)')

        # PIM Enabled : On
        p7= re.compile('PIM+ +Enabled+ +:+ +(?P<pim_en>\w+)')

        # PVLAN : No
        p8= re.compile('PVLAN+ +:+ +(?P<pvlan>\w+)')

        # In Retry : 0x0
        p9= re.compile('In+ +Retry+ +:+ +(?P<in_retry>\w+)')

        # CCK Epoch : 0x17
        p10= re.compile('CCK+ +Epoch+ +:+ +(?P<cck_ep>\w+)')

        # IOSD Flood Mode : Off
        p11= re.compile('IOSD+ +Flood+ +Mode+ :+ +(?P<iosd_md>\w+)')

        # EVPN Proxy Enabled : On
        p12= re.compile('EVPN+ +Proxy+ +Enabled+ :+ +(?P<evpn_en>\w+)')

        # L3mcast Adj :
        p13=re.compile('L3mcast+ +Adj+      :+(?P<l3m_adj>.*)')

        # Mrouter PortQ :
        p14=re.compile('^Mrouter\s+PortQ\s+:\s*')
        # TenGigabitEthernet7/0/13
        p14_1 = re.compile("([A-Za-z]*\d[-().]*){10,}")

        # Flood PortQ :
        p15=re.compile('^Flood PortQ\s+:\s*')
        # TenGigabitEthernet7/0/13
        # FiveGigabitEthernet1/0/2
        # GigabitEthernet2/0/31
        p15_1 = re.compile('^[A-Za-z]+[\d\/]+$')

        # REP RI handle : 0x0
        p16= re.compile('REP+ +RI+ +handle+   :+(?P<rep_han>.*)')

        mroute_port_flag = 0
        mroute_list = []
        floodport_flag=0
        floodport_list = []
        for line in output.splitlines():
            line = line.strip()
            # Vlan 20
            m = p0.match(line)
            if m:
                vlan = m.groupdict()['vlan']
                mac_dict = platform_dict.setdefault('vlan', {}).setdefault(vlan, {})

            # MLDSN Enabled : On
            m = p1.match(line)
            if m:
                mac_dict['mldsn_en'] = m.groupdict()['mldsn_en']
                continue

            # PIMSN Enabled : Off
            m = p2.match(line)
            if m:
                mac_dict['pimsn_en'] = m.groupdict()['pimsn_en']
                continue

            # Flood Mode : Off
            m = p3.match(line)
            if m:
                mac_dict['flood_md'] = m.groupdict()['flood_md']
                continue

            # Oper State : Up
            m = p4.match(line)
            if m:
                mac_dict['op_state'] = m.groupdict()['op_state']
                continue

            # STP TCN Flood : Off
            m = p5.match(line)
            if m:
                mac_dict['stp_tcn_flood'] = m.groupdict()['stp_tcn_flood']
                continue

            # Routing Enabled : On
            m = p6.match(line)
            if m:
                mac_dict['route_en'] = m.groupdict()['route_en']
                continue

            # PIM Enabled : On
            m = p7.match(line)
            if m:
                mac_dict['pim_en'] = m.groupdict()['pim_en']
                continue

            # PVLAN : No
            m = p8.match(line)
            if m:
                mac_dict['pvlan'] = m.groupdict()['pvlan']
                continue

            # In Retry : 0x0
            m = p9.match(line)
            if m:
                mac_dict['in_retry'] = m.groupdict()['in_retry']
                continue

            # CCK Epoch : 0x17
            m = p10.match(line)
            if m:
                mac_dict['cck_ep'] = m.groupdict()['cck_ep']
                continue

            # IOSD Flood Mode : Off
            m = p11.match(line)
            if m:
                mac_dict['iosd_md'] = m.groupdict()['iosd_md']
                continue

            # EVPN Proxy Enabled : On
            m = p12.match(line)
            if m:
                mac_dict['evpn_en'] = m.groupdict()['evpn_en']
                continue

            # L3mcast Adj :
            m = p13.match(line)
            if m:
                mac_dict['l3m_adj'] = m.groupdict()['l3m_adj']
                # mac_dict['flood_port'] = p15
                continue

            # Mrouter PortQ :
            m = p14.match(line)
            if m:
                mac_dict['mroute_port'] = mroute_list
                mroute_port_flag = 1
                continue

            # TenGigabitEthernet7/0/13
            m = p14_1.match(line)
            if m:
                if mroute_port_flag == 1:
                    mroute_list.append(m.group(0))
                elif floodport_flag ==1:
                    floodport_list.append(m.group(0))

            # Flood PortQ :
            m = p15_1.match(line)
            if m:
                if mroute_port_flag == 1:
                    mroute_list.append(m.group(0))
                elif floodport_flag ==1:
                    floodport_list.append(m.group(0))

            # TenGigabitEthernet7/0/13
            # FiveGigabitEthernet1/0/2
            # GigabitEthernet2/0/31
            m = p15.match(line)
            if m:
                mroute_port_flag = 0
                floodport_flag = 1
                mac_dict['flood_port'] = floodport_list
                continue

            # REP RI handle : 0x0
            m = p16.match(line)
            if m:
                mac_dict['rep_han'] = m.groupdict()['rep_han']
                continue

        return platform_dict


class ShowPlatformHardwareVoltageMarginSwitchSchema(MetaParser):
    """
    Schema for show platform hardware voltage margin switch {mode} rp active
    """
    schema = {
        'max_channels': int,
        'channels': {
            Any(): {
                'rail_name': str,
                'voltage_in_mv': float,
                'nominal_voltage': float,
                'min_margin': float,
                'percentage_change': float,
                'max_margin': float,
                'monitor': int
               },
           }
       }

class ShowPlatformHardwareVoltageMarginSwitch(ShowPlatformHardwareVoltageMarginSwitchSchema):
    """ Parser for show platform hardware voltage margin switch {mode} rp active"""

    cli_command = 'show platform hardware voltage margin switch {mode} rp active'

    def cli(self, mode, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(mode=mode))

        # initial variables
        ret_dict = {}

        # max chnl 36
        p1 = re.compile('^max chnl\s+(?P<max_channels>\d+)$')

        # Channel  Rail Name         Voltage(mv)   Nominal Voltage  Min Margin  % Change  Max Margin  Monitor
        # 0        PVCCKRHV              1315.71        1300.00       -3.00        1.21        3.00       0
        p2 = re.compile('^(?P<channels>\S+)\s+(?P<rail_name>\S+)\s+(?P<voltage_in_mv>[\d+\.]+)\s+(?P<nominal_voltage>[\d+\.]+)\s+(?P<min_margin>\S+)\s+(?P<percentage_change>\S+)\s+(?P<max_margin>\S+)\s+(?P<monitor>\d+)$')


        for line in output.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict['max_channels'] = int(group['max_channels'])

            # Channel  Rail Name         Voltage(mv)   Nominal Voltage  Min Margin  % Change  Max Margin  Monitor
            # 0        PVCCKRHV              1315.71        1300.00       -3.00        1.21        3.00       0
            m = p2.match(line)
            if m:
                group = m.groupdict()
                channel_dict = ret_dict.setdefault('channels',{}).setdefault(int(group['channels']),{})
                channel_dict['rail_name'] = group['rail_name']
                channel_dict['voltage_in_mv']= float(group['voltage_in_mv'])
                channel_dict['nominal_voltage'] =float(group['nominal_voltage'])
                channel_dict['min_margin'] = float(group['min_margin'])
                channel_dict['percentage_change'] = float(group['percentage_change'])
                channel_dict['max_margin'] = float(group['max_margin'])
                channel_dict['monitor'] = int(group['monitor'])
                continue
        return ret_dict

class ShowPlatformHardwareQfpActiveInfrastructureBqsStatusSchema(MetaParser):

    """
    Schema for show platform hardware qfp active infrastructure bqs status | include QOS|QFP
    """
    schema = {
            Any(): {
                Optional('total_qos_queue'): int,
                Optional('total_qos_schedule_nodes'): int,
            }
    }

class ShowPlatformHardwareQfpActiveInfrastructureBqsStatus(ShowPlatformHardwareQfpActiveInfrastructureBqsStatusSchema):

    """Parser for show platform hardware qfp active infrastructure bqs status | include QOS|QFP """

    cli_command = ['show platform hardware qfp active infrastructure bqs status | include QOS|QFP']

    def cli(self, output=None):

        if output is None:
            output = self.device.execute(self.cli_command[0])

        # Initializes the Python dictionary variable
        parsed_dict = {}

        # QFP.0:
        p1 = re.compile(r'(?P<qfp_key>QFP\.\d+)')

        # # of QOS Queue Objects:                   1
        p2 = re.compile(r'^\#\s+of\s+QOS\s+Queue\s+Objects\:\s+(?P<total_qos_queue>\d+)')

        ## of QOS Schedule Objects :               2
        p3 = re.compile(r'^\#\s+of\s+QOS\s+Schedule\s+Objects\s+\:\s+(?P<total_qos_schedule_nodes>\d+)')

        key = "global"
        parsed_dict.setdefault(key, {})

        for line in output.splitlines():
            line = line.strip()

            # match QFP values
            m = p1.match(line)
            if m:
                group = m.groupdict()
                key = group['qfp_key']
                parsed_dict.setdefault(key, {})
                continue

            # match queue
            m = p2.match(line)
            if m:
                group = m.groupdict()
                parsed_dict[key]['total_qos_queue'] = int(group['total_qos_queue'])
                continue

            # match scheduling nodes
            m = p3.match(line)
            if m:
                group = m.groupdict()
                parsed_dict[key]['total_qos_schedule_nodes'] = int(group['total_qos_schedule_nodes'])
                continue

        return parsed_dict

class ShowPlatformHardwareQfpActiveFeatureQosInterfaceHierarchyDetailSchema(MetaParser):

    """
    Schema for show platform hardware qfp active feature qos interface Te0/1/0 hierarchy detail | include subdev
    """

    schema = {
        Optional('subdev'): int
        }

class ShowPlatformHardwareQfpActiveFeatureQosInterfaceHierarchyDetail(ShowPlatformHardwareQfpActiveFeatureQosInterfaceHierarchyDetailSchema):

    """
    Parser for show platform hardware qfp active feature qos interface Te0/1/0 hierarchy detail | include subdev
    """

    cli_command = ['show platform hardware qfp active feature qos interface {interface} hierarchy detail | include subdev']

    def cli(self, interface=None, output=None):

        if output is None:
            output = self.device.execute(self.cli_command[0].format(interface=interface))

        parsed_dict = {}

        # subdevice_id  : 1
        p1 = re.compile(r'subdevice_id\s+\:\s+(?P<subdev>\d+)')

        for line in output.splitlines():
            line = line.strip()

            # subdevice_id  : 1
            m = p1.match(line)
            if m:
                group = m.groupdict()
                parsed_dict['subdev'] = int(group['subdev'])
                continue

        return parsed_dict

class ShowPlatformSoftwareBPCrimsonContentConfigSchema(MetaParser):
    """Schema for show platform software bp crimson content config"""

    schema = {
        Any() : {
            'fipskey': str,
            'interface_details': {
                Any() : {
                    'link': int,
                    'slot': str,
                    }
                },
            'node_details': {
                'node_number': int,
                'priority': int,
              },
            'svl_link': {
                'link': int,
                },
            'svl_ports': {
                'domain': int,
                'mode': str,
                'node': int,
                'router_id': str,
                },
            },
    }

class ShowPlatformSoftwareBPCrimsonContentConfig(ShowPlatformSoftwareBPCrimsonContentConfigSchema):
    """ Parser for
       show platform software bp crimson content config
    """

    cli_command = 'show platform software bp crimson content config'
    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        ret_dict = {}

        # Node    Domain    Mode          Router-ID
        # 1       1         Aggregation   0.0.0.0
        p1 = re.compile(r'(?P<node>(\d)) +(?P<domain>(\d)) + (?P<mode>(\w+)) +(?P<router_id>(\S+))')

        # FIPSKEY
        # 4D56F017FFC920A5FA0EF11397788E917931D1D1AE48F9C0
        p2 = re.compile(r'^(?P<fipskey>(\w+)$)')

        # Node    Priority
        # 1       1
        p3 = re.compile(r'^(?P<node_number>(\d)) +(?P<priority>(\d))')

        # Configured SVL Links:
        # Link ID: 1
        p4 = re.compile(r'^Link +ID+\: +(?P<link>\d+)')

        # Interface                     Link    Slot:Bay:Port
        # HundredGigE1/0/13             1       1:0:13
        # HundredGigE1/0/14             1       1:0:14
        p5 = re.compile(r'^(?P<interface>(\S+)) +(?P<link>(\d+)) +(?P<slot>(\S+))$')

        for line in output.splitlines():
            line = line.strip()

            # Node    Domain    Mode          Router-ID
            # 1       1         Aggregation   0.0.0.0
            m = p1.match(line)
            if m:
                group = m.groupdict()
                domain_dict = node_dict.setdefault('svl_ports', {})
                domain_dict['node'] = int(group['node'])
                domain_dict['domain'] = int(group['domain'])
                domain_dict['mode'] = group['mode']
                domain_dict['router_id'] = group['router_id']
                continue

            # FIPSKEY
            # 4D56F017FFC920A5FA0EF11397788E917931D1D1AE48F9C0
            m = p2.match(line)
            if m:
                group = m.groupdict()
                node_dict['fipskey'] = group['fipskey']
                continue

            # Node    Priority
            # 1       1
            m = p3.match(line)
            if m:
                group = m.groupdict()
                node_number = group['node_number']
                node_dict = ret_dict.setdefault(node_number, {})
                priority_dict = node_dict.setdefault('node_details', {})
                priority_dict['node_number'] = int(group['node_number'])
                priority_dict['priority'] = int(group['priority'])
                continue

            # Configured SVL Links:
            # Link ID: 1
            m = p4.match(line)
            if m:
                group = m.groupdict()
                link_dict = node_dict.setdefault('svl_link', {})
                link_dict['link'] = int(group['link'])
                continue

            # Interface                     Link    Slot:Bay:Port
            # HundredGigE1/0/13             1       1:0:13
            # HundredGigE1/0/14             1       1:0:14
            m = p5.match(line)
            if m:
                group = m.groupdict()
                stack_ports = node_dict.setdefault('interface_details', {})
                each_ports = stack_ports.setdefault(group['interface'],{})
                each_ports['link'] = int(group['link'])
                each_ports['slot'] = group['slot']
                continue

        return ret_dict

class ShowPlatformSoftwareNodeClusterManagerSwitchB0NodeSchema(MetaParser):
    """
    Schema for show platform software node cluster-manager switch {mode} B0 node {node}
    """
    schema = {
        Any(): str,
    }

class ShowPlatformSoftwareNodeClusterManagerSwitchB0Node(ShowPlatformSoftwareNodeClusterManagerSwitchB0NodeSchema):
    """ Parser for show platform software node cluster-manager switch {mode} B0 node {node}"""

    cli_command = 'show platform software node cluster-manager switch {mode} B0 node {node}'

    def cli(self, mode, node, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(mode=mode, node=node))

        # initial variables
        ret_dict = {}
        # Node status is : NODE_STATUS_UP
        p1 = re.compile(r'^(?P<node_description>[\w\s]+)\: (?P<status>.*)$')

        for line in output.splitlines():
            line = line.strip()
            # Node status is : NODE_STATUS_UP
            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict[group['node_description']] = group['status']
                continue
        return ret_dict

# ======================================================================================
# Parser for 'show processes cpu platform sorted'
# ======================================================================================

class ShowProcessesCpuPlatformSorted(ShowProcessesCpuPlatform):
    """Parser for show processes cpu platform sorted"""

    cli_command = 'show processes cpu platform sorted'

    def cli(self, output=None):
        return(super().cli(output=output))


# ======================================================================================
# Parser Schema for 'show platform software punt-policer'
# ======================================================================================

class ShowPlatformSoftwarePuntPolicerSchema(MetaParser):
    """Schema for "show platform software punt-policer" """

    schema = {
        'punt_policer': {
            Any(): {
                  'description': str,
                  'config_rate_normal_pps': int,
                  'config_rate_high_pps': int,
                  'conform_pkts_normal': int,
                  'conform_pkts_high': int,
                  'dropped_pkts_normal': int,
                  'dropped_pkts_high': int,
                  'config_burst_normal_pkts': int,
                  'config_burst_high_pkts': int,
                  'config_alert_normal': str,
                  'config_alert_high': str
                 }
            }
       }

# ================================================================================
# Parser for 'show platform software punt-policer'
# ================================================================================

class ShowPlatformSoftwarePuntPolicer(ShowPlatformSoftwarePuntPolicerSchema):
    """ parser for "show platform software punt-policer" """

    cli_command = "show platform software punt-policer"

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        parsed_dict = {}

        #   2    IPv4 Options   4000     3000     0        0         0         0           4000     3000     Off      Off
        p1 = re.compile(r'^(?P<punt_cause>\d+)\s+(?P<description>(([A-Za-z0-9_-]+ ?){5}).*\s+|([A-Za-z0-9_-]+ ?))'
                       r'\s+(?P<config_rate_normal_pps>\d+)\s+(?P<config_rate_high_pps>\d+)\s+(?P<conform_pkts_normal>\d+)'
                       r'\s+(?P<conform_pkts_high>\d+)\s+(?P<dropped_pkts_normal>\d+)\s+(?P<dropped_pkts_high>\d+)'
                       r'\s+(?P<config_burst_normal_pkts>\d+)\s+(?P<config_burst_high_pkts>\d+)\s+(?P<config_alert_normal>\w+)'
                       r'\s+(?P<config_alert_high>\w+)$')

        for line in output.splitlines():
            line = line.strip()

            #   2    IPv4 Options  4000     3000     0       0      0       0        4000     3000     Off      Off
            m = p1.match(line)
            if m:
                group = m.groupdict()
                punt_cause = int(group.pop('punt_cause'))
                description = group.pop('description')
                config_alert_normal = group.pop('config_alert_normal')
                config_alert_high = group.pop('config_alert_high')
                punt_policer_dict = parsed_dict.setdefault('punt_policer',{}).setdefault(punt_cause,{})
                punt_policer_dict['description'] = description.rstrip()
                punt_policer_dict.update({k:int(v.rstrip().replace(' ','_').lower()) for k,v in group.items()})
                punt_policer_dict.update([('config_alert_normal', config_alert_normal),
                                          ('config_alert_high', config_alert_high)])

                continue

        return parsed_dict


class ShowFileSystemsSchema(MetaParser):
    """
    Schema for show file systems
    """
    schema = {
        'file_systems': {
                Any(): {
                    'total_size': int,
                    'free_size': int,
                    'type': str,
                    'flags': str,
                    'prefixes': str,
                }
        },
    }


class ShowFileSystems(ShowFileSystemsSchema):
    """
    Parser for show file systems
    """

    cli_command = 'show file systems'

    def cli(self, output=None):

        if output is None:
            output = self.device.execute(self.cli_command)
        # initialze return dictionary
        ret_dict = {}
        index = 0
        #*  11353194496    7130390528      disk     rw   flash-3:
        p0 = re.compile(r'^\*\s*(?P<total_size>\d+)\s*(?P<free_size>\d+)\s*(?P<type>\w+)\s*(?P<flags>\w+)\s*(?P<prefixes>[\S\s]+)$')
        #8162746368    8019398656      disk     ro   webui:
        p1 = re.compile(r'^(?P<total_size>\d+)\s*(?P<free_size>\d+)\s*(?P<type>\S*)\s*(?P<flags>\S*)\s*(?P<prefixes>[\S\s]+)$')

        for line in output.splitlines():
            line = line.strip()
            #*  11353194496    7130390528      disk     rw   flash-3:
            if p0.match(line):
                m = p0.match(line)
            else:
            #8162746368    8019398656      disk     ro   webui:
                m = p1.match(line)

            if m:
                group = m.groupdict()
                index += 1
                file_systems_dict = ret_dict.setdefault('file_systems', {}).setdefault(index, {})
                file_systems_dict.update({'total_size': int(group['total_size'])})
                file_systems_dict.update({'free_size': int(group['free_size'])})
                file_systems_dict.update({'type': group['type']})
                file_systems_dict.update({'flags': group['flags']})
                file_systems_dict.update({'prefixes': group['prefixes']})

        return ret_dict

# ============================================================================================
# Parser Schema for 'show platform hardware qfp active interface all statistics drop_summary'
# ============================================================================================

class ShowPlatformHardwareQfpActiveInterfaceAllStatisticsDropSummarySchema(MetaParser):
    """Schema for "show platform hardware qfp active interface all statistics drop_summary" """

    schema = {
        'drop_stats_summary': {
            Any(): {
                'rx_packets': int,
                'tx_packets': int
            },
        }
    }

# ======================================================================================
# Parser for 'show platform hardware qfp active interface all statistics drop_summary'
# ======================================================================================

class ShowPlatformHardwareQfpActiveInterfaceAllStatisticsDropSummary(
    ShowPlatformHardwareQfpActiveInterfaceAllStatisticsDropSummarySchema):
    """ parser for "show platform hardware qfp active interface all statistics drop_summary" """

    cli_command = "show platform hardware qfp active interface all statistics drop_summary"

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        parsed_dict = {}

        # GigabitEthernet0/0/0                                 16                   0
        p1 = re.compile(r'^(?P<intf_name>[a-zA-Z]+[\d/.]+)\s+(?P<rx_packets>\d+)\s+(?P<tx_packets>\d+)$')

        for line in output.splitlines():
            line = line.strip()

            # GigabitEthernet0/0/0                                 16                   0
            m = p1.match(line)
            if m:
                group = m.groupdict()
                intf_name = group.pop('intf_name')
                drop_stats_summary_dict = parsed_dict.setdefault('drop_stats_summary', {}). \
                    setdefault(intf_name, {})

                drop_stats_summary_dict.update({k: int(v) for k, v in group.items()})
                continue

        return parsed_dict

#=================================================================
#Parser Schema for show platform software factory-reset secure log
#=================================================================

class ShowPlatformSoftwareFactoryResetSecureLogSchema(MetaParser):

    """Schema for show platform software factory-reset secure log"""

    schema = {
        'start_time' : str,
        'end_time' : str,
        Any(): {
            Optional('mid'): str,
            Optional('nist'): str,
            Optional('pnm'): str,
            Optional('prv'): str,
            Optional('sn'): str,
            Optional('mnm'): str,
            Optional('status'): str
        }
    }

# ===========================================================
#  parser for show platform software factory-reset secure log
# ===========================================================

class ShowPlatformSoftwareFactoryResetSecureLog(ShowPlatformSoftwareFactoryResetSecureLogSchema):

    """Parser for  show platform software factory-reset secure log """

    cli_command = 'show platform software factory-reset secure log'

    def cli(self, output=None):

        if output is None:
            output = self.device.execute(self.cli_command)

        ret_dict = {}

        # START : 13-07-2022, 06:27:18
        p0 = re.compile(r'.*START\s+:\s+(?P<start_time>.*)')

        #   END : 13-07-2022, 06:30:01
        p1 = re.compile(r'.*END\s+:\s+(?P<end_time>.*)')

        #  -eMMC-
        p2 = re.compile(r'-(?P<partition>\S+)-$')

        #  PNM : nor
        #  NIST : PURGE
        p3 = re.compile(r'^(?P<partition_key>\S+)\s+:\s+(?P<partition_value>\S+)')

        for line in output.splitlines():
            line = line.strip()
            m = p0.match(line)

            if m :
               group = m.groupdict()
               ret_dict['start_time'] = group["start_time"]
               continue

            #   END : 13-07-2022, 06:30:01
            m1 = p1.match(line)

            if m1 :
                group = m1.groupdict()
                ret_dict['end_time'] = group["end_time"]
                continue

            # -eMMC-
            m2 = p2.match(line)

            if m2:
                group = m2.groupdict()
                partition_dict = ret_dict.setdefault(group["partition"], {})
                continue

            #  NIST : PURGE
            m3 = p3.match(line)
            if m3:
                group = m3.groupdict()
                partition_dict.update({group["partition_key"].lower():group["partition_value"]})
                continue

        return ret_dict

# ==========================================================================================
# Parser Schema for 'show platform hardware qfp active infra punt stat type per | ex _0_'
# ==========================================================================================

class ShowPlatformHardwareQfpActiveInfraPuntStatTypePerSchema(MetaParser):
    """Schema for "show platform hardware qfp {status} statistics drop | exclude _0_" """

    schema = {
    'global_punt_cause': {
        'number_of_punt_causes': int,
        'number_of_inject_causes': int,
        Any(): {
            'counter_id': {
                Any(): {
                    'cause_name': str,
                    'packet_received': int,
                    'packets_transmitted': int
                }
            }
        }
    }
}

# ================================================================================
# Parser for 'show platform hardware qfp active infra punt stat type per | ex _0_'
# ================================================================================

class ShowPlatformHardwareQfpActiveInfraPuntStatTypePer(ShowPlatformHardwareQfpActiveInfraPuntStatTypePerSchema):
    """ parser for "show platform hardware qfp active infra punt stat type per | ex _0_" """

    cli_command = "show platform hardware qfp active infra punt stat type per | ex _0_"

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        parsed_dict = {}

        # Number of punt causes =   160
        # Number of inject causes = 56
        p1 = re.compile(r'^(?P<name_of_cause>[A-Za-z ]+)=\s+(?P<no_of_causes>\d+)$')

        # Per Punt Cause Statistics
        # Per Inject Cause Statistics
        p2 = re.compile(r'^(?P<name_of_stats>Per+[A-Za-z ]+)$')

        # 003         Layer2 control and legacy                 3888454               3888454
        p3 = re.compile(r'^(?P<counter_id>\d+)\s+(?P<cause_name>([A-Za-z0-9_\/-<->]+ ?){5})\s+(?P<packet_received>\d+)\s+(?P<packets_transmitted>\d+)$')


        for line in output.splitlines():
            line = line.strip()

            # Number of punt causes =   160
            m = p1.match(line)
            if m:
                group = m.groupdict()
                punt_cause_stats_dict = parsed_dict.setdefault('global_punt_cause',{})
                punt_cause_dict = punt_cause_stats_dict.setdefault(group['name_of_cause'].lower().rstrip().replace(' ','_'),int(group['no_of_causes']))
                storage_dict = punt_cause_stats_dict
                continue

            # Per Punt Cause Statistics
            # Per Inject Cause Statistics
            m = p2.match(line)
            if m:
                group = m.groupdict()
                stats_name  = group['name_of_stats'].lower().replace(' ','_')
                stats_dict = storage_dict.setdefault(stats_name,{})
                continue

            # 003         Layer2 control and legacy                 3888454               3888454
            m = p3.match(line)
            if m:
                group = m.groupdict()
                counter_id = int(group.pop('counter_id'))
                name = (group.pop('cause_name')).rstrip().lower()
                punt_cause_dict = stats_dict.setdefault('counter_id',{}).setdefault(counter_id,{})
                punt_cause_dict['cause_name'] = name
                punt_cause_dict.update({k:int(v.rstrip()) for k,v in group.items()})
                continue

        return parsed_dict

# ======================================================================================
# Parser Schema for 'show platform hardware qfp active datapath infra sw-cio'
# ======================================================================================

class ShowPlatformHardwareQfpActiveDatapathInfraSwCioSchema(MetaParser):
    """Schema for "show platform hardware qfp active datapath infra sw-cio" """

    schema = {
        'infra_sw_cio': {
            'credits_usage': {
                'ids': {
                    int: {
                        'port': {
                            Any(): {
                                'wght': {
                                    Any(): {
                                        'global': int,
                                        'wrkr0': int,
                                        'wrkr1': int,
                                        'wrkr2': int,
                                        'wrkr3': int,
                                        'wrkr10': int,
                                        'wrkr11': int,
                                        'total': int
                                    }
                                }
                            }
                        }
                    }
                }
            },
            'core_utilization': {
                'preceding_secs': float,
                'id': {
                    int: {
                        'pp%': float,
                        'rx%': float,
                        'tm%': float,
                        'coff%': float,
                        'idle%': float
                    }
                }
            }
        }
    }

# ================================================================================
# Parser for 'show platform hardware qfp active datapath infra sw-cio'
# ================================================================================

class ShowPlatformHardwareQfpActiveDatapathInfraSwCio(ShowPlatformHardwareQfpActiveDatapathInfraSwCioSchema):
    """ parser for "show platform hardware qfp active datapath infra sw-cio" """

    cli_command = "show platform hardware qfp active datapath infra sw-cio"

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        parsed_dict = {}

        # Credits Usage:
        p1 = re.compile(r'^(?P<credits_usage>Credits\sUsage):$')

        # ID      Port  Wght  Global WRKR0  WRKR1  WRKR2  WRKR3  WRKR10  WRKR11  Total
        # 1      rcl0     4:   4999     0      0      0      0       0     121   5120
        p2 = re.compile(r'^(?P<id>\d+)\s+(?P<port>\w+)\s+(?P<wght>\d:+)\s+(?P<global>\d+)\s+(?P<wrkr0>\d+)\s+(?P<wrkr1>\d+)\s+(?P<wrkr2>\d+)\s+(?P<wrkr3>\d+)\s+(?P<wrkr10>\d+)\s+(?P<wrkr11>\d+)\s+(?P<total>\d+)$')

        # Core Utilization over preceding 95292.2911 seconds
        p3 = re.compile(r'^Core\sUtilization\sover\spreceding\s(?P<preceding_secs>[0-9.]+)\sseconds$')

        # ID:       0       1       2       3      10      11
        p4 = re.compile(r'^ID:\s+(?P<id0>\d+)\s+(?P<id1>\d+)\s+(?P<id2>\d+)\s+(?P<id3>\d+)\s+(?P<id10>\d+)\s+(?P<id11>\d+)$')

        # % PP:    0.10    0.73    0.65    0.11    0.00    0.00
        p5 = re.compile(r'^%\sPP:\s+(?P<id0>[0-9.]+)\s+(?P<id1>[0-9.]+)\s+(?P<id2>[0-9.]+)\s+(?P<id3>[0-9.]+)\s+(?P<id10>[0-9.]+)\s+(?P<id11>[0-9.]+)$')

        # % RX:    0.00    0.00    0.00    0.00    0.00    0.89
        p6 = re.compile(r'^%\sRX:\s+(?P<id0>[0-9.]+)\s+(?P<id1>[0-9.]+)\s+(?P<id2>[0-9.]+)\s+(?P<id3>[0-9.]+)\s+(?P<id10>[0-9.]+)\s+(?P<id11>[0-9.]+)$')

        # % TM:    0.00    0.00    0.00    0.00    0.78    0.00
        p7 = re.compile(r'^%\sTM:\s+(?P<id0>[0-9.]+)\s+(?P<id1>[0-9.]+)\s+(?P<id2>[0-9.]+)\s+(?P<id3>[0-9.]+)\s+(?P<id10>[0-9.]+)\s+(?P<id11>[0-9.]+)$')

        # % COFF:    0.00    0.00    0.00    0.00    0.00    0.00
        p8 = re.compile(r'^%\sCOFF:\s+(?P<id0>[0-9.]+)\s+(?P<id1>[0-9.]+)\s+(?P<id2>[0-9.]+)\s+(?P<id3>[0-9.]+)\s+(?P<id10>[0-9.]+)\s+(?P<id11>[0-9.]+)$')

        # % IDLE:   99.90   99.27   99.35   99.89   99.22   99.11
        p9 = re.compile(r'^%\sIDLE:\s+(?P<id0>[0-9.]+)\s+(?P<id1>[0-9.]+)\s+(?P<id2>[0-9.]+)\s+(?P<id3>[0-9.]+)\s+(?P<id10>[0-9.]+)\s+(?P<id11>[0-9.]+)$')


        for line in output.splitlines():
            line = line.strip()

            # Credits Usage:
            m = p1.match(line)
            if m:
                group = m.groupdict()
                infra_sw_cio_dict = parsed_dict.setdefault("infra_sw_cio",{})
                credits_dict = infra_sw_cio_dict.setdefault('credits_usage', {})
                continue

            # ID      Port  Wght  Global WRKR0  WRKR1  WRKR2  WRKR3  WRKR10  WRKR11  Total
            # 1      rcl0     4:   4999     0      0      0      0       0     121   5120
            m = p2.match(line)
            if m:
                group = m.groupdict()
                ids = int(group.pop('id'))
                port = group.pop('port')
                wght = group.pop('wght')
                ids = credits_dict.setdefault("ids", {}). \
                    setdefault(ids, {})
                ports = ids.setdefault('port',{}). \
                    setdefault(port, {})
                wghts = ports.setdefault('wght',{}). \
                    setdefault(wght, {})
                wghts.update({k: int(v) for k, v in group.items()})
                continue

            # Core Utilization over preceding 95292.2911 seconds
            m=p3.match(line)
            if m:
                group = m.groupdict()
                core_utilization_dict = infra_sw_cio_dict.setdefault('core_utilization',{})
                core_utilization_dict['preceding_secs'] = float(group['preceding_secs'])
                continue

            # ID:       0       1       2       3      10      11
            m=p4.match(line)
            if m:
                group = m.groupdict()
                core_utilization_id_dict = core_utilization_dict.setdefault('id', {})
                ids_list = [int(value) for value in group.values()]
                continue

            # % PP:    0.10    0.73    0.65    0.11    0.00    0.00
            m=p5.match(line)
            if m:
                group = m.groupdict()
                for index, value in enumerate(group.values()):
                    id_dict = core_utilization_id_dict.setdefault(ids_list[index], {})
                    id_dict['pp%'] = float(value)
                continue

            # % RX:    0.00    0.00    0.00    0.00    0.00    0.89
            m=p6.match(line)
            if m:
                group = m.groupdict()
                for index, value in enumerate(group.values()):
                    id_dict = core_utilization_id_dict.setdefault(ids_list[index], {})
                    id_dict['rx%'] = float(value)
                continue

            # % TM:    0.00    0.00    0.00    0.00    0.78    0.00
            m=p7.match(line)
            if m:
                group = m.groupdict()
                for index, value in enumerate(group.values()):
                    id_dict = core_utilization_id_dict.setdefault(ids_list[index], {})
                    id_dict['tm%'] = float(value)
                continue

            # % COFF:    0.00    0.00    0.00    0.00    0.00    0.00
            m=p8.match(line)
            if m:
                group = m.groupdict()
                for index, value in enumerate(group.values()):
                    id_dict = core_utilization_id_dict.setdefault(ids_list[index], {})
                    id_dict['coff%'] = float(value)
                continue

            # % IDLE:   99.90   99.27   99.35   99.89   99.22   99.11
            m=p9.match(line)
            if m:
                group = m.groupdict()
                for index, value in enumerate(group.values()):
                    id_dict = core_utilization_id_dict.setdefault(ids_list[index], {})
                    id_dict['idle%'] = float(value)
                continue

        return parsed_dict

# ======================================================================================
# Parser Schema for 'show platform hardware qfp active datapath infra sw-nic'
# ======================================================================================

class ShowPlatformHardwareQfpActiveDatapathInfraSwNicSchema(MetaParser):
    """Schema for "show platform hardware qfp active datapath infra sw-nic" """

    schema = {
        'infra_sw_nic': {
            'pmd_dict': {
                Any(): {
                    'device': str,
                    'rx': {
                        'rx_pkts': int,
                        'rx_bytes': int,
                        'rx_return': int,
                        'rx_badlen': int,
                        'pkts_burts': int,
                        'cycl_pkt': int,
                        'ext_cycl_pkt': int,
                        'total_ring_read': int,
                        'empty': int
                    },
                    'tx': {
                        'tx_pkts': int,
                        'tx_bytes': int,
                        Optional('pri_0_pkts'): int,
                        Optional('pri_0_bytes'): int,
                        Optional('pkts_send'): int
                    },
                    'total': {
                        'total_pkts_send': int,
                        'cycl_pkt': int,
                        'send': int,
                        'send_now': int,
                        'forced': int,
                        'poll': int,
                        'thd_poll': int,
                        'blocked': int,
                        'retries': int,
                        'mbuf_alloc_err': int,
                        'tx_queue_id': {
                            Any(): {
                                'full': int,
                                'current_index': int,
                                'hiwater': int
                            }
                        }
                    }
                }
            }
        }
    }

# ================================================================================
# Parser for 'show platform hardware qfp active datapath infra sw-nic'
# ================================================================================

class ShowPlatformHardwareQfpActiveDatapathInfraSwNic(ShowPlatformHardwareQfpActiveDatapathInfraSwNicSchema):
    """ parser for "show platform hardware qfp active datapath infra sw-nic" """

    cli_command = "show platform hardware qfp active datapath infra sw-nic"

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        parsed_dict = {}

        # pmd 46813180 device fpe0
        p1 = re.compile(r'^pmd\s+(?P<pmd>\w+)\sdevice\s(?P<device>\w+)$')

        # RX: pkts 15254  bytes 1498020 return 0 badlen 0
        p2 = re.compile(r'^RX:\spkts\s(?P<rx_pkts>\d+)\s+bytes\s(?P<rx_bytes>\d+)\sreturn\s(?P<rx_return>\d+)\s+badlen\s(?P<rx_badlen>\d+)$')

        # pkts/burst 1  cycl/pkt 938  ext_cycl/pkt 1390
        p3 = re.compile(r'^pkts/burst\s+(?P<pkts_burts>\d+)\s+cycl/pkt\s+(?P<cycl_pkt>\d+)\s+ext_cycl/pkt\s+(?P<ext_cycl_pkt>\d+)$')

        # Total ring read 4322810273, empty 4322795019
        p4 = re.compile(r'^Total\s+ring\s+read\s+(?P<total_ring_read>\d+),\s+empty\s+(?P<empty>\d+)$')

        # TX: pkts 2061  bytes 891639
        p5 = re.compile(r'TX:\s+pkts\s+(?P<tx_pkts>\d+)\s+bytes\s+(?P<tx_bytes>\d+)$')

        # pri-0: pkts 2068  bytes 892100
        p6 = re.compile(r'^pri-0:\s+pkts\s+(?P<pri_0_pkts>\d+)\s+bytes\s+(?P<pri_0_bytes>\d+)$')

        # pkts/send 1
        p7 = re.compile(r'^pkts/send\s(?P<pkts_send>\d+)$')

        # Total: pkts/send 1  cycl/pkt 1717
        p8 = re.compile(r'^Total:\spkts/send\s+(?P<total_pkts_send>\d+)\s+cycl/pkt\s+(?P<cycl_pkt>\d+)$')

        # send 2047  sendnow 0
        p9 = re.compile(r'^send\s(?P<send>\d+)\s+sendnow\s+(?P<send_now>\d+)$')

        # forced 2056  poll 0  thd_poll 0
        p10 = re.compile(r'^forced\s+(?P<forced>\d+)\s+poll\s+(?P<poll>\d+)\s+thd_poll\s+(?P<thd_poll>\d+)$')

        # blocked 0  retries 0  mbuf alloc err 0
        p11 = re.compile(r'blocked\s+(?P<blocked>\d+)\s+retries\s+(?P<retries>\d+)\s+mbuf\s+alloc\s+err\s+(?P<mbuf_alloc_err>\d+)$')

        # TX Queue 0: full 0  current index 0  hiwater 0
        p12 = re.compile(r'TX\s+Queue\s+(?P<tx_queue>\d+):\s+full\s+(?P<full>\d+)\s+current\s+index\s+(?P<current_index>\d+)\s+hiwater\s+(?P<hiwater>\d+)$')

        for line in output.splitlines():
            line = line.strip()

            # pmd 46813180 device fpe0
            m = p1.match(line)
            if m:
                group = m.groupdict()
                infra_sw_nic_dict = parsed_dict.setdefault('infra_sw_nic',{})
                pmd_dict = infra_sw_nic_dict.setdefault('pmd_dict', {}).setdefault(group['pmd'],{})
                pmd_dict['device'] = group['device']
                continue

            # RX: pkts 15254  bytes 1498020 return 0 badlen 0
            m = p2.match(line)
            if m:
                group = m.groupdict()
                rx_dict = pmd_dict.setdefault('rx',{})
                rx_dict['rx_pkts'] = int(group['rx_pkts'])
                rx_dict['rx_bytes'] = int(group['rx_bytes'])
                rx_dict['rx_return'] = int(group['rx_return'])
                rx_dict['rx_badlen'] = int(group['rx_badlen'])
                continue

            # pkts/burst 1  cycl/pkt 938  ext_cycl/pkt 1390
            m=p3.match(line)
            if m:
                group = m.groupdict()
                rx_dict['pkts_burts'] = int(group['pkts_burts'])
                rx_dict['cycl_pkt'] = int(group['cycl_pkt'])
                rx_dict['ext_cycl_pkt'] = int(group['ext_cycl_pkt'])
                continue

            # Total ring read 4322810273, empty 4322795019
            m=p4.match(line)
            if m:
                group = m.groupdict()
                rx_dict['total_ring_read'] = int(group['total_ring_read'])
                rx_dict['empty'] = int(group['empty'])
                continue

            #TX: pkts 2061  bytes 891639
            m=p5.match(line)
            if m:
                group = m.groupdict()
                tx_dict = pmd_dict.setdefault('tx',{})
                tx_dict['tx_pkts'] = int(group['tx_pkts'])
                tx_dict['tx_bytes'] = int(group['tx_bytes'])
                continue

            # pri-0: pkts 2061  bytes 891639
            m=p6.match(line)
            if m:
                group = m.groupdict()
                tx_dict['pri_0_pkts'] = int(group['pri_0_pkts'])
                tx_dict['pri_0_bytes'] = int(group['pri_0_bytes'])
                continue

            # pkts/send 1
            m=p7.match(line)
            if m:
                group = m.groupdict()
                tx_dict['pkts_send'] = int(group['pkts_send'])
                continue

            # Total: pkts/send 1  cycl/pkt 1717
            m=p8.match(line)
            if m:
                group = m.groupdict()
                total_dict = pmd_dict.setdefault('total',{})
                total_dict['total_pkts_send'] = int(group['total_pkts_send'])
                total_dict['cycl_pkt'] = int(group['cycl_pkt'])
                continue

            # send 2047  sendnow 0
            m=p9.match(line)
            if m:
                group = m.groupdict()
                total_dict['send'] = int(group['send'])
                total_dict['send_now'] = int(group['send_now'])
                continue

            # forced 2056  poll 0  thd_poll 0
            m=p10.match(line)
            if m:
                group = m.groupdict()
                total_dict['forced'] = int(group['forced'])
                total_dict['poll'] = int(group['poll'])
                total_dict['thd_poll'] = int(group['thd_poll'])
                continue

            # blocked 0  retries 0  mbuf alloc err 0
            m=p11.match(line)
            if m:
                group = m.groupdict()
                total_dict['blocked'] = int(group['blocked'])
                total_dict['retries'] = int(group['retries'])
                total_dict['mbuf_alloc_err'] = int(group['mbuf_alloc_err'])
                continue

            # TX Queue 0: full 0  current index 0  hiwater 0
            m=p12.match(line)
            if m:
                group = m.groupdict()
                tx_queue_dict = total_dict.setdefault('tx_queue_id',{}).setdefault(int(group['tx_queue']),{})
                tx_queue_dict['full'] = int(group['full'])
                tx_queue_dict['current_index'] = int(group['current_index'])
                tx_queue_dict['hiwater'] = int(group['hiwater'])
                continue

        return parsed_dict

# ==========================================================================================
# Parser Schema for 'show platform soft infra bipc | inc buffer'
# ==========================================================================================

class ShowPlatformSoftInfraBipcSchema(MetaParser):
    """Schema for "show platform soft infra bipc | inc buffer" """

    schema = {
        'platform_soft_infra_bipc': {
            'total_buffers_allocated': int,
            'total_buffers_freed': int,
            'total_buffer_alloc_failure': int
            },
        'buffers': {
            'rx_buffers_allocated': int,
            'rx_buffer_freed': int,
            'tx_buffer_allocated': int,
            'tx_buffer_freed': int
            },
        'failure': {
            'rx_buffer_alloc_failure': int,
            'tx_buffer_alloc_failure': int
            }
        }

# ================================================================================
# Parser for 'show platform soft infra bipc | inc buffer'
# ================================================================================

class ShowPlatformSoftInfraBipc(ShowPlatformSoftInfraBipcSchema):
    """ parser for "show platform soft infra bipc | inc buffer" """

    cli_command = "show platform soft infra bipc | inc buffer"

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        parsed_dict = {}

        # 338036 total buffers allocated
        p1 = re.compile(r'^(?P<total>\d+)\s+total\s+buffers\s+allocated$')

        # 338036 total buffers freed
        p2 = re.compile(r'^(?P<total>\d+)\s+total\s+buffers\s+freed$')

        # 307831 rx buffer allocated
        p3 = re.compile(r'^(?P<total>\d+)\s+rx\s+buffer\s+allocated$')

        # 307831 rx buffer freed
        p4 = re.compile(r'^(?P<total>\d+)\s+rx\s+buffer\s+freed$')

        # 30205 tx buffer allocated
        p5 = re.compile(r'^(?P<total>\d+)\s+tx\s+buffer\s+allocated$')

        # 30205 tx buffer freed
        p6 = re.compile(r'^(?P<total>\d+)\s+tx\s+buffer\s+freed$')

        # 0 total buffer alloc failure
        p7 = re.compile(r'^(?P<total>\d+)\s+total\s+buffer\s+alloc\s+failure$')

        # 0 rx buffer alloc failure
        p8 = re.compile(r'^(?P<total>\d+)\s+rx\s+buffer\s+alloc\s+failure$')

        # 0 tx buffer alloc failure
        p9 = re.compile(r'^(?P<total>\d+)\s+tx\s+buffer\s+alloc\s+failure$')

        for line in output.splitlines():
            line = line.strip()

            # 338036 total buffers allocated
            m = p1.match(line)
            if m:
                group = m.groupdict()
                buffer_info_dict = parsed_dict.setdefault("platform_soft_infra_bipc", {})
                buffer_info_dict['total_buffers_allocated'] = int(group['total'])
                continue

            #  338036 total buffers freed
            m = p2.match(line)
            if m:
                group = m.groupdict()
                buffer_info_dict['total_buffers_freed'] = int(group['total'])
                continue

            # 307831 rx buffer allocated
            m = p3.match(line)
            if m:
                group = m.groupdict()
                buffer_dict = parsed_dict.setdefault("buffers", {})
                buffer_dict['rx_buffers_allocated'] = int(group['total'])
                continue

            # 307831 rx buffer freed
            m = p4.match(line)
            if m:
                group = m.groupdict()
                buffer_dict['rx_buffer_freed'] = int(group['total'])
                continue

            # 30205 tx buffer allocated
            m = p5.match(line)
            if m:
                group = m.groupdict()
                buffer_dict['tx_buffer_allocated'] = int(group['total'])
                continue

            # 30205 tx buffer freed
            m = p6.match(line)
            if m:
                group = m.groupdict()
                buffer_dict['tx_buffer_freed'] = int(group['total'])
                continue

            # 0 total buffer alloc failure
            m = p7.match(line)
            if m:
                group = m.groupdict()
                buffer_info_dict['total_buffer_alloc_failure'] = int(group['total'])
                continue

            # 0 rx buffer alloc failure
            m = p8.match(line)
            if m:
                group = m.groupdict()
                failure_dict = parsed_dict.setdefault('failure', {})
                failure_dict['rx_buffer_alloc_failure'] = int(group['total'])
                continue

            # 0 tx buffer alloc failure
            m = p9.match(line)
            if m:
                group = m.groupdict()
                failure_dict['tx_buffer_alloc_failure'] = int(group['total'])
                continue

        return parsed_dict


# ======================================================================================
#  Schema for
#  * 'show platform hardware fed switch active fwd resource utilization | include LABEL'
# =======================================================================================
class ShowPlatformHardwareFedSwitchActiveFwdResourceUtilizationLabelSchema(MetaParser):
    """Schema for 'show platform hardware fed switch active fwd resource utilization | include LABEL'
    """
    schema = {
        'resource_name':{
            Any():{
                'allocated': int,
                'free': int,
                        }
                }
    }


# =======================================================================================
#  Parser for
#  * 'show platform hardware fed switch active fwd resource utilization | include LABEL'
# =======================================================================================

class ShowPlatformHardwareFedSwitchActiveFwdResourceUtilizationLabel(ShowPlatformHardwareFedSwitchActiveFwdResourceUtilizationLabelSchema):
    """
    Parser for :
        * show platform hardware fed switch active fwd resource utilization | include LABEL
    """
    cli_command = 'show platform hardware fed switch active fwd resource utilization | include {label}'

    def cli(self,label="",output=None):
        if output is None:
            cmd = self.cli_command.format(label=label)
            output = self.device.execute(cmd)
        else:
            output = output
        # initial return dictionary
        ret_dict ={}
        #RSC_LABEL_STACK_ID           6       65531
        p1 = re.compile(r'(?P<resource_name>\S+)\s+(?P<allocated>\d+)\s+(?P<free>\d+)$')
        for line in output.splitlines():
            line = line.strip()
            m = p1.match(line)
            if m:
                group = m.groupdict()
                resource_name = group['resource_name']
                sub_dict = ret_dict.setdefault('resource_name', {}).setdefault(resource_name, {})

                allocated = group['allocated']
                sub_dict['allocated'] = int(allocated)

                free = group['free']
                sub_dict['free'] = int(free)
                continue

        return ret_dict


# ===================================================================
# Parser Schema for 'show platform hardware qfp active system state'
# ===================================================================

class ShowPlatformHardwareQfpActiveSystemStateSchema(MetaParser):
    """Schema for "show platform hardware qfp active system state" """

    schema = {
        'cpp_ha_client_processes': {
            'total_processes': int,
            'registered_process': int,
            'client_processes': {
                'cpp_ha': str,
                'cpp_sp': str,
                'cpp_driver0': str,
                'fman_fp': str,
                'cpp_cp': str
            },
            'platform_state': {
                'curr': str,
                'next': str
            },
            'ha_state': {
                'cpp': str,
                'dir': str,
                'role_state': {
                    'curr': str,
                    'next': str
                }
            },
            'client_state': str,
            'image': str,
            'load': {
                'load_count': int,
                'time': str
            },
            'active_threads': str,
            'stuck_threads': str,
            'fault_manager_flag': {
                'ignore_fault': str,
                'ignore_stuck_thread': str,
                'crashdump_in_progress': str
            }
        }
    }

# ======================================================================================
# Parser for 'show platform hardware qfp active system state'
# ======================================================================================

class ShowPlatformHardwareQfpActiveSystemState(ShowPlatformHardwareQfpActiveSystemStateSchema):
    """ parser for "show platform hardware qfp active system state" """

    cli_command = "show platform hardware qfp active system state"

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        parsed_dict = {}

        # CPP HA client processes registered (5 of 5)
        p1 = re.compile(
            r'^CPP\s+HA\s+client\s+processes\s+registered\s+\((?P<total_processes>\d+)\sof\s(?P<registered_process>\d+)\)$')

        # cpp_ha : Initialized
        p2 = re.compile(r'^cpp_ha\s:\s+(?P<cpp_ha>\w+)$')

        # cpp_sp : Initialized
        p3 = re.compile(r'^cpp_sp\s:\s+(?P<cpp_sp>\w+)$')

        # cpp_driver0 : Initialized
        p4 = re.compile(r'^cpp_driver0\s:\s+(?P<cpp_driver0>\w+)$')

        # FMAN-FP : Initialized
        p5 = re.compile(r'^FMAN-FP\s:\s+(?P<fman_fp>\w+)$')

        # cpp_cp : Initialized
        p6 = re.compile(r'^cpp_cp\s:\s+(?P<cpp_cp>\w+)$')

        # Platform State: curr=ACTIVE_SOLO next=ACTIVE_SOLO
        p7 = re.compile(r'^Platform\s+State:\scurr=(?P<curr>[A-Z_]+)\snext=(?P<next>[A-Z_]+)$')

        # HA State: CPP=0 dir=BOTH Role: curr=ACTIVE_SOLO next=ACTIVE_SOLO
        p8 = re.compile(
            r'^HA\sState:\s+CPP=(?P<cpp>\d+)\sdir=(?P<dir>\w+)\sRole:\scurr=(?P<curr>[A-Z_]+)\snext=(?P<next>[A-Z_]+)$')

        # Client State: ENABLE
        p9 = re.compile(r'^Client\s+State:\s+(?P<client_state>\w+)$')

        # Image: /tmp/sw/fp/0/0/fp/mount/usr/cpp/bin/qfp-ucode-radium
        p10 = re.compile(r'^Image:\s+(?P<image>[a-z0-9\/-]+)$')

        # Load Cnt: 1 Time: Jun 23, 2022 07:21:15
        p11 = re.compile(r'^Load\s+Cnt:\s+(?P<load_count>\d+)\sTime:\s(?P<time>[A-Za-z0-9 :,]+)$')

        # Active Threads: 0-3,10-11
        p12 = re.compile(r'^Active\s+Threads:\s+(?P<active_threads>[0-9-,]+)$')

        # Stuck Threads: 4-9
        p13 = re.compile(r'^Stuck\s+Threads:\s+(?P<stuck_threads>[0-9-]+)$')

        # ignore_fault:          FALSE
        p14 = re.compile(r'^ignore_fault:\s+(?P<ignore_fault>\w+)$')

        # ignore_stuck_thread:   FALSE
        p15 = re.compile(r'^ignore_stuck_thread:\s+(?P<ignore_stuck_thread>\w+)$')

        # crashdump_in_progress: FALSE
        p16 = re.compile(r'^crashdump_in_progress:\s+(?P<crashdump_in_progress>\w+)$')

        for line in output.splitlines():
            line = line.strip()

            # CPP HA client processes registered (5 of 5)
            m = p1.match(line)
            if m:
                group = m.groupdict()
                cpp_ha_client_processes_dict = parsed_dict.setdefault('cpp_ha_client_processes', {})
                cpp_ha_client_processes_dict['total_processes'] = int(group['total_processes'])
                cpp_ha_client_processes_dict['registered_process'] = int(group['registered_process'])
                continue

            # cpp_ha : Initialized
            m = p2.match(line)
            if m:
                group = m.groupdict()
                client_processes_dict = cpp_ha_client_processes_dict.setdefault('client_processes', {})
                client_processes_dict['cpp_ha'] = group['cpp_ha']
                continue

            # cpp_sp : Initialized
            m = p3.match(line)
            if m:
                group = m.groupdict()
                client_processes_dict['cpp_sp'] = group['cpp_sp']
                continue

            # cpp_driver0 : Initialized
            m = p4.match(line)
            if m:
                group = m.groupdict()
                client_processes_dict['cpp_driver0'] = group['cpp_driver0']
                continue

            # FMAN-FP : Initialized
            m = p5.match(line)
            if m:
                group = m.groupdict()
                client_processes_dict['fman_fp'] = group['fman_fp']
                continue

            # cpp_cp : Initialized
            m = p6.match(line)
            if m:
                group = m.groupdict()
                client_processes_dict['cpp_cp'] = group['cpp_cp']
                continue

            # Platform State: curr=ACTIVE_SOLO next=ACTIVE_SOLO
            m = p7.match(line)
            if m:
                group = m.groupdict()
                platform_state_dict = cpp_ha_client_processes_dict.setdefault('platform_state', {})
                platform_state_dict['curr'] = group['curr']
                platform_state_dict['next'] = group['next']
                continue

            # HA State: CPP=0 dir=BOTH Role: curr=ACTIVE_SOLO next=ACTIVE_SOLO
            m = p8.match(line)
            if m:
                group = m.groupdict()
                ha_state_dict = cpp_ha_client_processes_dict.setdefault('ha_state', {})
                ha_state_dict['cpp'] = group['cpp']
                ha_state_dict['dir'] = group['dir']
                role_state_dict = ha_state_dict.setdefault('role_state', {})
                role_state_dict['curr'] = group['curr']
                role_state_dict['next'] = group['next']
                continue

            # Client State: ENABLE
            m = p9.match(line)
            if m:
                group = m.groupdict()
                cpp_ha_client_processes_dict['client_state'] = group['client_state']
                continue

            # Image: /tmp/sw/fp/0/0/fp/mount/usr/cpp/bin/qfp-ucode-radium
            m = p10.match(line)
            if m:
                group = m.groupdict()
                cpp_ha_client_processes_dict['image'] = group['image']
                continue

            # Load Cnt: 1 Time: Jun 23, 2022 07:21:15
            m = p11.match(line)
            if m:
                group = m.groupdict()
                load_dict = cpp_ha_client_processes_dict.setdefault('load', {})
                load_dict['load_count'] = int(group['load_count'])
                load_dict['time'] = group['time']
                continue

            # Active Threads: 0-3,10-11
            m = p12.match(line)
            if m:
                group = m.groupdict()
                cpp_ha_client_processes_dict['active_threads'] = group['active_threads']
                continue

            # Stuck Threads: 4-9
            m = p13.match(line)
            if m:
                group = m.groupdict()
                cpp_ha_client_processes_dict['stuck_threads'] = group['stuck_threads']
                continue

            # Fault Manager Flags:
            # ignore_fault:          FALSE
            m = p14.match(line)
            if m:
                group = m.groupdict()
                fault_manager_flag_dict = cpp_ha_client_processes_dict.setdefault('fault_manager_flag', {})
                fault_manager_flag_dict['ignore_fault'] = group['ignore_fault']
                continue

            # ignore_stuck_thread:   FALSE
            m = p15.match(line)
            if m:
                group = m.groupdict()
                fault_manager_flag_dict['ignore_stuck_thread'] = group['ignore_stuck_thread']
                continue

            # crashdump_in_progress: FALSE
            m = p16.match(line)
            if m:
                group = m.groupdict()
                fault_manager_flag_dict['crashdump_in_progress'] = group['crashdump_in_progress']
                continue

        return parsed_dict

# ======================================================================================
# Parser Schema for 'show platform hardware qfp active feature ipsec datapath drops all'
# ======================================================================================

class ShowPlatformHardwareQfpActiveFeatureIpsecDatapathDropsAllSchema(MetaParser):
    """Schema for "show platform hardware qfp active feature ipsec datapath drops all" """

    schema = {
      'drops': {
              Any(): {
                      'drop_type': int,
                      'packets': int
              }
       }
}

# ================================================================================
# Parser for 'show platform hardware qfp active feature ipsec datapath drops all'
# ================================================================================

class ShowPlatformHardwareQfpActiveFeatureIpsecDatapathDropsAll(ShowPlatformHardwareQfpActiveFeatureIpsecDatapathDropsAllSchema):
    """ parser for "show platform hardware qfp active feature ipsec datapath drops all" """

    cli_command = "show platform hardware qfp active feature ipsec datapath drops all"

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        ret_dict = {}

        # 1  IN_V4_PKT_HIT_INVALID_SA                                    0                           67643
        p1 = re.compile(r"^(?P<drop_type>\d+).* +(?P<drop_name>[\w\_]+).* +(?P<packets>\d+)$")

        for line in output.splitlines():
            line = line.strip()

            # 1  IN_V4_PKT_HIT_INVALID_SA                                    0
            m = p1.match(line)
            if m:
                group = m.groupdict()
                drop_dict = ret_dict.setdefault("drops", {}).setdefault(group['drop_name'], {})
                drop_dict.update({'drop_type':int(group['drop_type']), 'packets':int(group['packets'])})
                continue

        return ret_dict

# ======================================================================================
# Parser Schema for 'show platform hardware qfp active datapath pmd ifdev'
# ======================================================================================

class ShowPlatformHardwareQfpActiveDatapathPmdIfdevSchema(MetaParser):
    """Schema for "show platform hardware qfp active datapath pmd ifdev" """

    schema = {
        'port': {
            Any(): {
                'port_name': str,
                'state_information': {
                    'bind_name': str,
                    'driver': str,
                    'mac_address': str,
                    'device': str,
                    'cio': {
                        'cio_state': str,
                        'if_type': int,
                        'uidb_index': int,
                        'module_id': int,
                        'flags': str
                    },
                    'cio_events': {
                        'enable': int,
                        'disable': int
                    },
                    'tx_drain': str,
                    'vdev_pause': str,
                    'admin_state': str,
                    'oper_state': str,
                    'link_state': {
                        'up': int,
                        'down': int
                    },
                    'events': {
                        'remove': int,
                        'reset': int,
                        'link_up': int,
                        'link_down': int,
                        'bond_del': int,
                        'unknown': int
                    },
                    'vdev_rmv_pendng': int,
                    'attach_attempts': int
                },
                'attributes': {
                    'reconfigure': str,
                    'rx_offload_crc_strip': str,
                    'rx_offload_vlan_filter': str,
                    'rx_vlan_tag_insert': str,
                    'rx_vlan_tag_swap_': str,
                    'mac_filter_api': str,
                    'mc_promisc': str,
                    'set_mc_addr_api': str,
                    'pause_resume': str
                },
                'configuration': {
                    'promiscuous': {
                        'admin': str,
                        'override': str,
                        'multicast': str
                    },
                'mtu_config': {                 
    
                                        'mtu': int,
                                        'cur': int,
                                        'min': int,
                                        'max': int
                                },

                'trans_vlan': int,
                'map_qid_num': int,
                'map_qid_id': int,
                'rx_ring_size': int,
                'tx_ring_size': int,
                'rx_active_q_num': int,
                'rx_total_q_num': int,
                'rx_cio_q_num': int,
                'rx_desc_num': {
                    'queue_0': int
                },
                'tx_q_num': int,
                'tx_desc_num': {
                    'queue_0': int
                },
                'num_vlans': int
            }
        }
    }                   

}

# ================================================================================
# Parser for 'show platform hardware qfp active datapath pmd ifdev'
# ================================================================================

class ShowPlatformHardwareQfpActiveDatapathPmdIfdev(ShowPlatformHardwareQfpActiveDatapathPmdIfdevSchema):
    """ parser for "show platform hardware qfp active datapath pmd ifdev" """

    cli_command = "show platform hardware qfp active datapath pmd ifdev"

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        parsed_dict = {}

        # Port#0 - Name: fpe0
        p1 = re.compile(r'^Port#(?P<port_number>\d+)\s+\-\s+Name:\s+(?P<port_name>\w+)$')

        # Bind name      : 0000:0b:10.0
        p2 = re.compile(r'^Bind\s+name\s+:\s(?P<bind_name>[0-9a-z:.]+)$')

        # Driver         : net_e1000_igb_vf
        p3 = re.compile(r'^Driver\s+:\s+(?P<driver>[0-9a-z_]+)$')

        # MAC Address    : f86b.d9c0.cbe0
        p4 = re.compile(r'MAC\s+Address\s+:\s+(?P<mac_address>([0-9a-fA-F].?){12})$')

        # Device         : RUNNING
        p5 = re.compile(r'^Device\s+:\s+(?P<device>\w+)$')

        # CIO State      : ENABLED, if_type 0, uidb_index 1023, module_id 65535, flags 0x1
        p6 = re.compile(r'^CIO\s+State\s+:\s+(?P<cio_state>\w+),\s+if_type\s+(?P<if_type>\d+),\s+uidb_index\s+(?P<uidb_index>\d+),\s+module_id\s+(?P<module_id>\d+),\s+flags\s+(?P<flags>\w+)$')

        # CIO Events     : Enable 2, Disable 1
        p7 = re.compile(r'^CIO\s+Events\s+:\s+Enable\s(?P<enable>\d+),\s+Disable\s+(?P<disable>\d+)$')

        # Tx_Drain       : FALSE
        p8 = re.compile(r'^Tx_Drain\s+:\s+(?P<tx_drain>\w+)$')

        # Vdev Pause     : Inactive
        p9 = re.compile(r'^Vdev\s+Pause\s+:\s+(?P<vdev_pause>\w+)$')

        # Admin State    : Up
        p10 = re.compile(r'^Admin\s+State\s+:\s+(?P<admin_state>\w+)$')

        # Oper State     : Up (Up)
        p11 = re.compile(r'^Oper\s+State\s+:\s+(?P<oper_state>\w+\s\(\w+\))$')

        # Link state chg : Up 1, Down 0
        p12 = re.compile(r'^Link\s+state\s+chg\s:\sUp\s(?P<up>\d+),\s+Down\s+(?P<down>\d+)$')

        # Events         : Remove 0, Reset 1, Link up 0, Link dn 0
        p13 = re.compile(r'^Events\s+:\s+Remove\s+(?P<remove>\d+),\s+Reset\s+(?P<reset>\d+),\s+Link\s+up+\s(?P<link_up>\d+),\s+Link\s+dn\s+(?P<link_down>\d+)$')

        # Events         : Bond del 0, Unknown 0
        p14 = re.compile(r'^Events\s+:\s+Bond\s+del\s+(?P<bond_del>\d+),\s+Unknown\s+(?P<unknown>\d+)$')

        # Vdev Rmv Pendng: 0
        p15 = re.compile(r'^Vdev\s+Rmv\s+Pendng:\s+(?P<vdev_rmv_pendng>\d+)$')

        # Attach Attempts: 50
        p16 = re.compile(r'^Attach\s+Attempts:\s+(?P<attach_attempts>\d+)$')

        # Attributes
        # RECONFIGURE_SUPPORTED
        p17 = re.compile(r'^(?P<attribute_name>RECONFIGURE)_(?P<status>[A-Z]+)$')

        # RX_OFFLOAD_CRC_STRIP_SUPPORTED
        p18 = re.compile(r'^(?P<attribute_name>RX_OFFLOAD_CRC_STRIP)_(?P<status>[A-Z]+)$')

        # RX_OFFLOAD_VLAN_FILTER_SUPPORTED
        p19 = re.compile(r'^(?P<attribute_name>RX_OFFLOAD_VLAN_FILTER)_(?P<status>[A-Z]+)$')

        # RX_VLAN_TAG_INSERT_NEEDED
        p20 = re.compile(r'^(?P<attribute_name>RX_VLAN_TAG_INSERT)_(?P<status>[A-Z]+)$')

        # RX_VLAN_TAG_SWAP_NEEDED
        p21 = re.compile(r'^(?P<attribute_name>RX_VLAN_TAG_SWAP_)(?P<status>[A-Z]+)$')

        # MAC_FILTER_API_SUPPORTED
        p22 = re.compile(r'^(?P<attribute_name>MAC_FILTER_API)_(?P<status>[A-Z]+)$')

        # ALWAYS_MC_PROMISC
        p23 = re.compile(r'^(?P<status>[A-Z]+)_(?P<attribute_name>MC_PROMISC)$')

        # SET_MC_ADDR_API_SUPPORTED
        p24 = re.compile(r'^(?P<attribute_name>SET_MC_ADDR_API)_(?P<status>[A-Z]+)$')

        # PAUSE_RESUME_SUPPORTED
        p25 = re.compile(r'^(?P<attribute_name>PAUSE_RESUME)_(?P<status>[A-Z]+)$')

        # Configuration
        # Promiscuous    : Admin DISABLED, Override DISABLED, Multicast ENABLED
        p26 = re.compile(r'^Promiscuous\s+:\s+Admin\s+(?P<admin_status>\w+),\s+Override\s+(?P<override_status>\w+),\s+Multicast\s+(?P<multicast_status>\w+)$')

        # MTU config     : 1526
        p27 = re.compile(r'^MTU\s+config\s+:\s+(?P<mtu>\d+)$')

        # cur/min/max  : 1500/68/65535
        p28 = re.compile(r'^cur\/min\/max\s+:\s+(?P<cur>\d+)/(?P<min>\d+)/(?P<max>\d+)$')

        # Trans VLAN     : 0
        p29 = re.compile(r'^Trans\s+VLAN\s+:\s+(?P<trans_vlan>\d+)$')

        # Map QID Num    : 0
        p30 = re.compile(r'^Map\s+QID\s+Num\s+:\s+(?P<map_qid_num>\d+)$')

        # Map QID Id     : 0
        p31 = re.compile(r'^Map\s+QID\s+Id\s+:\s+(?P<map_qid_id>\d+)$')

        # Rx ring size   : 0
        p32 = re.compile(r'^Rx\s+ring\s+size\s+:\s+(?P<rx_ring_size>\d+)$')

        # Tx ring size   : 0
        p33 = re.compile(r'^Tx\s+ring\s+size\s+:\s+(?P<tx_ring_size>\d+)$')

        # Rx Active Q Num: 1
        p34 = re.compile(r'^Rx\s+Active\s+Q\s+Num:\s+(?P<rx_active_q_num>\d+)$')

        # Rx Total Q Num : 1
        p35 = re.compile(r'^Rx\s+Total\s+Q\s+Num\s+:\s+(?P<rx_total_q_num>\d+)$')

        # Rx CIO Q Num   : 1
        p36 = re.compile(r'^Rx\s+CIO\s+Q\s+Num\s+:\s+(?P<rx_cio_q_num>\d+)$')

        # Rx Desc Num
        # Tx Desc Num
        p37 = re.compile(r'^(?P<name>([A-Z][a-z]\s+[A-zZ][a-z]+\s+[A-Z][a-z]+))$')

        # Queue 0      : 1024
        p38 = re.compile(r'^Queue\s+0\s+:\s+(?P<queue0>\d+)$')

        # Tx Q Num       : 1
        p39 = re.compile(r'^Tx\s+Q\s+Num\s+:\s+(?P<tx_q_num>\d+)$')

        # Num VLANs      : 0
        p40 = re.compile(r'^Num\s+VLANs\s+:\s+(?P<num_vlans>\d+)$')

        for line in output.splitlines():
            line = line.strip()

            # Port#0 - Name: fpe0
            m = p1.match(line)
            if m:
                group = m.groupdict()
                port_number = group['port_number']
                port_dict = parsed_dict.setdefault("port", {}). \
                    setdefault(port_number, {})
                port_dict['port_name'] = group['port_name']
                continue

            # State Information
            # Bind name      : 0000:0b:10.0
            m = p2.match(line)
            if m:
                group = m.groupdict()
                state_info_dict = port_dict.setdefault("state_information", {})
                state_info_dict['bind_name'] = group['bind_name']
                continue

            # Driver         : net_e1000_igb_vf
            m = p3.match(line)
            if m:
                group = m.groupdict()
                state_info_dict['driver'] = group['driver']
                continue

            # MAC Address    : f86b.d9c0.cbe0
            m = p4.match(line)
            if m:
                group = m.groupdict()
                state_info_dict['mac_address'] = group['mac_address']
                continue

            # Device         : RUNNING
            m = p5.match(line)
            if m:
                group = m.groupdict()
                state_info_dict['device'] = group['device']
                continue

            # CIO State      : ENABLED, if_type 0, uidb_index 1023, module_id 65535, flags 0x1
            m = p6.match(line)
            if m:
                group = m.groupdict()
                cio_dict = state_info_dict.setdefault("cio", {})
                cio_dict['cio_state'] = group['cio_state']
                cio_dict['if_type'] = int(group['if_type'])
                cio_dict['uidb_index'] = int(group['uidb_index'])
                cio_dict['module_id'] = int(group['uidb_index'])
                cio_dict['flags'] = group['flags']
                continue

            # CIO Events     : Enable 2, Disable 1
            m = p7.match(line)
            if m:
                group = m.groupdict()
                cio_events_dict = state_info_dict.setdefault("cio_events", {})
                cio_events_dict['enable'] = int(group['enable'])
                cio_events_dict['disable'] = int(group['disable'])
                continue

            # Tx_Drain       : FALSE
            m = p8.match(line)
            if m:
                group = m.groupdict()
                state_info_dict['tx_drain'] = group['tx_drain']
                continue

            # Vdev Pause     : Inactive
            m = p9.match(line)
            if m:
                group = m.groupdict()
                state_info_dict['vdev_pause'] = group['vdev_pause']
                continue

            # Admin State    : Up
            m = p10.match(line)
            if m:
                group = m.groupdict()
                state_info_dict['admin_state'] = group['admin_state']
                continue

            # Oper State     : Up (Up)
            m = p11.match(line)
            if m:
                group = m.groupdict()
                state_info_dict['oper_state'] = group['oper_state']
                continue

            # Link state chg : Up 1, Down 0
            m = p12.match(line)
            if m:
                group = m.groupdict()
                link_state_dict = state_info_dict.setdefault("link_state", {})
                link_state_dict['up'] = int(group['up'])
                link_state_dict['down'] = int(group['down'])
                continue

            # Events         : Remove 0, Reset 1, Link up 0, Link dn 0
            m = p13.match(line)
            if m:
                group = m.groupdict()
                events_dict = state_info_dict.setdefault("events", {})
                events_dict['remove'] = int(group['remove'])
                events_dict['reset'] = int(group['reset'])
                events_dict['link_up'] = int(group['link_up'])
                events_dict['link_down'] = int(group['link_down'])
                continue

            # Events         : Bond del 0, Unknown 0
            m = p14.match(line)
            if m:
                group = m.groupdict()
                events_dict['bond_del'] = int(group['bond_del'])
                events_dict['unknown'] = int(group['unknown'])
                continue

            # Vdev Rmv Pendng: 0
            m = p15.match(line)
            if m:
                group = m.groupdict()
                state_info_dict['vdev_rmv_pendng'] = int(group['vdev_rmv_pendng'])
                continue

            # Attach Attempts: 50
            m = p16.match(line)
            if m:
                group = m.groupdict()
                state_info_dict['attach_attempts'] = int(group['attach_attempts'])
                continue

            # Attributes
            # RECONFIGURE_SUPPORTED
            m = p17.match(line)
            if m:
                group = m.groupdict()
                attributes_dict = port_dict.setdefault("attributes", {})
                attributes_dict[group["attribute_name"].lower()] = group['status'].lower()
                continue

            # RX_OFFLOAD_CRC_STRIP_SUPPORTED
            m = p18.match(line)
            if m:
                group = m.groupdict()
                attributes_dict[group["attribute_name"].lower()] = group['status'].lower()
                continue

            # RX_OFFLOAD_VLAN_FILTER_SUPPORTED
            m = p19.match(line)
            if m:
                group = m.groupdict()
                attributes_dict[group["attribute_name"].lower()] = group['status'].lower()
                continue

            # RX_VLAN_TAG_INSERT_NEEDED
            m = p20.match(line)
            if m:
                group = m.groupdict()
                attributes_dict[group["attribute_name"].lower()] = group['status'].lower()
                continue

            # RX_VLAN_TAG_SWAP_NEEDED
            m = p21.match(line)
            if m:
                group = m.groupdict()
                attributes_dict[group["attribute_name"].lower()] = group['status'].lower()
                continue

            # MAC_FILTER_API_SUPPORTED
            m = p22.match(line)
            if m:
                group = m.groupdict()
                attributes_dict[group["attribute_name"].lower()] = group['status'].lower()
                continue

            # ALWAYS_MC_PROMISC
            m = p23.match(line)
            if m:
                group = m.groupdict()
                attributes_dict[group["attribute_name"].lower()] = group['status'].lower()
                continue

            # SET_MC_ADDR_API_SUPPORTED
            m = p24.match(line)
            if m:
                group = m.groupdict()
                attributes_dict[group["attribute_name"].lower()] = group['status'].lower()
                continue

            # PAUSE_RESUME_SUPPORTED
            m = p25.match(line)
            if m:
                group = m.groupdict()
                attributes_dict[group["attribute_name"].lower()] = group['status'].lower()
                continue

            # Configuration
            # Promiscuous    : Admin DISABLED, Override DISABLED, Multicast ENABLED
            m = p26.match(line)
            if m:
                group = m.groupdict()
                configuration_dict = port_dict.setdefault("configuration", {})
                promiscuous_dict = configuration_dict.setdefault("promiscuous",{})
                promiscuous_dict["admin"] = group['admin_status'].lower()
                promiscuous_dict["override"] = group['override_status'].lower()
                promiscuous_dict["multicast"] = group['multicast_status'].lower()
                continue

            # MTU config     : 1526
            m = p27.match(line)
            if m:
                group = m.groupdict()
                mtu_config_dict = configuration_dict.setdefault("mtu_config",{})
                mtu_config_dict["mtu"] = int(group['mtu'])
                continue

            # cur/min/max  : 1500/68/65535
            m = p28.match(line)
            if m:
                group = m.groupdict()
                mtu_config_dict["cur"] = int(group['cur'])
                mtu_config_dict["min"] = int(group['min'])
                mtu_config_dict["max"] = int(group['max'])
                continue

            # Trans VLAN     : 0
            m = p29.match(line)
            if m:
                group = m.groupdict()
                configuration_dict["trans_vlan"] = int(group['trans_vlan'])
                continue

            # Map QID Num    : 0
            m = p30.match(line)
            if m:
                group = m.groupdict()
                configuration_dict["map_qid_num"] = int(group['map_qid_num'])
                continue

            # Map QID Id     : 0
            m = p31.match(line)
            if m:
                group = m.groupdict()
                configuration_dict["map_qid_id"] = int(group['map_qid_id'])
                continue

            # Rx ring size   : 0
            m = p32.match(line)
            if m:
                group = m.groupdict()
                configuration_dict["rx_ring_size"] = int(group['rx_ring_size'])
                continue

            # Tx ring size   : 0
            m = p33.match(line)
            if m:
                group = m.groupdict()
                configuration_dict["tx_ring_size"] = int(group['tx_ring_size'])
                continue

            # Rx Active Q Num: 1
            m = p34.match(line)
            if m:
                group = m.groupdict()
                configuration_dict["rx_active_q_num"] = int(group['rx_active_q_num'])
                continue

            # Rx Total Q Num : 1
            m = p35.match(line)
            if m:
                group = m.groupdict()
                configuration_dict["rx_total_q_num"] = int(group['rx_total_q_num'])
                continue

            # Rx CIO Q Num   : 1
            m = p36.match(line)
            if m:
                group = m.groupdict()
                configuration_dict["rx_cio_q_num"] = int(group['rx_cio_q_num'])
                continue

            # Rx Desc Num
            # Tx Desc Num
            m = p37.match(line)
            if m:
                group = m.groupdict()
                dict_name = (group["name"].lower()).replace(" ","_")
                configuration_dict.setdefault(dict_name,{})
                continue

            # Queue 0      : 1024
            m = p38.match(line)
            if m:
                group = m.groupdict()
                desc_num_dict = configuration_dict.setdefault(dict_name,{})
                desc_num_dict["queue_0"] = int(group['queue0'])
                continue

            # Tx Q Num       : 1
            m = p39.match(line)
            if m:
                group = m.groupdict()
                configuration_dict["tx_q_num"] = int(group['tx_q_num'])
                continue

            # Num VLANs      : 0
            m = p40.match(line)
            if m:
                group = m.groupdict()
                configuration_dict["num_vlans"] = int(group['num_vlans'])
                continue

        return parsed_dict

# ==========================================================================================
# Parser Schema for 'show platform hardware throughput level'
# ==========================================================================================

class ShowPlatformHardwareThroughputLevelSchema(MetaParser):
    """Schema for "show platform hardware throughput level" """

    schema = {
         'curr_throughput_level': str
    }

# ================================================================================
# Parser for 'show platform hardware throughput level'
# ================================================================================

class ShowPlatformHardwareThroughputLevel(ShowPlatformHardwareThroughputLevelSchema):
    """ parser for "show platform hardware throughput level" """

    cli_command = "show platform hardware throughput level"

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        parsed_dict = {}

        # The current throughput level is unthrottled
        # The current throughput level is 1000000 kb/s
        p1 = re.compile(r'^The\s+current\s+throughput\s+level\s+is\s+(?P<curr_throughput_level>[a-z0-9 /]+)$')

        for line in output.splitlines():
            line = line.strip()

            # The current throughput level is unthrottled
            # The current throughput level is 1000000 kb/s
            m = p1.match(line)
            if m:
                group = m.groupdict()
                parsed_dict['curr_throughput_level'] =  group['curr_throughput_level']
                continue

        return parsed_dict

# ==========================================================================================
# Parser Schema for 'show platform hardware qfp active datapath infra sw-distrib'
# ==========================================================================================

class ShowPlatformHardwareQfpActiveInfraDatapathInfraSwDistribSchema(MetaParser):
    """Schema for "show platform hardware qfp active datapath infra sw-distrib" """

    schema = {
             'sw_distrib': {
                'dist_mode': str,
                'inactive_ppes': str,
                'rx_stats': {
                    'source_id': {
                        Any(): {
                            'name': str,
                            'pmask': str,
                            'port': {
                                Any(): {
                                    'port_name': str,
                                    'classifier': str,
                                    'credit_error': str,
                                    'pp': {
                                        Any(): {
                                            'flushes': str,
                                            'flushed': str,
                                            'spin': str,
                                            'sw_hash': str,
                                            Optional('coff_directed'): str,
                                            'total': str
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

# ================================================================================
# Parser for 'show platform hardware qfp active datapath infra sw-distrib'
# ================================================================================

class ShowPlatformHardwareQfpActiveInfraDatapathInfraSwDistrib(ShowPlatformHardwareQfpActiveInfraDatapathInfraSwDistribSchema):
    """ parser for "show platform hardware qfp active datapath infra sw-distrib" """

    cli_command = "show platform hardware qfp active datapath infra sw-distrib"

    def cli(self, output=None):
        if output is None:
           output = self.device.execute(self.cli_command)

        parsed_dict = {}

        # Dist Mode: NSFBD
        p1 = re.compile(r'^Dist\s+Mode:\s(?P<dist_mode>\w+)$')

        # Inactive PPEs: 4-9
        p2 = re.compile(r'^Inactive\s+PPEs:\s(?P<inactive_ppes>[0-9-]+)$')

        # RX Stats
        p3 = re.compile(r'^(?P<stats>RX Stats)$')

        # Source  0: name   DST, pmask 0x3f0
        p4 = re.compile(r'^Source\s+(?P<source_id>\d+):\s+name\s+(?P<name>\w+),\s+pmask\s(?P<pmask>\w+)$')

        # Port  4 (fpe0/GigabitEthernet0/0/0): Classifier: L4TUPLE, Credit Err:  -
        p5 = re.compile(r'^Port\s+(?P<port>\d+)\s+(?P<port_name>\([A-Za-z0-9_//)]+):\s+Classifier:\s+(?P<classifier>\w+),\s+Credit\s+Err:\s+(?P<credit_error>\S+)$')

        #                 Flushes         Flushed            Spin         SW Hash   COFF Directed           Total
        # PP  0:           665518          665538               -          665538               -          665538
        p6 = re.compile(r'^PP\s+(?P<pp>[0-9-]+):\s+(?P<flushes>[0-9-]+)\s+(?P<flushed>[0-9-]+)\s+(?P<spin>[0-9-]+)\s+(?P<sw_hash>[0-9-]+)\s+(?P<coff_directed>[0-9-]+)\s+(?P<total>[0-9-]+)$')

        #                  Flushes         Flushed            Spin         SW Hash           Total
        # PP  3:           306421          306421               -          306421          306421
        p7 = re.compile(r'^PP\s+(?P<pp>[0-9-]+):\s+(?P<flushes>[0-9-]+)\s+(?P<flushed>[0-9-]+)\s+(?P<spin>[0-9-]+)\s+(?P<sw_hash>[0-9-]+)\s+(?P<total>[0-9-]+)$')

        #                 Flushes         Flushed            Spin         SW Hash         Unknown           Total
        # PP  0:           105241          124512               -          124512               -          124512
        p8 = re.compile(r'^PP\s+(?P<pp>[0-9-]+):\s+(?P<flushes>[0-9-]+)\s+(?P<flushed>[0-9-]+)\s+(?P<spin>[0-9-]+)\s+(?P<sw_hash>[0-9-]+)\s+(?P<unknown>[0-9-]+)\s+(?P<total>[0-9-]+)$')

        for line in output.splitlines():
            line = line.strip()

            # Dist Mode: NSFBD
            m = p1.match(line)
            if m:
                group = m.groupdict()
                sw_distrib_dict = parsed_dict.setdefault('sw_distrib', {})
                sw_distrib_dict['dist_mode'] = group['dist_mode']
                continue

            # Inactive PPEs: 4-9
            m = p2.match(line)
            if m:
                group = m.groupdict()
                sw_distrib_dict['inactive_ppes'] = group['inactive_ppes']
                continue

            # RX Stats
            m = p3.match(line)
            if m:
                group = m.groupdict()
                stats = (group['stats'].lower()).replace(' ','_')
                stats_dict = sw_distrib_dict.setdefault(stats, {})
                continue

            # Source  0: name   DST, pmask 0x3f0
            m = p4.match(line)
            if m:
                group = m.groupdict()
                source_id = group.pop('source_id')
                rx_source_dict = stats_dict.setdefault('source_id', {}).setdefault(source_id, {})
                rx_source_dict.update({k: v for k, v in group.items()})
                continue

            # Port  4 (fpe0/GigabitEthernet0/0/0): Classifier: L4TUPLE, Credit Err:  -
            m = p5.match(line)
            if m:
                group = m.groupdict()
                port_id = group.pop('port')
                port_dict = rx_source_dict.setdefault('port', {}).setdefault(port_id, {})
                port_dict.update({k: v for k, v in group.items()})
                continue

            #                 Flushes         Flushed            Spin         SW Hash   COFF Directed           Total
            # PP  0:           665518          665538               -          665538               -          665538
            m = p6.match(line)
            if m:
                group = m.groupdict()
                pp_id = group.pop('pp')
                pp_dict = port_dict.setdefault('pp', {}).setdefault(pp_id, {})
                pp_dict.update({k: v for k, v in group.items()})
                continue

            #                  Flushes         Flushed            Spin         SW Hash           Total
            # PP  3:           306421          306421               -          306421          306421
            m = p7.match(line)
            if m:
                group = m.groupdict()
                pp_id = group.pop('pp')
                pp_dict = port_dict.setdefault('pp', {}).setdefault(pp_id, {})
                pp_dict.update({k: v for k, v in group.items()})
                continue

            #                 Flushes         Flushed            Spin         SW Hash         Unknown           Total
            # PP  0:           105241          124512               -          124512               -          124512
            m = p8.match(line)
            if m:
                group = m.groupdict()
                pp_id = group.pop('pp')
                pp_dict = port_dict.setdefault('pp', {}).setdefault(pp_id, {})
                pp_dict.update({k: v for k, v in group.items()})
                continue

        return parsed_dict
# =========================================================
#  Schema for
#  * 'show platform software fed switch active acl usage'
#  * 'show platform software fed switch active acl usage | include {acl_name}'
# =========================================================
class ShowPlatformSoftwareFedSwitchActiveAclUsageSchema(MetaParser):
    """Schema for 'show platform software fed switch active acl usage
    """
    schema = {
        Optional('acl_usage'): {
            Optional('ace_software'): {
                 Optional('vmr_max') : int,
                 Optional('used') : int,
             },
            'acl_name': {
                Any(): {
                    'direction': {
                        Any(): {
                            'feature_type': str,
                            'acl_type': str,
                            'entries_used': int,
                        }
                    }
                }
            }
        }
    }

# =========================================================
#  Parser for
#  * 'show platform software fed switch active acl usage'
#  * 'show platform software fed switch active acl usage | include {acl_name}'
# =========================================================
class ShowPlatformSoftwareFedSwitchActiveAclUsage(ShowPlatformSoftwareFedSwitchActiveAclUsageSchema):
    """
    Parser for :
        * show platform software fed switch active acl usage
        * show platform software fed switch active acl usage | include {acl_name}
    """

    cli_command = ['show platform software fed switch active acl usage',
                   'show platform software fed switch active acl usage | include {acl_name}']

    def cli(self, acl_name="", output=None):
        if output is None:
            if acl_name:
                cmd = self.cli_command[1].format(acl_name=acl_name)
            else:
                cmd = self.cli_command[0]
            output = self.device.execute(cmd)

        ######  ACE Software VMR max:196608 used:253
        p1 = re.compile(r'^\#\#\#\#\#\s+ACE\sSoftware\sVMR\smax\:(?P<vmr_max>\d+)\sused\:(?P<used>\d+)$')


        #   RACL        IPV4     Ingress   PBR-DMVPN    92
        p2 = re.compile(r'^(?P<feature_type>\S+)\s+(?P<acl_type>\S+)\s+(?P<direction>\S+)\s+(?P<name>\S+)\s+(?P<entries_used>\d+)$')

        # initial return dictionary
        ret_dict ={}

        for line in output.splitlines():
            line = line.strip()

            acl_usage = ret_dict.setdefault('acl_usage', {})

            ######  ACE Software VMR max:196608 used:253
            m = p1.match(line)
            if m:
                group = m.groupdict()
                acl_usage = ret_dict.setdefault('acl_usage', {})
                ace_software = acl_usage.setdefault('ace_software',{})

                vmr_max = group['vmr_max']
                ace_software['vmr_max'] = int(vmr_max)

                used = group['used']
                ace_software['used'] = int(used)
                continue

            #   RACL        IPV4     Ingress   PBR-DMVPN    92
            m = p2.match(line)
            if m:
                group = m.groupdict()
                acl_name = acl_usage.setdefault('acl_name', {}).\
                                 setdefault(Common.convert_intf_name(group['name']), {})
                direction = acl_name.setdefault('direction',{}).\
                                 setdefault(Common.convert_intf_name(group['direction']), {})


                direction['feature_type'] = group['feature_type']
                direction['acl_type'] = group['acl_type']
                direction['entries_used'] = int(group['entries_used'])
                continue
        return ret_dict


# =============================================
# Schema for 'show platform software fed {switch} active vt counter'
# Schema for 'show platform software fed active vt counter'
# =============================================

class ShowPlatformSoftwareFedSwitchActiveVtCounterSchema(MetaParser):
    """Schema for show platform software fed switch active vt counter"""
    schema = {
        'number_of_vlans': int,
    }

class ShowPlatformSoftwareFedSwitchActiveVtCounter(ShowPlatformSoftwareFedSwitchActiveVtCounterSchema):
    """Parser for show platform software fed switch active vt counter"""

    cli_command = ['show platform software fed switch {switch} active vt counter','show platform software fed active vt counter']
    def cli(self, output=None, switch=''):
        if output is None:
            if switch:
                cmd = self.cli_command[0].format(switch=switch)
            else:
                cmd = self.cli_command[1]

            output = self.device.execute(cmd)

        # Total no of vlan mappings configured: 1
        p1 = re.compile(r"^Total\s+no\s+of\s+vlan\s+mappings\s+configured:\s+(?P<number_of_vlans>\d+)$")
        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()
            matched_values = p1.match(line)
            if matched_values:
                vlan_dict = matched_values.groupdict()
                ret_dict['number_of_vlans'] = int(vlan_dict['number_of_vlans'])
                continue
        return ret_dict


# ======================================================
# Parser for 'show platform software fed switch active vt all '
# ======================================================

class ShowPlatformSoftwareFedSwitchActiveVtAllSchema(MetaParser):
    """Schema for show platform software fed switch active vt all"""

    schema = {
        'interface_id': {
            Any(): {
                'cvlan_id': int,
                'svlan_id': int,
                'action': int,
            }
        }
    }

class ShowPlatformSoftwareFedSwitchActiveVtAll(ShowPlatformSoftwareFedSwitchActiveVtAllSchema):
    """Parser for show platform software fed switch active vt all"""

    cli_command = 'show platform software fed switch active vt all'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        #interface_id  cvlan_id      svlan-id              action
        #183           20            30                    1
        p1 = re.compile(r"^(?P<interface_id>\d+)\s+(?P<cvlan_id>\d+)\s+(?P<svlan_id>\d+)\s+(?P<action>\d+)$")
        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()
            matched_values = p1.match(line)
            if matched_values:
                parsed_dict = matched_values.groupdict()
                interface_id_var = parsed_dict['interface_id']
                group = ret_dict.setdefault('interface_id', {}).setdefault(interface_id_var, {})
                group['cvlan_id'] = int(parsed_dict['cvlan_id'])
                group['svlan_id'] = int(parsed_dict['svlan_id'])
                group['action'] = int(parsed_dict['action'])
                continue
        return ret_dict


# ======================================================================================
# Parser Schema for 'show platform hardware qfp active infrastructure exmem statistics'
# ======================================================================================

class ShowPlatformHardwareQfpActiveInfrastructureExmemStatisticsSchema(MetaParser):
    """Schema for "show platform hardware qfp active infrastructure exmem statistics" """

    schema = {
        'qfp_exmem_stats': {
            'type': {
                Any(): {
                    'qfp': int,
                    'total': int,
                    'inuse': int,
                    'free': int,
                    'lowest_free_water_mark': int
                }
            }
        }
    }

# ===============================================================================
# Parser for 'show platform hardware qfp active infrastructure exmem statistics'
# ===============================================================================

class ShowPlatformHardwareQfpActiveInfrastructureExmemStatistics(
    ShowPlatformHardwareQfpActiveInfrastructureExmemStatisticsSchema):
    """ parser for "show platform hardware qfp active infrastructure exmem statistics" """

    cli_command = "show platform hardware qfp active infrastructure exmem statistics"

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        parsed_dict = {}

        # Type: Name: DRAM, QFP: 0
        # Type: Name: IRAM, QFP: 0
        # Type: Name: SRAM, QFP: 0
        p1 = re.compile(r'^Type:\sName:\s(?P<type_name>\w+),\sQFP:\s(?P<qfp>\d+)$')

        # Total: 536870912
        p2 = re.compile(r'^Total:\s(?P<total>\d+)$')

        # InUse: 423936
        p3 = re.compile(r'^InUse:\s(?P<inuse>\d+)$')

        # Free: 1673216
        p4 = re.compile(r'^Free:\s(?P<free>\d+)$')

        # Lowest free water mark: 1673216
        p5 = re.compile(r'^Lowest\sfree\swater\smark:\s(?P<lowest_free_water_mark>\d+)$')

        for line in output.splitlines():
            line = line.strip()

            # Type: Name: DRAM, QFP: 0
            # Type: Name: IRAM, QFP: 0
            # Type: Name: SRAM, QFP: 0
            m = p1.match(line)
            if m:
                group = m.groupdict()
                type_name = group['type_name'].lower()
                qfp_exmem_stats_dict = parsed_dict.setdefault('qfp_exmem_stats', {}). \
                    setdefault('type', {})
                type_dict = qfp_exmem_stats_dict.setdefault(type_name, {})
                type_dict['qfp'] = int(group['qfp'])
                continue

            # Total: 536870912
            m = p2.match(line)
            if m:
                group = m.groupdict()
                type_dict['total'] = int(group['total'])
                continue

            # InUse: 423936
            m = p3.match(line)
            if m:
                group = m.groupdict()
                type_dict['inuse'] = int(group['inuse'])
                continue

            # Free: 1673216
            m = p4.match(line)
            if m:
                group = m.groupdict()
                type_dict['free'] = int(group['free'])
                continue

            # Lowest free water mark: 1673216
            m = p5.match(line)
            if m:
                group = m.groupdict()
                type_dict['lowest_free_water_mark'] = int(group['lowest_free_water_mark'])
                continue

        return parsed_dict

# ================================================================================
# Parser Schema for 'show platform hardware fed active qos queue config interface'
#            or 'show platform hardware fed switch <no> qos queue config interface'
# ================================================================================
class ShowPlatformHardwareFedActiveQosQueueConfigInterfaceSchema(MetaParser):
    """Schema for show platform hardware fed active qos queue config interface"""

    schema = {
        Optional('asic'): int,
        Optional('core'): int,
        'data_port': int,
        'gpn':  int,
        Optional('linkspeed'): str,
        'afd': str,
        Optional('flatafd'): str,
        'qosmap': int,
        'hw_queues': {
            'min': int,
            'max': int,
        },
        'drainfast': str,
        'portsoftstart': {
            'min': int,
            'max': int,
        },
        Optional('buffersharing'): str,
        'queue': {
            int: {
                'dts': int,
                'hardmax': int,
                'softmax': int,
                'portsmin': int,
                'glblsmin': int,
                'portstend': int,
                Optional('qenable'): str,
                'priority': int,
                'schedule_mode': str,
                'weight': int,
                'shaping_step': int,
                Optional('sharpedweight'): int,
                'weight0': int,
                'max_th0': int,
                'min_th0': int,
                'weight1': int,
                'max_th1': int,
                'min_th1': int,
                'weight2': int,
                'max_th2': int,
                'min_th2': int,
            },
        },
        Optional('port'):{
            'priority': int,
            'schedule_mode': str,
            'weight': int,
            'shaping_step': int,
            Optional('sharpedweight'): int,
            },
    }

# ================================================================================
# Parser for 'show platform hardware fed active qos queue config interface'
#         or 'show platform hardware fed switch <no> qos queue config interface'
# ================================================================================
class ShowPlatformHardwareFedActiveQosQueueConfigInterface(ShowPlatformHardwareFedActiveQosQueueConfigInterfaceSchema):
    cli_command = ['show platform hardware fed active qos queue config interface {interface}',
                   'show platform hardware fed switch {switch_num} qos queue config interface {interface}']

    def cli(self, interface, switch_num=None, output=None):
        if output is None:
            if switch_num is None:
                cmd = self.cli_command[0].format(interface=interface)
            else:
                cmd = self.cli_command[1].format(switch_num=switch_num,interface=interface)

            output = self.device.execute(cmd)

        ret_dict = {}

        '''
        Asic:1 Core:1 DATA Port:70 GPN:325 LinkSpeed:0xa
        AFD:Disabled FlatAFD:Disabled QoSMap:0 HW Queues: 560 - 567
        '''
        p1 = re.compile(r'^Asic:(?P<asic>\d+)\s+Core:(?P<core>\d+)\s+DATA Port:(?P<data_port>\d+)\s+GPN:(?P<gpn>\d+)\s+LinkSpeed:(?P<linkspeed>\S+)$')
        p2 = re.compile(r'^AFD:(?P<afd>\S+)\s+FlatAFD:(?P<flatafd>\S+)\s+QoSMap:(?P<qosmap>\d+)\s+HW Queues:\s*(?P<hw_queue1>\d+)\s*-\s*(?P<hw_queue2>\d+)$')

        '''
        DATA Port:0 GPN:97 AFD:Disabled QoSMap:0 HW Queues: 0 - 7
        '''
        p2_1 = re.compile(r'^DATA Port:(?P<data_port>\d+)\s+GPN:(?P<gpn>\d+)\s+AFD:(?P<afd>\S+)\s+QoSMap:(?P<qosmap>\d+)\s+HW Queues:\s*(?P<hw_queue1>\d+)\s*-\s*(?P<hw_queue2>\d+)$')

        '''
        DrainFast:Disabled PortSoftStart:3 - 42000 BufferSharing:Disabled
        '''
        p3 = re.compile(r'^DrainFast:(?P<drainfast>\S+)\s+PortSoftStart:(?P<portsoftstart1>\d+)\s*-\s*(?P<portsoftstart2>\d+)\s+BufferSharing:(?P<buffersharing>\S+)$')

        '''
        DrainFast:Disabled PortSoftStart:2 - 2016
        '''
        p3_1 = re.compile(r'^DrainFast:(?P<drainfast>\S+)\s+PortSoftStart:(?P<portsoftstart1>\d+)\s*-\s*(?P<portsoftstart2>\d+)$')

        '''
           DTS  Hardmax  Softmax   PortSMin  GlblSMin  PortStEnd   QEnable
          ----- --------  --------  --------  --------  ---------  -------
        0   1  2   224   5 42000   0     0   0     0   1 42000      En
        1   1  0     0   5 42000   1  1312   0     0   1 42000      En
        '''
        p4 = re.compile(r'^(?P<q_no>\d+)\s+(?P<dts>\d+)\s+(\d+)\s+(?P<hardmax>\d+)\s+'\
                         '(\d+)\s+(?P<softmax>\d+)\s+(\d+)\s+(?P<portsmin>\d+)\s+(\d+)\s+(?P<glblsmin>\d+)\s+'\
                         '(\d+)\s+(?P<portstend>\d+)\s+(?P<qenable>\S+)$'
        )

        '''
          DTS  Hardmax  Softmax   PortSMin  GlblSMin  PortStEnd
          ----- --------  --------  --------  --------  ---------
        0   1  2   224   5 42000   0     0   0     0   1 42000
        1   1  0     0   5 42000   1  1312   0     0   1 42000
        '''
        p4_1 = re.compile(r'^(?P<q_no>\d+)\s+(?P<dts>\d+)\s+(\d+)\s+(?P<hardmax>\d+)\s+'\
                         '(\d+)\s+(?P<softmax>\d+)\s+(\d+)\s+(?P<portsmin>\d+)\s+(\d+)\s+(?P<glblsmin>\d+)\s+'\
                         '(\d+)\s+(?P<portstend>\d+)$'
        )

        '''
        Priority   Shaped/shared   weight  shaping_step  sharpedWeight
        --------   -------------   ------  ------------   -------------
        0      0     Shared            50           0           0

        '''
        p5 = re.compile(r'^(?P<q_no>\d+)\s+(?P<priority>\d+)\s+(?P<mode>\S+)\s+'\
                         '(?P<weight>\d+)\s+(?P<shaping_step>\d+)\s+(?P<sharpedweight>\d+)$'
        )

        '''
        Priority   Shaped/shared   weight  shaping_step
        --------   -------------   ------  ------------
        0      0     Shared            50           0

        '''
        p5_1 = re.compile(r'^(?P<q_no>\d+)\s+(?P<priority>\d+)\s+(?P<mode>\S+)\s+'\
                         '(?P<weight>\d+)\s+(?P<shaping_step>\d+)$'
        )

        '''
           Weight0 Max_Th0 Min_Th0 Weigth1 Max_Th1 Min_Th1  Weight2 Max_Th2 Min_Th2
        ------- ------- ------- ------- ------- -------  ------- ------- ------
        0       0   33647       0       0   37605       0       0   42224       0
        1       0   33468       0       0   37406       0       0   42000       0

        '''
        p6 = re.compile(r'^(?P<q_no>\d+)\s+(?P<weight0>\d+)\s+(?P<max_th0>\d+)\s+(?P<min_th0>\d+)\s+'\
                         '(?P<weight1>\d+)\s+(?P<max_th1>\d+)\s+(?P<min_th1>\d+)\s+'\
                         '(?P<weight2>\d+)\s+(?P<max_th2>\d+)\s+(?P<min_th2>\d+)$'
        )

        '''
        Port       Port            Port    Port          Port
        Priority   Shaped/shared   weight  shaping_step  sharpedWeight
        --------   -------------   ------  ------------  -------------
            2     Sharped           100        1023      1023

        or (older releases)

         Port       Port            Port    Port
        Priority   Shaped/shared   weight  shaping_step
        --------   -------------   ------  ------------
            2     Shaped          1023        1023


        '''
        p7 = re.compile(r'^(?P<priority>\d+)\s+(?P<mode>\S+)\s+(?P<weight>\d+)\s+(?P<step>\d+)\s+(?P<s_weight>\d+)$')
        p7_1 = re.compile(r'^(?P<priority>\d+)\s+(?P<mode>\S+)\s+(?P<weight>\d+)\s+(?P<step>\d+)$')

        for line in output.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict['asic'] = int(group['asic'])
                ret_dict['core'] = int(group['core'])
                ret_dict['data_port'] = int(group['data_port'])
                ret_dict['gpn'] = int(group['gpn'])
                ret_dict['linkspeed'] = group['linkspeed'].lower()
                continue

            m = p2.match(line)
            if m:
                group = m.groupdict()
                ret_dict['afd'] = group['afd'].lower()
                ret_dict['flatafd'] = group['flatafd'].lower()
                ret_dict['qosmap'] = int(group['qosmap'])
                ret_dict['hw_queues'] = dict()
                ret_dict['hw_queues']['min'] =  int(group['hw_queue1'])
                ret_dict['hw_queues']['max'] =  int(group['hw_queue2'])
                continue

            m = p2_1.match(line)
            if m:
                group = m.groupdict()
                ret_dict['data_port'] = int(group['data_port'])
                ret_dict['gpn'] = int(group['gpn'])
                ret_dict['afd'] = group['afd'].lower()
                ret_dict['qosmap'] = int(group['qosmap'])
                ret_dict['hw_queues'] = dict()
                ret_dict['hw_queues']['min'] =  int(group['hw_queue1'])
                ret_dict['hw_queues']['max'] =  int(group['hw_queue2'])
                continue

            m = p3.match(line)
            if m:
                group = m.groupdict()
                ret_dict['drainfast'] = group['drainfast'].lower()
                ret_dict['portsoftstart'] = dict()
                ret_dict['portsoftstart']['min'] =  int(group['portsoftstart1'])
                ret_dict['portsoftstart']['max'] =  int(group['portsoftstart2'])
                ret_dict['buffersharing'] = group['buffersharing'].lower()
                continue

            m = p3_1.match(line)
            if m:
                group = m.groupdict()
                ret_dict['drainfast'] = group['drainfast'].lower()
                ret_dict['portsoftstart'] = dict()
                ret_dict['portsoftstart']['min'] =  int(group['portsoftstart1'])
                ret_dict['portsoftstart']['max'] =  int(group['portsoftstart2'])
                continue

            m = p4.match(line)
            if m:
                group = m.groupdict()
                ret_dict.setdefault('queue', dict()).setdefault(int(group['q_no']), dict())
                ret_dict['queue'][int(group['q_no'])]['dts'] = int(group['dts'])
                ret_dict['queue'][int(group['q_no'])]['hardmax'] = int(group['hardmax'])
                ret_dict['queue'][int(group['q_no'])]['softmax'] = int(group['softmax'])
                ret_dict['queue'][int(group['q_no'])]['portsmin'] = int(group['portsmin'])
                ret_dict['queue'][int(group['q_no'])]['glblsmin'] = int(group['glblsmin'])
                ret_dict['queue'][int(group['q_no'])]['portstend'] = int(group['portstend'])
                ret_dict['queue'][int(group['q_no'])]['qenable'] = group['qenable'].lower()
                continue

            m = p4_1.match(line)
            if m:
                group = m.groupdict()
                ret_dict.setdefault('queue', dict()).setdefault(int(group['q_no']), dict())
                ret_dict['queue'][int(group['q_no'])]['dts'] = int(group['dts'])
                ret_dict['queue'][int(group['q_no'])]['hardmax'] = int(group['hardmax'])
                ret_dict['queue'][int(group['q_no'])]['softmax'] = int(group['softmax'])
                ret_dict['queue'][int(group['q_no'])]['portsmin'] = int(group['portsmin'])
                ret_dict['queue'][int(group['q_no'])]['glblsmin'] = int(group['glblsmin'])
                ret_dict['queue'][int(group['q_no'])]['portstend'] = int(group['portstend'])
                continue

            m = p5.match(line)
            if m:
                group = m.groupdict()
                ret_dict.setdefault('queue', dict()).setdefault(int(group['q_no']), dict())
                ret_dict['queue'][int(group['q_no'])]['priority'] = int(group['priority'])
                ret_dict['queue'][int(group['q_no'])]['schedule_mode'] = group['mode'].lower()
                ret_dict['queue'][int(group['q_no'])]['weight'] = int(group['weight'])
                ret_dict['queue'][int(group['q_no'])]['shaping_step'] = int(group['shaping_step'])
                ret_dict['queue'][int(group['q_no'])]['sharpedweight'] = int(group['sharpedweight'])
                continue

            m = p5_1.match(line)
            if m:
                group = m.groupdict()
                ret_dict.setdefault('queue', dict()).setdefault(int(group['q_no']), dict())
                ret_dict['queue'][int(group['q_no'])]['priority'] = int(group['priority'])
                ret_dict['queue'][int(group['q_no'])]['schedule_mode'] = group['mode'].lower()
                ret_dict['queue'][int(group['q_no'])]['weight'] = int(group['weight'])
                ret_dict['queue'][int(group['q_no'])]['shaping_step'] = int(group['shaping_step'])
                continue

            m = p6.match(line)
            if m:
                group = m.groupdict()
                ret_dict.setdefault('queue', dict()).setdefault(int(group['q_no']), dict())
                ret_dict['queue'][int(group['q_no'])]['weight0'] = int(group['weight0'])
                ret_dict['queue'][int(group['q_no'])]['max_th0'] = int(group['max_th0'])
                ret_dict['queue'][int(group['q_no'])]['min_th0'] = int(group['min_th0'])
                ret_dict['queue'][int(group['q_no'])]['weight1'] = int(group['weight1'])
                ret_dict['queue'][int(group['q_no'])]['max_th1'] = int(group['max_th1'])
                ret_dict['queue'][int(group['q_no'])]['min_th1'] = int(group['min_th1'])
                ret_dict['queue'][int(group['q_no'])]['weight2'] = int(group['weight2'])
                ret_dict['queue'][int(group['q_no'])]['max_th2'] = int(group['max_th2'])
                ret_dict['queue'][int(group['q_no'])]['min_th2'] = int(group['min_th2'])
                continue

            m = p7.match(line)
            if m:
                group = m.groupdict()
                ret_dict['port'] = dict()
                ret_dict['port']['priority'] = int(group['priority'])
                ret_dict['port']['schedule_mode'] = group['mode'].lower()
                ret_dict['port']['weight'] = int(group['weight'])
                ret_dict['port']['shaping_step'] = int(group['step'])
                ret_dict['port']['sharpedweight'] = int(group['s_weight'])
                continue

            m = p7_1.match(line)
            if m:
                group = m.groupdict()
                ret_dict['port'] = dict()
                ret_dict['port']['priority'] = int(group['priority'])
                ret_dict['port']['schedule_mode'] = group['mode'].lower()
                ret_dict['port']['weight'] = int(group['weight'])
                ret_dict['port']['shaping_step'] = int(group['step'])
                continue

        return ret_dict

# ================================================================================
# Parser Schema for 'show platform hardware iomd <slot> qos port <no> ingress queue stats'
#                   'show platform hardware iomd switch <switch_no> <slot> qos port <no> ingress queue stats'
# ================================================================================
class ShowPlatformHardwareIomdQosPortIngressQueueStatsSchema(MetaParser):
    """Schema for show platform hardware iomd <slot> qos port <no> ingress queue stats"""
    '''
    mac-gen2#show platform hardware iomd 10/0 qos port 1 ingress queue stats
    DATA Port:1 StartingQueue:0  Enqueue Counters
    -------------------------------------------
    Queue Buffers Enqueue-TH0 Enqueue-TH1 Enqueue-TH2
    ----- ------- ----------- ----------- -----------
        0       0           0           0           0
        1     314           0           0  1606072000

    DATA Port:0 Drop Counters
    -------------------------------
    Queue Drop-TH0    Drop-TH1    Drop-TH2    SBufDrop    QebDrop
    ----- ----------- ----------- ----------- ----------- -----------
        0           0           0           0           0           0
        1           0           0  1605942200           0           0

    Note: Queuing stats are in bytes
    '''
    schema = {
        'unit': str,
        'data_port': int,
        'startingqueue':  int,
        'queue': {
            int: {
                'buffers': int,
                'enqueue_th0': int,
                'enqueue_th1': int,
                'enqueue_th2': int,
                'drop_th0': int,
                'drop_th1': int,
                'drop_th2': int,
                'sbufdrop': int,
                'qebdrop': int,
            }
        }
    }

# ================================================================================
# Parser for 'show platform hardware iomd <slot> qos port <no> ingress queue stats'
#            'show platform hardware iomd switch <switch_no> <slot> qos port <no> ingress queue stats'
# ================================================================================
class ShowPlatformHardwareIomdQosPortIngressQueueStats(ShowPlatformHardwareIomdQosPortIngressQueueStatsSchema):
    """ parser for "show platform hardware iomd <slot> qos port <no> ingress queue stats" """

    # i.e. show platform hardware iomd 1/0 qos port 24 ingress queue stats"
    cli_command = ["show platform hardware iomd {slot} qos port {port_no} ingress queue stats",
                   "show platform hardware iomd switch {switch_no} {slot} qos port {port_no} ingress queue stats"]

    def cli(self, slot, port_no, switch_no=None, output=None):
        if output is None:
            if not switch_no:
                cmd = self.cli_command[0].format(slot=slot, port_no=str(port_no))
            else:
                cmd = self.cli_command[1].format(slot=slot, port_no=str(port_no), switch_no = switch_no)
            output = self.device.execute(cmd)

        ret_dict = {}

        '''
        DATA Port:1 StartingQueue:0  Enqueue Counters
        '''
        p1 = re.compile(r'^DATA Port:(?P<port_no>\d+)\s+StartingQueue:(?P<starting>\d+)\s+Enqueue Counters$')

        '''
        -------------------------------------------
        Queue Buffers Enqueue-TH0 Enqueue-TH1 Enqueue-TH2
        ----- ------- ----------- ----------- -----------
        0       0           0           0           0
        1     314           0           0  1606072000
        '''
        p2 = re.compile(r'^(?P<queue>\d+)\s+(?P<buf>\d+)\s+(?P<en_th0>\d+)\s+(?P<en_th1>\d+)\s+(?P<en_th2>\d+)$')

        '''
        -------------------------------
        Queue Drop-TH0    Drop-TH1    Drop-TH2    SBufDrop    QebDrop
        ----- ----------- ----------- ----------- ----------- -----------
        0           0           0           0           0           0
        1           0           0  1605942200           0           0
        '''
        p3 = re.compile(r'^(?P<queue>\d+)\s+(?P<dr_th0>\d+)\s+(?P<dr_th1>\d+)\s+(?P<dr_th2>\d+)\s+(?P<sbuf>\d+)\s+(?P<qeb>\d+)$')

        '''
        Note: Queuing stats are in bytes
        '''
        p4 = re.compile(r'Note:\s+Queuing stats are in\s+(?P<unit>\S+)$')

        for line in output.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict['data_port'] = int(group['port_no'])
                ret_dict['startingqueue'] =int(group['starting'])
                continue

            m = p2.match(line)
            if m:
                group = m.groupdict()
                ret_dict.setdefault('queue', dict())
                queue_no = int(group['queue'])
                ret_dict['queue'].setdefault(queue_no, dict())
                ret_dict['queue'][queue_no]['buffers'] = int(group['buf'])
                ret_dict['queue'][queue_no]['enqueue_th0'] = int(group['en_th0'])
                ret_dict['queue'][queue_no]['enqueue_th1'] = int(group['en_th1'])
                ret_dict['queue'][queue_no]['enqueue_th2'] = int(group['en_th2'])
                continue

            m = p3.match(line)
            if m:
                group = m.groupdict()
                ret_dict.setdefault('queue', dict())
                queue_no = int(group['queue'])
                ret_dict['queue'].setdefault(queue_no, dict())
                ret_dict['queue'][queue_no]['drop_th0'] = int(group['dr_th0'])
                ret_dict['queue'][queue_no]['drop_th1'] = int(group['dr_th1'])
                ret_dict['queue'][queue_no]['drop_th2'] = int(group['dr_th2'])
                ret_dict['queue'][queue_no]['sbufdrop'] = int(group['sbuf'])
                ret_dict['queue'][queue_no]['qebdrop'] = int(group['qeb'])
                continue

            m = p4.match(line)
            if m:
                group = m.groupdict()
                ret_dict['unit'] = group['unit'].lower()
                continue

        return ret_dict


# ================================================================================
# Parser Schema for 'show platform hardware iomd <slot> portgroups'
#                   'show platform hardware iomd switch <switch_no> <slot> portgroups'
# ================================================================================
class ShowPlatformHardwareIomdPortgroupsSchema(MetaParser):
    """Schema for show platform hardware iomd <slot> portgroups"""
    '''
    mac-gen2#show platform hardware iomd 10/0 portgroups
    Port  Interface                       Status    Interface  Group Max
    Group                                           Bandwith   Bandwidth


    1     TenGigabitEthernet10/0/2        up         10G
    1     TenGigabitEthernet10/0/3        up         10G
    1     TenGigabitEthernet10/0/4        up         10G
    1     TenGigabitEthernet10/0/5        up         10G
    1     TenGigabitEthernet10/0/6        up         10G       60G
    1     TenGigabitEthernet10/0/7        up         10G
    1     TenGigabitEthernet10/0/8        up         10G
    1     TenGigabitEthernet10/0/9        up         10G
    1     TenGigabitEthernet10/0/10       up         10G
    1     TenGigabitEthernet10/0/11       up         10G
    1     TenGigabitEthernet10/0/12       up         10G

    2     TenGigabitEthernet10/0/13       up         10G
    2     TenGigabitEthernet10/0/14       up         10G
    2     TenGigabitEthernet10/0/15       up         10G
    2     TenGigabitEthernet10/0/16       up         10G
    2     TenGigabitEthernet10/0/17       up         10G
    2     TenGigabitEthernet10/0/18       up         10G       60G
    2     TenGigabitEthernet10/0/19       down       10G
    '''
    schema = {
        'portgroup': {
            int: {
                'intf': {
                    str: {
                        'status': str,
                        'intf_bw': str,
                        'group_max_bw': str,
                        'portgroup': int
                    }
                }
            }
        }
    }

# ================================================================================
# Parser for 'show platform hardware iomd <slot> portgroups'
#            'show platform hardware iomd switch <switch_no> <slot> portgroups'
# ================================================================================
class ShowPlatformHardwareIomdPortgroups(ShowPlatformHardwareIomdPortgroupsSchema):
    """Parser for 'show platform hardware iomd <slot> portgroups'"""

    cli_command = ["show platform hardware iomd {slot} portgroups",
                   "show platform hardware iomd switch {switch_no} {slot} portgroups"]

    def cli(self, slot, switch_no=None, output=None):
        if output is None:
            if not switch_no:
                cmd = self.cli_command[0].format(slot=slot)
            else:
                cmd = self.cli_command[1].format(slot=slot, switch_no = switch_no)
            output = self.device.execute(cmd)

        ret_dict = {}
        group_bw_dict = {}


        # 1     TenGigabitEthernet10/0/18       up         10G       60G
        p1 = re.compile(r'^(?P<group>\d+)\s+(?P<intf>\S+)\s+(?P<status>\S+)\s+(?P<intf_bw>\S+)\s+(?P<group_bw>\S+)$')

        # 1     TenGigabitEthernet10/0/1        up         10G
        p1_1 = re.compile(r'^(?P<group>\d+)\s+(?P<intf>\S+)\s+(?P<status>\S+)\s+(?P<intf_bw>\S+)$')


        ## Pass1: Get group max bandwidth first
        for line in output.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                ret_dict.setdefault('portgroup', dict())
                parsed = m.groupdict()
                group_no = int(parsed['group'])
                ret_dict['portgroup'].setdefault(group_no, dict())
                ret_dict['portgroup'][group_no].setdefault('intf', dict())

                intf_dict = dict()
                intf_dict['status'] = parsed['status'].lower()
                intf_dict['intf_bw'] = parsed['intf_bw']
                intf_dict['group_max_bw'] = parsed['group_bw']
                intf_dict['portgroup'] = group_no

                intf = parsed['intf'].lower()
                ret_dict['portgroup'][group_no]['intf'][intf] = intf_dict

                # for Pass2
                group_bw_dict[group_no] = parsed['group_bw']

        ## Pass2:
        for line in output.splitlines():
            line = line.strip()

            m = p1_1.match(line)
            if m:
                ret_dict.setdefault('portgroup', dict())
                parsed = m.groupdict()
                group_no = int(parsed['group'])
                ret_dict['portgroup'].setdefault(group_no, dict())
                ret_dict['portgroup'][group_no].setdefault('intf', dict())

                intf_dict = dict()
                intf_dict['status'] = parsed['status'].lower()
                intf_dict['intf_bw'] = parsed['intf_bw']
                intf_dict['portgroup'] = group_no
                if group_no in group_bw_dict:  # schema should fail if not found
                    intf_dict['group_max_bw'] = group_bw_dict[group_no]

                intf = parsed['intf'].lower()
                ret_dict['portgroup'][group_no]['intf'][intf] = intf_dict

        return ret_dict

# ================================================================================
# Parser Schema for 'show platform hardware fed active fwd-asic register read register-name'
# ================================================================================
class ShowPlatformHardwareRegisterReadAsicSchema(MetaParser):
    '''
    This parser should fit any platform hardware Register Read CLIs:
    i.e.
    show platform hardware fed active fwd-asic register read register-name xyz asic n core m
    show platform hardware fed switch x fwd-asic register read register-name xyz asic n core m
    '''
    schema = {
        'asic': {
            int: {
                'core': {
                    int: {
                        Any(): str
                    }
                }
            }
        }
    }

class ShowPlatformHardwareRegisterReadAsic(ShowPlatformHardwareRegisterReadAsicSchema):
    '''
    show platform hardware fed active fwd-asic register read register-name xyz asic n core m
    show platform hardware fed switch x fwd-asic register read register-name xyz asic n core m
    '''
    cli_command = ['show platform hardware fed active fwd-asic register read register-name {reg_name} asic {asic} core {core}',
                   'show platform hardware fed switch {switch_no} fwd-asic register-name read register-name {reg_name} asic {asic} core {core}']

    def cli(self, reg_name, asic, core, switch_no=None, output=None):
        if output is None:
            if not switch_no:
                cmd = self.cli_command[0].format(reg_name = reg_name, asic=asic, core=core)
            else:
                cmd = self.cli_command[1].format(reg_name = reg_name, asic=asic, core=core, switch_no = switch_no)
            output = self.device.execute(cmd)

        ret_dict = {}

        # For asic 1 core 0
        p0 = re.compile(r'^For +asic +(?P<asic>\d+) +core +(?P<core>\d+)$')

        # <key>: <value>   i.e. waitTimer                 : 0xfffbfff88
        p1 = re.compile(r'^(?P<key>\S+)\s*:\s*(?P<hex>0[xX][0-9a-fA-F]+)$')

        for line in output.splitlines():
            line = line.strip()

            # For asic 1 core 0 (Initilize the dict of the asic/core combination)
            m = p0.match(line)
            if m:
                parsed = m.groupdict()
                asic = int(parsed['asic'])
                core = int(parsed['core'])
                ret_dict.setdefault('asic', dict())
                ret_dict['asic'].setdefault(asic, dict())
                ret_dict['asic'][asic].setdefault('core', dict())
                ret_dict['asic'][asic]['core'].setdefault(core, dict())
                current_ret_dict = ret_dict['asic'][asic]['core'][core]
                continue

            # <key>: <value> ... any values that can match this pattern will be put under the asic/core dict
            m = p1.match(line)
            if m:
                parsed = m.groupdict()
                current_ret_dict[parsed['key']] = parsed['hex']

        return ret_dict

# ======================================================
# Parser for 'show platform software wired-client switch <active/standby> f0 '
# ======================================================

class ShowPlatformSoftwareWiredClientSwitchActiveF0Schema(MetaParser):
    """Schema for show platform software wired-client switch <active/standby>} f0"""

    schema = {
        'mac_address': {
            Any(): {
                'id': str,
                'fwd': str,
                'open_access': str,
                'status': str,
            },
        },
    }

class ShowPlatformSoftwareWiredClientSwitchActiveF0(ShowPlatformSoftwareWiredClientSwitchActiveF0Schema):
    """Parser for show platform software wired-client switch <active/standby> f0"""

    cli_command = 'show platform software wired-client switch {switch} f0'

    def cli(self, switch=None, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(switch=switch))

        # 0x13151bdb  001b.0c18.918d  Yes      No            Done
        p1 = re.compile(r"^(?P<id>\S+)\s+(?P<mac_address>\S+)\s+(?P<fwd>\w+)\s+(?P<open_access>\w+)\s+(?P<status>\w+)\s+$")

        ret_dict = {}

        for line in output.splitlines():

            # 0x13151bdb  001b.0c18.918d  Yes      No            Done
            match_obj = p1.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                mac_address_var = dict_val['mac_address']
                if 'mac_address' not in ret_dict:
                    mac_address = ret_dict.setdefault('mac_address', {})
                if mac_address_var not in ret_dict['mac_address']:
                    mac_address_dict = ret_dict['mac_address'].setdefault(mac_address_var, {})
                mac_address_dict['id'] = dict_val['id']
                mac_address_dict['fwd'] = dict_val['fwd']
                mac_address_dict['open_access'] = dict_val['open_access']
                mac_address_dict['status'] = dict_val['status']
                continue

        return ret_dict

# ======================================================
# Parser for 'show platform software fed switch active vp summary vlan {vlan}'
# ======================================================

class ShowPlatformSoftwareFedSwitchActiveVpSummaryVlanSchema(MetaParser):
    """Schema for show platform software fed switch <active/standby> vp summary vlan <vlan>"""

    schema = {
        'if_id': {
            Any(): {
                'vlan_id': int,
                'pvlan_mode': str,
                'pvlan_vlan': int,
                'stp_state': str,
                'vtp_pruned': str,
                'untagged': str,
            },
        },
    }

class ShowPlatformSoftwareFedSwitchActiveVpSummaryVlan(ShowPlatformSoftwareFedSwitchActiveVpSummaryVlanSchema):
    """Parser for show platform software fed switch active vp summary vlan <vlan>"""

    cli_command = 'show platform software fed switch {switch} vp summary vlan {vlan}'

    def cli(self, switch=None, vlan=None, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(switch=switch,vlan=vlan))

        #               32          100         none            1  forwarding          No                No
        p1 = re.compile(r"^\s+(?P<if_id>\d+)\s+(?P<vlan_id>\d+)\s+(?P<pvlan_mode>\w+)\s+(?P<pvlan_vlan>\d+)\s+(?P<stp_state>\w+)\s+(?P<vtp_pruned>\w+)\s+(?P<untagged>\w+)\s+$")

        ret_dict = {}

        for line in output.splitlines():

            #               32          100         none            1  forwarding          No                No
            match_obj = p1.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if_id_var = dict_val['if_id']
                if 'if_id' not in ret_dict:
                    if_id = ret_dict.setdefault('if_id', {})
                if if_id_var not in ret_dict['if_id']:
                    if_id_dict = ret_dict['if_id'].setdefault(if_id_var, {})
                if_id_dict['vlan_id'] = int(dict_val['vlan_id'])
                if_id_dict['pvlan_mode'] = dict_val['pvlan_mode']
                if_id_dict['pvlan_vlan'] = int(dict_val['pvlan_vlan'])
                if_id_dict['stp_state'] = dict_val['stp_state']
                if_id_dict['vtp_pruned'] = dict_val['vtp_pruned']
                if_id_dict['untagged'] = dict_val['untagged']
                continue

        return ret_dict



# ======================================================
# Parser for 'show redundancy config-sync failures mcl '
# ======================================================

class ShowRedundancyConfigSyncFailuresMclSchema(MetaParser):
    """Schema for show redundancy config-sync failures mcl"""

    schema = {
        'err_list': list,
    }

class ShowRedundancyConfigSyncFailuresMcl(ShowRedundancyConfigSyncFailuresMclSchema):
    """Parser for show redundancy config-sync failures mcl"""

    cli_command = 'show redundancy config-sync failures mcl'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        # The list is Empty
        p1 = re.compile(r"^The\s+list\s+is\s+Empty$")

        # 00:06:31: Config Sync: Starting lines from MCL file:
        p2 = re.compile(r"^\S+\s+Config Sync: Starting lines from MCL file:$")

        ret_dict = {}
        err_flag = False

        for line in output.splitlines():
            line = line.strip()

            # The list is Empty
            match_obj = p1.match(line)
            if match_obj:
                ret_dict.setdefault("err_list", [])
                break

            # 00:06:31: Config Sync: Starting lines from MCL file:
            match_obj = p2.match(line)
            if match_obj:
                err_flag = True
                ret_dict.setdefault('err_list', []).append(line)
                continue

            # Append all the config-sync failures
            if err_flag:
                ret_dict["err_list"].append(line)
                continue

        return ret_dict


# ========================================================================
# Schema for 'show platform software wired-client switch {switch_state} r0 '
# ========================================================================

class ShowPlatformSoftwareWiredClientSwitchR0Schema(MetaParser):
    """Schema for show platform software wired-client switch {switch_state} r0"""

    schema = {
        'wired_client': {
            Any(): {
                'id': str,
                'mac': str,
                'fwd': str,
                'open_access': str,
            },
        },
    }

# ==========================================================================
# Parser for 'show platform software wired-client switch {switch_state} r0 '
# ==========================================================================

class ShowPlatformSoftwareWiredClientSwitchR0(ShowPlatformSoftwareWiredClientSwitchR0Schema):
    """Parser for show platform software wired-client switch {switch_state} r0"""

    cli_command = 'show platform software wired-client switch {switch_state} r0'

    def cli(self, switch_state, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(switch_state=switch_state))

        # 0x13151bdb  001b.0c18.918d  Yes    No            
        p1 = re.compile(r'^(?P<id>[0-9a-z]+) +'
                  '(?P<mac>[\w\.]+) +'
                  '(?P<fwd>\w+) +'
                  '(?P<open_access>\w+)$')
        ret_dict = {}
        
        for line in output.splitlines():
            line = line.strip()

            # 0x13151bdb  001b.0c18.918d  Yes    No
            m = p1.match(line)
            if m:
                dict_val = m.groupdict()
                id_var = dict_val['id']
                if 'wired_client' not in ret_dict:
                    wired_client = ret_dict.setdefault('wired_client', {})
                if id_var not in ret_dict['wired_client']:
                    id_dict = ret_dict['wired_client'].setdefault(id_var, {})
                id_dict['id'] = dict_val['id']
                id_dict['mac'] = dict_val['mac']
                id_dict['fwd'] = dict_val['fwd']
                id_dict['open_access'] = dict_val['open_access']
                continue

        return ret_dict

# =========================================================================
# Parser for 'show platform authentication sbinfo interface {interface} '
# =========================================================================

class ShowPlatformAuthenticationSbinfoInterfaceSchema(MetaParser):
    """Schema for show platform authentication sbinfo interface {interface}"""

    schema = {
        'sb_info': {
            'sb_access_vlan': int,
            'sb_voice_vlan': int,
            'conf_access_vlan': int,
            'conf_voice_vlan': int,
            'oper_access_vlan': int,
            'oper_voice_vlan': int,
            'def_host_access': int,
            'auth_in_vp': bool,
            'client_count': int,
            'vlan_count': int,
            'port_ctrl_enable': bool,
            'cdp_bypass_enable': bool,
            'port_mode': str,
            'ctrl_dir': str,
        },
        'mac': {
            Any(): {
                'int': str,
                'mac': str,
                'domain': str,
                'vlan': int,
                'clent_handle': str,
                'port_open': str,
                'flags': str,
            },
        },
        'int_vlan': {
            Any(): {
                'int': str,
                'vlan': int,
                'domain': str,
                'user_count': int,
                'fwd_count': int,
                'client_count': int,
                'vp_state': int,
                'flags': str,
            },
        },
    }

# =====================================================================
# Parser for 'show platform authentication sbinfo interface {interface} '
# ======================================================================
class ShowPlatformAuthenticationSbinfoInterface(ShowPlatformAuthenticationSbinfoInterfaceSchema):
    """Parser for show platform authentication sbinfo interface {interface}"""

    cli_command = 'show platform authentication sbinfo interface {interface}'

    def cli(self, interface, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(interface=interface))

        # SB Access Vlan: 1
        p1 = re.compile(r"^\s+SB\s+Access\s+Vlan:\s+(?P<sb_access_vlan>\d+)$")
        # SB Voice Vlan: 100
        p1_1 = re.compile(r"^\s+SB\s+Voice\s+Vlan:\s+(?P<sb_voice_vlan>\d+)$")
        # Conf Access Vlan: 1
        p1_2 = re.compile(r"^\s+Conf\s+Access\s+Vlan:\s+(?P<conf_access_vlan>\d+)$")
        # Conf Voice Vlan: 100
        p1_3 = re.compile(r"^\s+Conf\s+Voice\s+Vlan:\s+(?P<conf_voice_vlan>\d+)$")
        # Oper Access Vlan: 1
        p1_4 = re.compile(r"^\s+Oper\s+Access\s+Vlan:\s+(?P<oper_access_vlan>\d+)$")
        # Oper Voice Vlan: 100
        p1_5 = re.compile(r"^\s+Oper\s+Voice\s+Vlan:\s+(?P<oper_voice_vlan>\d+)$")
        # Default Host Access: 1
        p1_6 = re.compile(r"^\s+Default\s+Host\s+Access:\s+(?P<def_host_access>\d+)$")
        # Auth In VP: True
        p1_7 = re.compile(r"^\s+Auth\s+In\s+VP:\s+(?P<auth_in_vp>\w+)$")
        # Client Count : 1
        p1_8 = re.compile(r"^\s+Client\s+Count\s+:\s+(?P<client_count>\d+)$")
        # Vlan Count : 2
        p1_9 = re.compile(r"^\s+Vlan\s+Count\s+:\s+(?P<vlan_count>\d+)$")
        # Port-Control Auto Enabled : TRUE
        p1_10 = re.compile(r"^Port-Control\s+Auto\s+Enabled\s+:\s+(?P<port_ctrl_enable>\w+)$")
        # CDP Bypass Enabled : FALSE
        p1_11 = re.compile(r"^\s+CDP\s+Bypass\s+Enabled\s+:\s+(?P<cdp_bypass_enable>\w+)$")
        # Port Mode : CLOSED
        p1_12 = re.compile(r"^\s+Port\s+Mode\s+:\s+(?P<port_mode>\w+)$")
        # Control Direction : BOTH
        p1_13 = re.compile(r"^\s+Control\s+Direction\s+:\s+(?P<ctrl_dir>\w+)$")
        # Gi1/0/24  001b.0c18.918d    VOICE    100  0x94000008  0x0002  None
        p2 = re.compile(r"^\s+(?P<int>\S+)\s+(?P<mac>\S+)\s+(?P<domain>\w+)\s+(?P<vlan>\d+)\s+(?P<clent_handle>\S+)\s+(?P<port_open>\S+)\s+(?P<flags>\w+)$")
        # Gi1/0/24  1       DATA    1     0     0       2     None
        p3 = re.compile(r"^\s+(?P<int>\S+)\s+(?P<vlan>\d+)\s+(?P<domain>\w+)\s+(?P<user_count>\d+)\s+(?P<fwd_count>\d+)\s+(?P<client_count>\d+)\s+(?P<vp_state>\S+\s+)\s+(?P<flags>\w+)$")

        ret_dict = {}

        for line in output.splitlines():

            # SB Access Vlan: 1
            m = p1.match(line)
            if m:
                dict_val = m.groupdict()
                if 'sb_info' not in ret_dict:
                    sb_info = ret_dict.setdefault('sb_info', {})
                sb_info['sb_access_vlan'] = int(dict_val['sb_access_vlan'])
                continue

            # SB Voice Vlan: 100
            m = p1_1.match(line)
            if m:
                dict_val = m.groupdict()
                if 'sb_info' not in ret_dict:
                    sb_info = ret_dict.setdefault('sb_info', {})
                sb_info['sb_voice_vlan'] = int(dict_val['sb_voice_vlan'])
                continue

            # Conf Access Vlan: 1
            m = p1_2.match(line)
            if m:
                dict_val = m.groupdict()
                if 'sb_info' not in ret_dict:
                    sb_info = ret_dict.setdefault('sb_info', {})
                sb_info['conf_access_vlan'] = int(dict_val['conf_access_vlan'])
                continue

            # Conf Voice Vlan: 100
            m = p1_3.match(line)
            if m:
                dict_val = m.groupdict()
                if 'sb_info' not in ret_dict:
                    sb_info = ret_dict.setdefault('sb_info', {})
                sb_info['conf_voice_vlan'] = int(dict_val['conf_voice_vlan'])
                continue

            # Oper Access Vlan: 1
            m = p1_4.match(line)
            if m:
                dict_val = m.groupdict()
                if 'sb_info' not in ret_dict:
                    sb_info = ret_dict.setdefault('sb_info', {})
                sb_info['oper_access_vlan'] = int(dict_val['oper_access_vlan'])
                continue

            # Oper Voice Vlan: 100
            m = p1_5.match(line)
            if m:
                dict_val = m.groupdict()
                if 'sb_info' not in ret_dict:
                    sb_info = ret_dict.setdefault('sb_info', {})
                sb_info['oper_voice_vlan'] = int(dict_val['oper_voice_vlan'])
                continue

            # Default Host Access: 1
            m = p1_6.match(line)
            if m:
                dict_val = m.groupdict()
                if 'sb_info' not in ret_dict:
                    sb_info = ret_dict.setdefault('sb_info', {})
                sb_info['def_host_access'] = int(dict_val['def_host_access'])
                continue

            # Auth In VP: True
            m = p1_7.match(line)
            if m:
                dict_val = m.groupdict()
                if 'sb_info' not in ret_dict:
                    sb_info = ret_dict.setdefault('sb_info', {})
                sb_info['auth_in_vp'] = bool(dict_val['auth_in_vp'])
                continue

            # Client Count : 1
            m = p1_8.match(line)
            if m:
                dict_val = m.groupdict()
                if 'sb_info' not in ret_dict:
                    sb_info = ret_dict.setdefault('sb_info', {})
                sb_info['client_count'] = int(dict_val['client_count'])
                continue

            # Vlan Count : 2
            m = p1_9.match(line)
            if m:
                dict_val = m.groupdict()
                if 'sb_info' not in ret_dict:
                    sb_info = ret_dict.setdefault('sb_info', {})
                sb_info['vlan_count'] = int(dict_val['vlan_count'])
                continue

            # Port-Control Auto Enabled : TRUE
            m = p1_10.match(line)
            if m:
                dict_val = m.groupdict()
                if 'sb_info' not in ret_dict:
                    sb_info = ret_dict.setdefault('sb_info', {})
                sb_info['port_ctrl_enable'] = bool(dict_val['port_ctrl_enable'])
                continue

            # CDP Bypass Enabled : FALSE
            m = p1_11.match(line)
            if m:
                dict_val = m.groupdict()
                if 'sb_info' not in ret_dict:
                    sb_info = ret_dict.setdefault('sb_info', {})
                sb_info['cdp_bypass_enable'] = bool(dict_val['cdp_bypass_enable'])
                continue

            # Port Mode : CLOSED
            m = p1_12.match(line)
            if m:
                dict_val = m.groupdict()
                if 'sb_info' not in ret_dict:
                    sb_info = ret_dict.setdefault('sb_info', {})
                sb_info['port_mode'] = dict_val['port_mode']
                continue

            # Control Direction : BOTH
            m = p1_13.match(line)
            if m:
                dict_val = m.groupdict()
                if 'sb_info' not in ret_dict:
                    sb_info = ret_dict.setdefault('sb_info', {})
                sb_info['ctrl_dir'] = dict_val['ctrl_dir']
                continue

            # Gi1/0/24  001b.0c18.918d    VOICE    100  0x94000008  0x0002  None
            m = p2.match(line)
            if m:
                dict_val = m.groupdict()
                int_var = dict_val['int']
                if 'mac' not in ret_dict:
                    mac = ret_dict.setdefault('mac', {})
                if int_var not in ret_dict['mac']:
                    int_dict = ret_dict['mac'].setdefault(int_var, {})
                int_dict['int'] = dict_val['int']
                int_dict['mac'] = dict_val['mac']
                int_dict['domain'] = dict_val['domain']
                int_dict['vlan'] = int(dict_val['vlan'])
                int_dict['clent_handle'] = dict_val['clent_handle']
                int_dict['port_open'] = dict_val['port_open']
                int_dict['flags'] = dict_val['flags']
                continue

            # Gi1/0/24  1       DATA    1     0     0       2     None
            m = p3.match(line)
            if m:
                dict_val = m.groupdict()
                vlan_var = dict_val['vlan']
                if 'int_vlan' not in ret_dict:
                    int_vlan = ret_dict.setdefault('int_vlan', {})
                if vlan_var not in ret_dict['int_vlan']:
                    vlan_dict = ret_dict['int_vlan'].setdefault(vlan_var, {})
                vlan_dict['int'] = dict_val['int']
                vlan_dict['vlan'] = int(dict_val['vlan'])
                vlan_dict['domain'] = dict_val['domain']
                vlan_dict['user_count'] = int(dict_val['user_count'])
                vlan_dict['fwd_count'] = int(dict_val['fwd_count'])
                vlan_dict['client_count'] = int(dict_val['client_count'])
                vlan_dict['vp_state'] = int(dict_val['vp_state'])
                vlan_dict['flags'] = dict_val['flags']
                continue


        return ret_dict


# ======================================================
# Schema for 'show platform host-access-table {interface} '
# ======================================================

class ShowPlatformHostAccessTableIntfSchema(MetaParser):
    """Schema for show platform host-access-table <intf>"""

    schema = {
        'host_access': {
            Any(): {
                'src_address': str,
                'vlan_id': int,
                'access_mode': str,
                'feature': str,
                'type': str,
            },
            'current_feature': str,
            'default': str,
        },
    }

class ShowPlatformHostAccessTableIntf(ShowPlatformHostAccessTableIntfSchema):
    """Parser for show platform host-access-table <intf>"""

    cli_command = 'show platform host-access-table {intf}'

    def cli(self, intf=None, output=None):
        if output is None:
            cmd = self.cli_command.format(intf=intf)
            output = self.device.execute(cmd)

        # 001b.0c18.918d       100         permit         dot1x        dynamic
        p1 = re.compile(r"^(?P<src_address>\S+)\s+(?P<vlan_id>\d+)\s+(?P<access_mode>\w+)\s+(?P<feature>\S+)\s+(?P<type>\w+)$")
        # Current feature:  dot1x
        p1_1 = re.compile(r"^Current\s+feature:\s+(?P<current_feature>\S+)$")
        # Default            ask
        p1_2 = re.compile(r"^Default\s+(?P<default>\w+)$")

        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()

            # 001b.0c18.918d       100         permit         dot1x        dynamic
            m = p1.match(line)
            if m:
                dict_val = m.groupdict()
                vlan_id_var = dict_val['vlan_id']
                if 'host_access' not in ret_dict:
                    host_access = ret_dict.setdefault('host_access', {})
                if vlan_id_var not in ret_dict['host_access']:
                    vlan_id_dict = ret_dict['host_access'].setdefault(vlan_id_var, {})
                vlan_id_dict['src_address'] = dict_val['src_address']
                vlan_id_dict['vlan_id'] = int(dict_val['vlan_id'])
                vlan_id_dict['access_mode'] = dict_val['access_mode']
                vlan_id_dict['feature'] = dict_val['feature']
                vlan_id_dict['type'] = dict_val['type']
                continue

            # Current feature:  dot1x
            m = p1_1.match(line)
            if m:
                dict_val = m.groupdict()
                if 'host_access' not in ret_dict:
                    host_access = ret_dict.setdefault('host_access', {})
                host_access['current_feature'] = dict_val['current_feature']
                continue

            # Default            ask
            m = p1_2.match(line)
            if m:
                dict_val = m.groupdict()
                if 'host_access' not in ret_dict:
                    host_access = ret_dict.setdefault('host_access', {})
                host_access['default'] = dict_val['default']
                continue


        return ret_dict


# ======================================================
# Schema for 'show platform software fed switch <state> ifm if-id <if_id> '
# ======================================================

class ShowPlatformSoftwareFedSwitchStateIfmIfIdIf_idSchema(MetaParser):
    """Schema for show platform software fed switch <state> ifm if-id <if_id>"""

    schema = {
        'int_info': {
            Optional('name'): str,
            'if_id': str,
            Optional('blk_ptr'): str,
            Optional('blk_state'): str,
            Optional('state'): str,
            Optional('status'): str,
            Optional('ref_count'): int,
            Optional('type'): str,
            Optional('create_time'): str,
            Optional('last_modfd_time'): str,
            Optional('cur_time'): str,
            Optional('mac'): str,
            Optional('parent_if_id'): str,
            Optional('client_if_id'): str,
            Optional('switch_num'): int,
            Optional('client_type'): int,
            Optional('asic_num'): int,
            Optional('client_le'): str,
            Optional('dns_punt'): str,
            Optional('ref_count_feature'): str,
        },
        Optional('port_info'): {
            Optional('handle'): str,
            Optional('type'): str,
            Optional('identifier'): str,
            Optional('unit'): str,
        },
        Optional('port_logical_subblk'): {
            Optional('client_le_handle'): str,
            Optional('parent_identifier'): str,
            Optional('asic_num'): str,
            Optional('switch_num'): str,
            Optional('rewr_type'): str,
            Optional('client_mac'): str,
            Optional('ri_handle'): int,
            Optional('di_handle'): int,
            Optional('dst_adj_handle'): int,
            Optional('dst_lkp_handle'): int,
            Optional('src_adj_handle'): str,
            Optional('src_lkp_handle'): int,
        },
        Optional('port_l2_subblk'): {
            Optional('enabled'): str,
            Optional('allow_dot1q'): str,
            Optional('allow_native'): str,
            Optional('def_vlan'): int,
            Optional('allow_priority_tag'): str,
            Optional('allow_unkn_ucast'): str,
            Optional('allow_unkn_mcast'): str,
            Optional('allow_unkn_bcast'): str,
            Optional('protected'): str,
            Optional('ipv4_arp_snp'): str,
            Optional('ipv6_arp_snp'): str,
            Optional('jumbo_mtu'): int,
            Optional('learning_mode'): int,
            Optional('vepa'): str,
            Optional('app_hosting'): str,
        },
        Optional('port_qos_subblk'): {
            Optional('trust_type'): str,
            Optional('def_value'): int,
            Optional('ingrs_tbl_map'): str,
            Optional('egrs_tbl_map'): str,
            Optional('q_map'): str,
        },
        Optional('port_cts_subblk'): {
            Optional('disable_sgacl'): str,
            Optional('trust'): str,
            Optional('propagate'): str,
            Optional('port_sgt'): str,
        },
        Optional('ifm_feature_ref_counts'): {
            Optional('fid'): str,
            Optional('ref_count'): int,
        },
    }

# ======================================================
# Parser for 'show platform software fed switch <state> ifm if-id <if_id> '
# ======================================================
class ShowPlatformSoftwareFedSwitchStateIfmIfIdIf_id(ShowPlatformSoftwareFedSwitchStateIfmIfIdIf_idSchema):
    """Parser for show platform software fed switch <state> ifm if-id <if_id>"""

    cli_command = 'show platform software fed switch {state} ifm if-id {if_id}'

    def cli(self, state=None, if_id=None, output=None):
        if output is None:
            cmd = self.cli_command.format(state=state, if_id=if_id)
            output = self.device.execute(cmd)

        # Interface Name          : C320150491
        p1 = re.compile(r"^Interface\s+Name\s+:\s+(?P<name>\S+)$")
        # Interface IF_ID         : 0x0000000013151bdb
        p1_1 = re.compile(r"^Interface\s+IF_ID\s+:\s+(?P<if_id>\S+)$")
        # Interface Block Pointer : 0x7f16cd385568
        p1_2 = re.compile(r"^Interface\s+Block\s+Pointer\s+:\s+(?P<blk_ptr>\S+)$")
        # Interface Block State   : READY
        p1_3 = re.compile(r"^Interface\s+Block\s+State\s+:\s+(?P<blk_state>\w+)$")
        # Interface State         : Enabled
        p1_4 = re.compile(r"^Interface\s+State\s+:\s+(?P<state>\w+)$")
        # Interface Status        : ADD, UPD
        p1_5 = re.compile(r"^Interface\s+Status\s+:\s+(?P<status>\S+\s+\S+)$")
        # Interface Ref-Cnt       : 2
        p1_6 = re.compile(r"^Interface\s+Ref-Cnt\s+:\s+(?P<ref_count>\d+)$")
        # Interface Type          : WIRED_CLIENT
        p1_7 = re.compile(r"^Interface\s+Type\s+:\s+(?P<type>\S+)$")
        # Created Time            : 2022/09/29 12:17:16.343
        p1_8 = re.compile(r"^Created\s+Time\s+:\s+(?P<create_time>\S+\s+\S+)$")
        # Last Modified Time      : 2022/09/29 12:17:16.387
        p1_9 = re.compile(r"^Last\s+Modified\s+Time\s+:\s+(?P<last_modfd_time>\S+\s+\S+)$")
        # Current Time            : 2022/09/29 12:29:36.705
        p1_10 = re.compile(r"^Current\s+Time\s+:\s+(?P<cur_time>\S+\s+\S+)$")
        #   mac            : 001b.0c18.918d
        p1_11 = re.compile(r"^mac\s+:\s+(?P<mac>\S+)$")
        #   parent if_id   : 0x0000000000000020
        p1_12 = re.compile(r"^parent\s+if_id\s+:\s+(?P<parent_if_id>\S+)$")
        #   Client if_id   : 0x0000000013151bdb
        p1_13 = re.compile(r"^Client\s+if_id\s+:\s+(?P<client_if_id>\S+)$")
        #   Switch Num     : 1
        p1_14 = re.compile(r"^Switch\s+Num\s+:\s+(?P<switch_num>\d+)$")
        #   Client type    : 1
        p1_15 = re.compile(r"^Client\s+type\s+:\s+(?P<client_type>\d+)$")
        #   ASIC Num       : 1
        p1_16 = re.compile(r"^ASIC\s+Num\s+:\s+(?P<asic_num>\d+)$")
        #   Client LE      : 0x7f16cd0caaa8
        p1_17 = re.compile(r"^Client\s+LE\s+:\s+(?P<client_le>\S+)$")
        #   DNS punt       : False
        p1_18 = re.compile(r"^DNS\s+punt\s+:\s+(?P<dns_punt>\S+)$")
        # Ref Count : 2 (feature Ref Counts + 1)
        p1_19 = re.compile(r"^Ref\s+Count\s+:\s+(?P<ref_count_feature>\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+)$")
        #   Handle ............ [0x8b00013f]
        p2 = re.compile(r"^Handle\s+\.*\s+\[(?P<handle>\S+)\]$")
        #   Type .............. [Wired-client]
        p2_1 = re.compile(r"^Type\s+\.*\s+\[(?P<type>\S+)\]$")
        #   Identifier ........ [0x13151bdb]
        p2_2 = re.compile(r"^Identifier\s+\.*\s+\[(?P<identifier>\S+)\]$")
        #   Unit .............. [320150491]
        p2_3 = re.compile(r"^Unit\s+\.*\s+\[(?P<unit>\S+)\]$")
        #       Client LE handle .... [0x7f16cd0caaa8]
        p3 = re.compile(r"^Client\s+LE\s+handle\s+\.*\s+\[(?P<client_le_handle>\S+)\]$")
        #       Parent Identifier : 0x20
        p3_1 = re.compile(r"^Parent\s+Identifier\s+:\s+(?P<parent_identifier>\S+)$")
        #       Asic num          : 0x1
        p3_2 = re.compile(r"^Asic\s+num\s+:\s+(?P<asic_num>\S+)$")
        #       Switch num        : 0x1
        p3_3 = re.compile(r"^Switch\s+num\s+:\s+(?P<switch_num>\S+)$")
        #       Rewrite type      : 0x0
        p3_4 = re.compile(r"^Rewrite\s+type\s+:\s+(?P<rewr_type>\S+)$")
        #       Client mac        : 1:0:0:0:0:0
        p3_5 = re.compile(r"^Client\s+mac\s+:\s+(?P<client_mac>\S+)$")
        #       RI handle         : 53
        p3_6 = re.compile(r"^RI\s+handle\s+:\s+(?P<ri_handle>\d+)$")
        #       DI handle         : 0
        p3_7 = re.compile(r"^DI\s+handle\s+:\s+(?P<di_handle>\d+)$")
        #       Dst Adj  handle   : 0
        p3_8 = re.compile(r"^Dst\s+Adj\s+handle\s+:\s+(?P<dst_adj_handle>\d+)$")
        #       Dst Lookup handle : 0
        p3_9 = re.compile(r"^Dst\s+Lookup\s+handle\s+:\s+(?P<dst_lkp_handle>\d+)$")
        #       Src Adj  handle   : 0x53
        p3_10 = re.compile(r"^Src\s+Adj\s+handle\s+:\s+(?P<src_adj_handle>\S+)$")
        #       Src Lookup handle : 0
        p3_11 = re.compile(r"^Src\s+Lookup\s+handle\s+:\s+(?P<src_lkp_handle>\d+)$")


        #       Enabled ............. [No]
        p4 = re.compile(r"^Enabled\s+\.*\s+\[(?P<enabled>\w+)\]$")
        #       Allow dot1q ......... [No]
        p4_1 = re.compile(r"^Allow\s+dot1q\s+\.*\s+\[(?P<allow_dot1q>\w+)\]$")
        #       Allow native ........ [No]
        p4_2 = re.compile(r"^Allow\s+native\s+\.*\s+\[(?P<allow_native>\w+)\]$")
        #       Default VLAN ........ [0]
        p4_3 = re.compile(r"^Default\s+VLAN\s+\.*\s+\[(?P<def_vlan>\d+)\]$")
        #       Allow priority tag ... [No]
        p4_4 = re.compile(r"^Allow\s+priority\s+tag\s+\.*\s+\[(?P<allow_priority_tag>\w+)\]$")
        #       Allow unknown unicast  [No]
        p4_5 = re.compile(r"^Allow\s+unknown\s+unicast\s+\[(?P<allow_unkn_ucast>\w+)\]$")
        #       Allow unknown multicast[No]
        p4_6 = re.compile(r"^Allow\s+unknown\s+multicast\[(?P<allow_unkn_mcast>\w+)\]$")
        #       Allow unknown broadcast[No]
        p4_7 = re.compile(r"^Allow\s+unknown\s+broadcast\[(?P<allow_unkn_bcast>\w+)\]$")
        #       Protected ............ [No]
        p4_8 = re.compile(r"^Protected\s+\.*\s+\[(?P<protected>\w+)\]$")
        #       IPv4 ARP snoop ....... [No]
        p4_9 = re.compile(r"^IPv4\s+ARP\s+snoop\s+\.*\s+\[(?P<ipv4_arp_snp>\w+)\]$")
        #       IPv6 ARP snoop ....... [No]
        p4_10 = re.compile(r"^IPv6\s+ARP\s+snoop\s+\.*\s+\[(?P<ipv6_arp_snp>\w+)\]$")
        #       Jumbo MTU ............ [0]
        p4_11 = re.compile(r"^Jumbo\s+MTU\s+\.*\s+\[(?P<jumbo_mtu>\d+)\]$")
        #       Learning Mode ........ [0]
        p4_12 = re.compile(r"^Learning\s+Mode\s+\.*\s+\[(?P<learning_mode>\d+)\]$")
        #       Vepa ................. [Disabled]
        p4_13 = re.compile(r"^Vepa\s+\.*\s+\[(?P<vepa>\w+)\]$")
        #       App Hosting........... [Disabled]
        p4_14 = re.compile(r"^App\s+Hosting\.*\s+\[(?P<app_hosting>\S+)\]$")

        #       Trust Type .................... [0x7]
        p5 = re.compile(r"^Trust\s+Type\s+\.*\s+\[(?P<trust_type>\S+)\]$")
        #       Default Value ................. [0]
        p5_1 = re.compile(r"^Default\s+Value\s+\.*\s+\[(?P<def_value>\d+)\]$")
        #       Ingress Table Map ............. [0x0]
        p5_2 = re.compile(r"^Ingress\s+Table\s+Map\s+\.*\s+\[(?P<ingrs_tbl_map>\S+)\]$")
        #       Egress Table Map .............. [0x0]
        p5_3 = re.compile(r"^Egress\s+Table\s+Map\s+\.*\s+\[(?P<egrs_tbl_map>\S+)\]$")
        #       Queue Map ..................... [0x0]
        p5_4 = re.compile(r"^Queue\s+Map\s+\.*\s+\[(?P<q_map>\S+)\]$")

        #       Disable SGACL .................... [0x0]
        p6 = re.compile(r"^Disable\s+SGACL\s+\.*\s+\[(?P<disable_sgacl>\S+)\]$")
        #       Trust ............................ [0x0]
        p6_1 = re.compile(r"^Trust\s+\.*\s+\[(?P<trust>\S+)\]$")
        #       Propagate ........................ [0x0]
        p6_2 = re.compile(r"^Propagate\s+\.*\s+\[(?P<propagate>\S+)\]$")
        #       Port SGT ......................... [0xffff]
        p6_3 = re.compile(r"^Port\s+SGT\s+\.*\s+\[(?P<port_sgt>\S+)\]$")


        #   FID : 98 (AAL_FEATURE_L2_MULTICAST_IGMP), Ref Count : 1
        p7 = re.compile(r"^FID\s+:\s+(?P<fid>\S+\s+\S+),\s+Ref\s+Count\s+:\s+(?P<ref_count>\d+)$")

        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()
            # Interface Name          : C320150491
            m = p1.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['name'] = dict_val['name']
                continue

            # Interface IF_ID         : 0x0000000013151bdb
            m = p1_1.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['if_id'] = dict_val['if_id']
                continue

            # Interface Block Pointer : 0x7f16cd385568
            m = p1_2.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['blk_ptr'] = dict_val['blk_ptr']
                continue

            # Interface Block State   : READY
            m = p1_3.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['blk_state'] = dict_val['blk_state']
                continue

            # Interface State         : Enabled
            m = p1_4.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['state'] = dict_val['state']
                continue

            # Interface Status        : ADD, UPD
            m = p1_5.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['status'] = dict_val['status']
                continue

            # Interface Ref-Cnt       : 2
            m = p1_6.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['ref_count'] = int(dict_val['ref_count'])
                continue

            # Interface Type          : WIRED_CLIENT
            m = p1_7.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['type'] = dict_val['type']
                continue

            # Created Time            : 2022/09/29 12:17:16.343
            m = p1_8.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['create_time'] = dict_val['create_time']
                continue

            # Last Modified Time      : 2022/09/29 12:17:16.387
            m = p1_9.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['last_modfd_time'] = dict_val['last_modfd_time']
                continue

            # Current Time            : 2022/09/29 12:29:36.705
            m = p1_10.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['cur_time'] = dict_val['cur_time']
                continue

            #   mac            : 001b.0c18.918d
            m = p1_11.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['mac'] = dict_val['mac']
                continue

            #   parent if_id   : 0x0000000000000020
            m = p1_12.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['parent_if_id'] = dict_val['parent_if_id']
                continue

            #   Client if_id   : 0x0000000013151bdb
            m = p1_13.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['client_if_id'] = dict_val['client_if_id']
                continue

            #   Switch Num     : 1
            m = p1_14.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['switch_num'] = int(dict_val['switch_num'])
                continue

            #   Client type    : 1
            m = p1_15.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['client_type'] = int(dict_val['client_type'])
                continue

            #   ASIC Num       : 1
            m = p1_16.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['asic_num'] = int(dict_val['asic_num'])
                continue

            #   Client LE      : 0x7f16cd0caaa8
            m = p1_17.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['client_le'] = dict_val['client_le']
                continue

            #   DNS punt       : False
            m = p1_18.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['dns_punt'] = dict_val['dns_punt']
                continue

            # Ref Count : 2 (feature Ref Counts + 1)
            m = p1_19.match(line)
            if m:
                dict_val = m.groupdict()
                if 'int_info' not in ret_dict:
                    int_info = ret_dict.setdefault('int_info', {})
                int_info['ref_count_feature'] = dict_val['ref_count_feature']
                continue

            #   Handle ............ [0x8b00013f]
            m = p2.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_info' not in ret_dict:
                    port_info = ret_dict.setdefault('port_info', {})
                port_info['handle'] = dict_val['handle']
                continue

            #   Type .............. [Wired-client]
            m = p2_1.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_info' not in ret_dict:
                    port_info = ret_dict.setdefault('port_info', {})
                port_info['type'] = dict_val['type']
                continue

            #   Identifier ........ [0x13151bdb]
            m = p2_2.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_info' not in ret_dict:
                    port_info = ret_dict.setdefault('port_info', {})
                port_info['identifier'] = dict_val['identifier']
                continue

            #   Unit .............. [320150491]
            m = p2_3.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_info' not in ret_dict:
                    port_info = ret_dict.setdefault('port_info', {})
                port_info['unit'] = dict_val['unit']
                continue

            #       Client LE handle .... [0x7f16cd0caaa8]
            m = p3.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_logical_subblk' not in ret_dict:
                    port_logical_subblk = ret_dict.setdefault('port_logical_subblk', {})
                port_logical_subblk['client_le_handle'] = dict_val['client_le_handle']
                continue

            #       Parent Identifier : 0x20
            m = p3_1.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_logical_subblk' not in ret_dict:
                    port_logical_subblk = ret_dict.setdefault('port_logical_subblk', {})
                port_logical_subblk['parent_identifier'] = dict_val['parent_identifier']
                continue

            #       Asic num          : 0x1
            m = p3_2.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_logical_subblk' not in ret_dict:
                    port_logical_subblk = ret_dict.setdefault('port_logical_subblk', {})
                port_logical_subblk['asic_num'] = dict_val['asic_num']
                continue

            #       Switch num        : 0x1
            m = p3_3.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_logical_subblk' not in ret_dict:
                    port_logical_subblk = ret_dict.setdefault('port_logical_subblk', {})
                port_logical_subblk['switch_num'] = dict_val['switch_num']
                continue

            #       Rewrite type      : 0x0
            m = p3_4.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_logical_subblk' not in ret_dict:
                    port_logical_subblk = ret_dict.setdefault('port_logical_subblk', {})
                port_logical_subblk['rewr_type'] = dict_val['rewr_type']
                continue

            #       Client mac        : 1:0:0:0:0:0
            m = p3_5.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_logical_subblk' not in ret_dict:
                    port_logical_subblk = ret_dict.setdefault('port_logical_subblk', {})
                port_logical_subblk['client_mac'] = dict_val['client_mac']
                continue

            #       RI handle         : 53
            m = p3_6.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_logical_subblk' not in ret_dict:
                    port_logical_subblk = ret_dict.setdefault('port_logical_subblk', {})
                port_logical_subblk['ri_handle'] = int(dict_val['ri_handle'])
                continue

            #       DI handle         : 0
            m = p3_7.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_logical_subblk' not in ret_dict:
                    port_logical_subblk = ret_dict.setdefault('port_logical_subblk', {})
                port_logical_subblk['di_handle'] = int(dict_val['di_handle'])
                continue

            #       Dst Adj  handle   : 0
            m = p3_8.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_logical_subblk' not in ret_dict:
                    port_logical_subblk = ret_dict.setdefault('port_logical_subblk', {})
                port_logical_subblk['dst_adj_handle'] = int(dict_val['dst_adj_handle'])
                continue

            #       Dst Lookup handle : 0
            m = p3_9.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_logical_subblk' not in ret_dict:
                    port_logical_subblk = ret_dict.setdefault('port_logical_subblk', {})
                port_logical_subblk['dst_lkp_handle'] = int(dict_val['dst_lkp_handle'])
                continue

            #       Src Adj  handle   : 0x53
            m = p3_10.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_logical_subblk' not in ret_dict:
                    port_logical_subblk = ret_dict.setdefault('port_logical_subblk', {})
                port_logical_subblk['src_adj_handle'] = dict_val['src_adj_handle']
                continue

            #       Src Lookup handle : 0
            m = p3_11.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_logical_subblk' not in ret_dict:
                    port_logical_subblk = ret_dict.setdefault('port_logical_subblk', {})
                port_logical_subblk['src_lkp_handle'] = int(dict_val['src_lkp_handle'])
                continue

            #       Enabled ............. [No]
            m = p4.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_l2_subblk' not in ret_dict:
                    port_l2_subblk = ret_dict.setdefault('port_l2_subblk', {})
                port_l2_subblk['enabled'] = dict_val['enabled']
                continue

            #       Allow dot1q ......... [No]
            m = p4_1.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_l2_subblk' not in ret_dict:
                    port_l2_subblk = ret_dict.setdefault('port_l2_subblk', {})
                port_l2_subblk['allow_dot1q'] = dict_val['allow_dot1q']
                continue

            #       Allow native ........ [No]
            m = p4_2.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_l2_subblk' not in ret_dict:
                    port_l2_subblk = ret_dict.setdefault('port_l2_subblk', {})
                port_l2_subblk['allow_native'] = dict_val['allow_native']
                continue

            #       Default VLAN ........ [0]
            m = p4_3.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_l2_subblk' not in ret_dict:
                    port_l2_subblk = ret_dict.setdefault('port_l2_subblk', {})
                port_l2_subblk['def_vlan'] = int(dict_val['def_vlan'])
                continue

            #       Allow priority tag ... [No]
            m = p4_4.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_l2_subblk' not in ret_dict:
                    port_l2_subblk = ret_dict.setdefault('port_l2_subblk', {})
                port_l2_subblk['allow_priority_tag'] = dict_val['allow_priority_tag']
                continue

            #       Allow unknown unicast  [No]
            m = p4_5.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_l2_subblk' not in ret_dict:
                    port_l2_subblk = ret_dict.setdefault('port_l2_subblk', {})
                port_l2_subblk['allow_unkn_ucast'] = dict_val['allow_unkn_ucast']
                continue

            #       Allow unknown multicast[No]
            m = p4_6.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_l2_subblk' not in ret_dict:
                    port_l2_subblk = ret_dict.setdefault('port_l2_subblk', {})
                port_l2_subblk['allow_unkn_mcast'] = dict_val['allow_unkn_mcast']
                continue

            #       Allow unknown broadcast[No]
            m = p4_7.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_l2_subblk' not in ret_dict:
                    port_l2_subblk = ret_dict.setdefault('port_l2_subblk', {})
                port_l2_subblk['allow_unkn_bcast'] = dict_val['allow_unkn_bcast']
                continue

            #       Protected ............ [No]
            m = p4_8.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_l2_subblk' not in ret_dict:
                    port_l2_subblk = ret_dict.setdefault('port_l2_subblk', {})
                port_l2_subblk['protected'] = dict_val['protected']
                continue

            #       IPv4 ARP snoop ....... [No]
            m = p4_9.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_l2_subblk' not in ret_dict:
                    port_l2_subblk = ret_dict.setdefault('port_l2_subblk', {})
                port_l2_subblk['ipv4_arp_snp'] = dict_val['ipv4_arp_snp']
                continue

            #       IPv6 ARP snoop ....... [No]
            m = p4_10.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_l2_subblk' not in ret_dict:
                    port_l2_subblk = ret_dict.setdefault('port_l2_subblk', {})
                port_l2_subblk['ipv6_arp_snp'] = dict_val['ipv6_arp_snp']
                continue

            #       Jumbo MTU ............ [0]
            m = p4_11.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_l2_subblk' not in ret_dict:
                    port_l2_subblk = ret_dict.setdefault('port_l2_subblk', {})
                port_l2_subblk['jumbo_mtu'] = int(dict_val['jumbo_mtu'])
                continue

            #       Learning Mode ........ [0]
            m = p4_12.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_l2_subblk' not in ret_dict:
                    port_l2_subblk = ret_dict.setdefault('port_l2_subblk', {})
                port_l2_subblk['learning_mode'] = int(dict_val['learning_mode'])
                continue

            #       Vepa ................. [Disabled]
            m = p4_13.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_l2_subblk' not in ret_dict:
                    port_l2_subblk = ret_dict.setdefault('port_l2_subblk', {})
                port_l2_subblk['vepa'] = dict_val['vepa']
                continue

            #       App Hosting........... [Disabled]
            m = p4_14.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_l2_subblk' not in ret_dict:
                    port_l2_subblk = ret_dict.setdefault('port_l2_subblk', {})
                port_l2_subblk['app_hosting'] = dict_val['app_hosting']
                continue

            #       Trust Type .................... [0x7]
            m = p5.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_qos_subblk' not in ret_dict:
                    port_qos_subblk = ret_dict.setdefault('port_qos_subblk', {})
                port_qos_subblk['trust_type'] = dict_val['trust_type']
                continue

            #       Default Value ................. [0]
            m = p5_1.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_qos_subblk' not in ret_dict:
                    port_qos_subblk = ret_dict.setdefault('port_qos_subblk', {})
                port_qos_subblk['def_value'] = int(dict_val['def_value'])
                continue

            #       Ingress Table Map ............. [0x0]
            m = p5_2.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_qos_subblk' not in ret_dict:
                    port_qos_subblk = ret_dict.setdefault('port_qos_subblk', {})
                port_qos_subblk['ingrs_tbl_map'] = dict_val['ingrs_tbl_map']
                continue

            #       Egress Table Map .............. [0x0]
            m = p5_3.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_qos_subblk' not in ret_dict:
                    port_qos_subblk = ret_dict.setdefault('port_qos_subblk', {})
                port_qos_subblk['egrs_tbl_map'] = dict_val['egrs_tbl_map']
                continue

            #       Queue Map ..................... [0x0]
            m = p5_4.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_qos_subblk' not in ret_dict:
                    port_qos_subblk = ret_dict.setdefault('port_qos_subblk', {})
                port_qos_subblk['q_map'] = dict_val['q_map']
                continue

            #       Disable SGACL .................... [0x0]
            m = p6.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_cts_subblk' not in ret_dict:
                    port_cts_subblk = ret_dict.setdefault('port_cts_subblk', {})
                port_cts_subblk['disable_sgacl'] = dict_val['disable_sgacl']
                continue

            #       Trust ............................ [0x0]
            m = p6_1.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_cts_subblk' not in ret_dict:
                    port_cts_subblk = ret_dict.setdefault('port_cts_subblk', {})
                port_cts_subblk['trust'] = dict_val['trust']
                continue

            #       Propagate ........................ [0x0]
            m = p6_2.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_cts_subblk' not in ret_dict:
                    port_cts_subblk = ret_dict.setdefault('port_cts_subblk', {})
                port_cts_subblk['propagate'] = dict_val['propagate']
                continue

            #       Port SGT ......................... [0xffff]
            m = p6_3.match(line)
            if m:
                dict_val = m.groupdict()
                if 'port_cts_subblk' not in ret_dict:
                    port_cts_subblk = ret_dict.setdefault('port_cts_subblk', {})
                port_cts_subblk['port_sgt'] = dict_val['port_sgt']
                continue

            #   FID : 98 (AAL_FEATURE_L2_MULTICAST_IGMP), Ref Count : 1
            m = p7.match(line)
            if m:
                dict_val = m.groupdict()
                if 'ifm_feature_ref_counts' not in ret_dict:
                    ifm_feature_ref_counts = ret_dict.setdefault('ifm_feature_ref_counts', {})
                ifm_feature_ref_counts['fid'] = dict_val['fid']
                ifm_feature_ref_counts['ref_count'] = int(dict_val['ref_count'])
                continue

        return ret_dict



# ======================================================
# Schema for 'show platform pm port-data <int> '
# ======================================================

class ShowPlatformPmPortDataIntSchema(MetaParser):
    """Schema for show platform pm port-data <int>"""

    schema = {
        Optional('pm_port_data'): {
            Any(): {
                Optional('field'): str,
                Optional('admin_field'): str,
                Optional('oper_field'): str,
            },

        },
        Optional('pm_port_info'): {
            Optional('forwarding_vlans'): int,
            Optional('current_pruned_vlans'): str,
            Optional('previous_pruned_vlans'): str,
            Optional('sw_linkneg_state'): str,
            Optional('no_link_down_events'): int,
            Optional('time_stamp_last_link_flapped'): str,
            Optional('last_link_down_duration_secs'): int,
            Optional('last_link_up_duration_secs'): int,
        },
    }

# ======================================================
# Parser for 'show platform pm port-data <int> '
# ======================================================
class ShowPlatformPmPortDataInt(ShowPlatformPmPortDataIntSchema):
    """Parser for show platform pm port-data <int>"""

    cli_command = 'show platform pm port-data {interface}'

    def cli(self, interface=None, output=None):
        if output is None:
            cmd = self.cli_command.format(interface=interface)
            output = self.device.execute(cmd)

        #   Access Mode               Multi-Static         Multi-Static
        p1 = re.compile(r"^\s+(?P<field>(\w+|\w+\s+\w+|\w+\s+\w+\s+\w+)?)\s+(?P<admin_field>(\S+|\s+)?)\s+(?P<oper_field>(\S+|s+)?)$")

        #   Forwarding Vlans : 100
        p2 = re.compile(r"^\s+Forwarding\s+Vlans\s+:\s+(?P<forwarding_vlans>\d+)$")
        #   Current Pruned Vlans : none
        p2_1 = re.compile(r"^\s+Current\s+Pruned\s+Vlans\s+:\s+(?P<current_pruned_vlans>\w+)$")
        #   Previous Pruned Vlans : none
        p2_2 = re.compile(r"^\s+Previous\s+Pruned\s+Vlans\s+:\s+(?P<previous_pruned_vlans>\w+)$")
        #   Sw LinkNeg State : LinkStateUp
        p2_3 = re.compile(r"^\s+Sw\s+LinkNeg\s+State\s+:\s+(?P<sw_linkneg_state>\w+)$")
        #   No.of LinkDownEvents :    3
        p2_4 = re.compile(r"^\s+No\.of\s+LinkDownEvents\s+:\s+(?P<no_link_down_events>\d+)\s+$")
        #   Time Stamp Last Link Flapped(U) : Sep 13 20:14:35.714
        p2_5 = re.compile(r"^\s+Time\s+Stamp\s+Last\s+Link\s+Flapped\(U\)\s+:\s+(?P<time_stamp_last_link_flapped>\S+\s+\S+\s+\S+)$")
        #   LastLinkDownDuration(sec) 2
        p2_6 = re.compile(r"^\s+LastLinkDownDuration\(sec\)\s+(?P<last_link_down_duration_secs>\d+)\s+$")
        #   LastLinkUpDuration(sec):  1355054
        p2_7 = re.compile(r"^\s+LastLinkUpDuration\(sec\):\s+(?P<last_link_up_duration_secs>\d+)\s+$")

        ret_dict = {}

        for line in output.splitlines():

            #   Access Mode               Multi-Static         Multi-Static
            m = p1.match(line)
            if m:
                dict_val = m.groupdict()
                field_var = dict_val['field']
                if 'pm_port_data' not in ret_dict:
                    pm_port_data = ret_dict.setdefault('pm_port_data', {})
                if field_var not in ret_dict['pm_port_data']:
                    field_dict = ret_dict['pm_port_data'].setdefault(field_var, {})
                field_dict['field'] = dict_val['field']
                field_dict['admin_field'] = dict_val['admin_field']
                field_dict['oper_field'] = dict_val['oper_field']
                continue


            #   Forwarding Vlans : 100
            m = p2.match(line)
            if m:
                dict_val = m.groupdict()
                if 'pm_port_info' not in ret_dict:
                    pm_port_info = ret_dict.setdefault('pm_port_info', {})
                pm_port_info['forwarding_vlans'] = int(dict_val['forwarding_vlans'])
                continue

            #   Current Pruned Vlans : none
            m = p2_1.match(line)
            if m:
                dict_val = m.groupdict()
                if 'pm_port_info' not in ret_dict:
                    pm_port_info = ret_dict.setdefault('pm_port_info', {})
                pm_port_info['current_pruned_vlans'] = dict_val['current_pruned_vlans']
                continue

            #   Previous Pruned Vlans : none
            m = p2_2.match(line)
            if m:
                dict_val = m.groupdict()
                if 'pm_port_info' not in ret_dict:
                    pm_port_info = ret_dict.setdefault('pm_port_info', {})
                pm_port_info['previous_pruned_vlans'] = dict_val['previous_pruned_vlans']
                continue

            #   Sw LinkNeg State : LinkStateUp
            m = p2_3.match(line)
            if m:
                dict_val = m.groupdict()
                if 'pm_port_info' not in ret_dict:
                    pm_port_info = ret_dict.setdefault('pm_port_info', {})
                pm_port_info['sw_linkneg_state'] = dict_val['sw_linkneg_state']
                continue

            #   No.of LinkDownEvents :    3
            m = p2_4.match(line)
            if m:
                dict_val = m.groupdict()
                if 'pm_port_info' not in ret_dict:
                    pm_port_info = ret_dict.setdefault('pm_port_info', {})
                pm_port_info['no_link_down_events'] = int(dict_val['no_link_down_events'])
                continue

            #   Time Stamp Last Link Flapped(U) : Sep 13 20:14:35.714
            m = p2_5.match(line)
            if m:
                dict_val = m.groupdict()
                if 'pm_port_info' not in ret_dict:
                    pm_port_info = ret_dict.setdefault('pm_port_info', {})
                pm_port_info['time_stamp_last_link_flapped'] = dict_val['time_stamp_last_link_flapped']
                continue                
            
            #   LastLinkDownDuration(sec) 2

            m = p2_6.match(line)
            if m:
                dict_val = m.groupdict()
                if 'pm_port_info' not in ret_dict:
                    pm_port_info = ret_dict.setdefault('pm_port_info', {})
                pm_port_info['last_link_down_duration_secs'] = int(dict_val['last_link_down_duration_secs'])
                continue

            #   LastLinkUpDuration(sec):  1355054
            m = p2_7.match(line)
            if m:
                dict_val = m.groupdict()
                if 'pm_port_info' not in ret_dict:
                    pm_port_info = ret_dict.setdefault('pm_port_info', {})
                pm_port_info['last_link_up_duration_secs'] = int(dict_val['last_link_up_duration_secs'])
                continue


        return ret_dict


class ShowPlatformRewriteUtilizationSchema(MetaParser):
    """Schema for show platform hardware fed active fwd-asic resource rewrite utilization """
    schema = {
        'asic': {
            Any(): {
                'rewritedata': {
                    Any(): {
                        'allocated': int,
                        'free': int,
                          }
                   }
            }
        }
    }


class ShowPlatformRewriteUtilization(ShowPlatformRewriteUtilizationSchema):
    """Parser for show platform hardware fed sw active fwd-asic resource rewrite utilization """

    cli_command = ['show platform hardware fed {switch} active fwd-asic resource rewrite utilization','show platform hardware fed active fwd-asic resource rewrite utilization']

    def cli(self, output=None, switch=''):
        if output is None:
            if switch:
                cmd = self.cli_command[0].format(switch=switch)
            else:
                cmd = self.cli_command[1]
            output = self.device.execute(cmd)

        # initial return dictionary
        ret_dict = {}
        # initial regexp pattern
        # Resource Info for ASIC Instance: 0
        p1 = re.compile(r'Resource +Info +for +ASIC +Instance: +(?P<asic>(\d+))$')

        #Rewrite Data                        Allocated     Free
        #-------------------------------------------------------
        #PHF_EGRESS_destMacAddress             75001       23303
        #UDP_ENCAP_SRC_PORT                        0         256
        p2 = re.compile(r'(?P<rewritedata>\S+) +(?P<allocated>\S+) +(?P<free>\S+)$')
        for line in output.splitlines():
            line = line.strip()

            # Resource Info for ASIC Instance: 0
            m = p1.match(line)
            if m:
                group = m.groupdict()
                asic = group['asic']
                asic_dict = ret_dict.setdefault('asic', {}).setdefault(asic, {})
                continue

            #PHF_EGRESS_destMacAddress             75001       23303
            #UDP_ENCAP_SRC_PORT                        0         256

            m = p2.match(line)
            if m:
                groups = m.groupdict()
                rewritedata = (groups['rewritedata'])
                allocated = int(groups['allocated'])
                free = int(groups['free'])
                rewrite_table_dict = asic_dict.setdefault('rewritedata', {}).setdefault(rewritedata, {})

                rewrite_table_dict.update({
                    'allocated': allocated,
                    'free': free,
                })
                continue
        return ret_dict

class ShowPlatformMatmMacTableSchema(MetaParser):
    """Schema for show platform hardware fed switch active matm macTable"""
    schema = {
        'mac_address': {
            Any(): {
                'head': {
                    'vlan': int
                },
                'key': {
                    'vlan': int,
                    'mac': str,
                    'l3_if': int,
                    'gpn': int,
                    'epoch': int,
                    'static': int,
                    'flood_en': int,
                    'vlan_lead_wless_flood_en': int,
                    'client_home_asic': int,
                    'learning_peerid': int,
                    'learning_peerid_valid': int
                },
                'mask': {
                    'vlan': int,
                    'mac': str,
                    'l3_if': int,
                    'gpn': int,
                    'epoch': int,
                    'static': int,
                    'flood_en': int,
                    'vlan_lead_wless_flood_en': int,
                    'client_home_asic': int,
                    'learning_peerid': int,
                    'learning_peerid_valid': int
                },
                'src_ad': {
                    'need_to_learn': int,
                    'lrn_v': int,
                    'catchall': int,
                    'static_mac': int,
                    'chain_ptr_v': int,
                    'chain_ptr': int,
                    'static_entry_v': int,
                    'auth_state': int,
                    'auth_mode': int,
                    'traf_mode': int,
                    'is_src_ce': int
                },
                'dst_ad': {
                    'si': str,
                    'bridge': int,
                    'replicate': int,
                    'blk_fwd_o': int,
                    'v4_mac': int,
                    'v6_mac': int,
                    'catchall': int,
                    'ign_src_lrn': int,
                    'port_mask_o': int,
                    'afd_cli_f': int,
                    'afd_lbl': int,
                    'priority': int,
                    'dest_mod_idx':int,
                    'destined_to_us': int,
                    'pv_trunk': int
                }
            }
        },
        'total_mac_address': int
    }


class ShowPlatformMatmMacTable(ShowPlatformMatmMacTableSchema):
    """Parser for show platform hardware fed switch active matm macTable"""

    cli_command = 'show platform hardware fed switch active matm macTable'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        # HEAD: MAC address 0012.7fae.9662 in VLAN 1
        p1 = re.compile(r'^HEAD:\s+MAC\s+address\s+(?P<mac_address>[\d\.a-f]+)\s+in\s+VLAN\s+(?P<vlan>\d+)$')

        # KEY: vlan 4, mac 0x127fae9662, l3_if 0, gpn 24, epoch 0, static 0, flood_en 0, vlan_lead_wless_flood_en 0,
        # client_home_asic 0, learning_peerid 0, learning_peerid_valid 0
        p2 = re.compile(r'^(?P<key_mask>(KEY|MASK)):\s+vlan\s+(?P<vlan>\d+),\s+mac\s+(?P<mac>\S+),\s+l3_if\s+(?P<l3_if>\d+),\s+gpn\s+(?P<gpn>\d+),'
        r'\s+epoch\s+(?P<epoch>\d+),\s+static\s+(?P<static>\d+),\s+flood_en\s+(?P<flood_en>\d+),\s+vlan_lead_wless_flood_en'
        r'\s+(?P<vlan_lead_wless_flood_en>\d+),\s+client_home_asic\s+(?P<client_home_asic>\d+),*\s+learning_peerid\s+(?P<learning_peerid>\d+),'
        r'\s+learning_peerid_valid\s+(?P<learning_peerid_valid>\d+)$')

        # SRC_AD: need_to_learn 0, lrn_v 0, catchall 0, static_mac 0, chain_ptr_v 0, chain_ptr 0, static_entry_v 0,
        # auth_state 0, auth_mode 0, traf_mode 0, is_src_ce 0
        p3 = re.compile(r'^SRC_AD:\s+need_to_learn\s+(?P<need_to_learn>\d+),\s+lrn_v\s+(?P<lrn_v>\d+),\s+catchall\s+(?P<catchall>\d+),'
        r'\s+static_mac\s+(?P<static_mac>\d+),\s+chain_ptr_v\s+(?P<chain_ptr_v>\d+),\s+chain_ptr\s+(?P<chain_ptr>\d+),\s+static_entry_v'
        r'\s+(?P<static_entry_v>\d+),\s+auth_state\s+(?P<auth_state>\d+),\s+auth_mode\s+(?P<auth_mode>\d+),\s+traf_mode\s+(?P<traf_mode>\d+),'
        r'\s+is_src_ce\s+(?P<is_src_ce>\d+)$')

        # DST_AD: si 0xb1, bridge 0, replicate 0, blk_fwd_o 0, v4_mac 0, v6_mac 0, catchall 0, ign_src_lrn 0, port_mask_o 0,
        # afd_cli_f 0, afd_lbl 0, priority 3, dest_mod_idx 0, destined_to_us 0, pv_trunk 0
        p4 = re.compile(r'^DST_AD:\s+si\s+(?P<si>\S+),\s+bridge\s+(?P<bridge>\d+),\s+replicate\s+(?P<replicate>\d+),\s+blk_fwd_o\s+(?P<blk_fwd_o>\d+),'
        r'\s+v4_mac\s+(?P<v4_mac>\d+),\s+v6_mac\s+(?P<v6_mac>\d+),\s+catchall\s+(?P<catchall>\d+),\s+ign_src_lrn\s+(?P<ign_src_lrn>\d+),\s+port_mask_o'
        r'\s+(?P<port_mask_o>\d+),\s+afd_cli_f\s+(?P<afd_cli_f>\d+),\s+afd_lbl\s+(?P<afd_lbl>\d+),\s+priority\s+(?P<priority>\d+),\s+'
        r'dest_mod_idx\s+(?P<dest_mod_idx>\d+),\s+destined_to_us\s+(?P<destined_to_us>\d+),\s+pv_trunk\s+(?P<pv_trunk>\d+)$')

        # Total Mac number of addresses:: 6
        p5 = re.compile(r'^Total\s+Mac\s+number\s+of\s+addresses::\s+(?P<total_mac_address>\d+)$')

        ret_dict = dict()

        for line in output.splitlines():
            line = line.strip()

            # HEAD: MAC address 0012.7fae.9662 in VLAN 1
            m = p1.match(line)
            if m:
                mac_dict = ret_dict.setdefault('mac_address', {}).setdefault(m.groupdict()['mac_address'], {})
                mac_dict.setdefault('head', {}).setdefault('vlan', int(m.groupdict()['vlan']))
                continue

            # KEY: vlan 4, mac 0x127fae9662, l3_if 0, gpn 24, epoch 0, static 0, flood_en 0, vlan_lead_wless_flood_en 0,
            # client_home_asic 0, learning_peerid 0, learning_peerid_valid 0
            m = p2.match(line)
            if m:
                grp_dict = m.groupdict()
                tmp_dict = mac_dict.setdefault('key' if grp_dict['key_mask'] == 'KEY' else 'mask', {})
                tmp_dict['vlan'] = int(grp_dict['vlan'])
                tmp_dict['mac'] = grp_dict['mac']
                tmp_dict['l3_if'] = int(grp_dict['l3_if'])
                tmp_dict['gpn'] = int(grp_dict['gpn'])
                tmp_dict['epoch'] = int(grp_dict['epoch'])
                tmp_dict['static'] = int(grp_dict['static'])
                tmp_dict['flood_en'] = int(grp_dict['flood_en'])
                tmp_dict['vlan_lead_wless_flood_en'] = int(grp_dict['vlan_lead_wless_flood_en'])
                tmp_dict['client_home_asic'] = int(grp_dict['client_home_asic'])
                tmp_dict['learning_peerid'] = int(grp_dict['learning_peerid'])
                tmp_dict['learning_peerid_valid'] = int(grp_dict['learning_peerid_valid'])
                continue

            # SRC_AD: need_to_learn 0, lrn_v 0, catchall 0, static_mac 0, chain_ptr_v 0, chain_ptr 0, static_entry_v 0,
            # auth_state 0, auth_mode 0, traf_mode 0, is_src_ce 0
            m = p3.match(line)
            if m:
                grp_dict = m.groupdict()
                src_dict = mac_dict.setdefault('src_ad', {})
                src_dict['need_to_learn'] = int(grp_dict['need_to_learn'])
                src_dict['lrn_v'] = int(grp_dict['lrn_v'])
                src_dict['catchall'] = int(grp_dict['catchall'])
                src_dict['static_mac'] = int(grp_dict['static_mac'])
                src_dict['chain_ptr_v'] = int(grp_dict['chain_ptr_v'])
                src_dict['chain_ptr'] = int(grp_dict['chain_ptr'])
                src_dict['static_entry_v'] = int(grp_dict['static_entry_v'])
                src_dict['auth_state'] = int(grp_dict['auth_state'])
                src_dict['auth_mode'] = int(grp_dict['auth_mode'])
                src_dict['traf_mode'] = int(grp_dict['traf_mode'])
                src_dict['is_src_ce'] = int(grp_dict['is_src_ce'])
                continue

            # DST_AD: si 0xb1, bridge 0, replicate 0, blk_fwd_o 0, v4_mac 0, v6_mac 0, catchall 0, ign_src_lrn 0, port_mask_o 0,
            # afd_cli_f 0, afd_lbl 0, priority 3, dest_mod_idx 0, destined_to_us 0, pv_trunk 0
            m = p4.match(line)
            if m:
                grp_dict = m.groupdict()
                dst_dict = mac_dict.setdefault('dst_ad', {})
                dst_dict['si'] = grp_dict['si']
                dst_dict['bridge'] = int(grp_dict['bridge'])
                dst_dict['replicate'] = int(grp_dict['replicate'])
                dst_dict['blk_fwd_o'] = int(grp_dict['blk_fwd_o'])
                dst_dict['v4_mac'] = int(grp_dict['v4_mac'])
                dst_dict['v6_mac'] = int(grp_dict['v6_mac'])
                dst_dict['catchall'] = int(grp_dict['catchall'])
                dst_dict['ign_src_lrn'] = int(grp_dict['ign_src_lrn'])
                dst_dict['port_mask_o'] = int(grp_dict['port_mask_o'])
                dst_dict['afd_cli_f'] = int(grp_dict['afd_cli_f'])
                dst_dict['afd_lbl'] = int(grp_dict['afd_lbl'])
                dst_dict['priority'] = int(grp_dict['priority'])
                dst_dict['dest_mod_idx'] = int(grp_dict['dest_mod_idx'])
                dst_dict['destined_to_us'] = int(grp_dict['destined_to_us'])
                dst_dict['pv_trunk'] = int(grp_dict['pv_trunk'])
                continue

            # Total Mac number of addresses:: 6
            m = p5.match(line)
            if m:
                ret_dict['total_mac_address'] = int(m.groupdict()['total_mac_address'])
                continue

        return ret_dict

# ======================================================
# Parser for 'show platform software monitor session {session}'
# ======================================================

class ShowPlatformSoftwareMonitorSessionSchema(MetaParser):
    """Schema for show platform software monitor session {session}"""

    schema = {
        'span_session': str,
        'fed_session': str,
        'type': str,
        'prev_type': str,
        Optional('ingress_source_ports'): str,
        Optional('egress_source_ports'): str,
        Optional('ingress_local_source_ports'): str,
        Optional('egress_local_source_ports'): str,
        Optional('destination_ports'): list,
        Optional('ingress_source_vlans'): str,
        Optional('egress_source_vlans'): str,
        Optional('ingress_up_source_vlans'): str,
        Optional('egress_up_source_vlans'): str,
        Optional('source_trunk_filter_vlans'): str,
        'rspan': {
            'destination_vlan': int,
            'source_vlan': int,
            'source_vlan_sav': int
        },
        'destination_port_encap': str,
        'destination_port_ingress_encap': str,
        'destination_port_ingress_vlan': str,
        'source_session': str,
        'destination_session': str,
        'destination_port_cfgd': str,
        'rspn_destination_cfg': str,
        'rspn_source_vld': str,
        'dstination_cli_cfg': str,
        'dstination_prt_init': str,
        'pslclcfgd': str,
        'flags': list,
        'remote_destination_port': str,
        'destination_port_group': str,
        Optional('erspan'): {
            'id': str,
            Optional('org_ip'): str,
            Optional('destination_ip'): str,
            Optional('org_ipv6'): str,
            Optional('destination_ipv6'): str,
            Optional('ip_ttl'): int,
            Optional('dscp'): int,
            Optional('ipv6_flow_label'): int,
            Optional('vrfid'): int,
            Optional('state'): str,
            Optional('tun_id'): int
        }
    }

class ShowPlatformSoftwareMonitorSession(ShowPlatformSoftwareMonitorSessionSchema):
    """Parser for show platform software monitor session {session}"""

    cli_command = 'show platform software monitor session {session}'

    def cli(self,session="", output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(session=session))

        # Span Session 3 (FED Session 2):
        p1 = re.compile(r"^Span\s+Session\s+(?P<span_session>\d+)\s+\(FED\s+Session\s+(?P<fed_session>\w+)\):$")

        # Type:      ERSPAN Source
        p2 = re.compile(r"^Type:\s+(?P<type>.+)$")

        # Prev type: Unknown
        p3 = re.compile(r"^Prev\s+type:\s+(?P<prev_type>[\w\s]+)$")

        # Ingress Src Ports: Fif2/0/2
        p4 = re.compile(r"^Ingress\s+Src\s+Ports:\s+(?P<ingress_source_ports>\S+)$")

        # Egress Src Ports: Fif2/0/4
        p5 = re.compile(r"^Egress\s+Src\s+Ports:\s+(?P<egress_source_ports>\S+)$")

        # Ingress Local Src Ports: (null)
        p6 = re.compile(r"^Ingress\s+Local\s+Src\s+Ports:\s+\((?P<ingress_local_source_ports>(?!null)\S+)\)$")

        # Egress Local Src Ports: (null)
        p7 = re.compile(r"^Egress\s+Local\s+Src\s+Ports:\s+\((?P<egress_local_source_ports>(?!null)\S+)\)$")

        # Destination Ports: Fif2/0/10 2/0/5
        p8 = re.compile(r"^Destination\s+Ports:\s+(?P<destination_ports>.+)$")

        # Ingress Src Vlans: 3
        p9 = re.compile(r"^Ingress\s+Src\s+Vlans:\s+(?P<ingress_source_vlans>\d+)$")

        # Egress Src Vlans: 3
        p10 = re.compile(r"^Egress\s+Src\s+Vlans:\s+(?P<egress_source_vlans>\d+)$")

        # Ingress Up Src Vlans: (null)
        p11 = re.compile(r"^Ingress\s+Up\s+Src\s+Vlans:\s+\((?P<ingress_up_source_vlans>(?!null)\S+)\)$")

        # Egress Up Src Vlans:  (null)
        p12 = re.compile(r"^Egress\s+Up\s+Src\s+Vlans:\s+\((?P<egress_up_source_vlans>(?!null)\S+)\)$")

        # Src Trunk filter Vlans: 3
        p13 = re.compile(r"^Src\s+Trunk\s+filter\s+Vlans:\s+(?P<source_trunk_filter_vlans>\d+)$")

        # RSPAN dst vlan: 0
        p14 = re.compile(r"^RSPAN\s+dst\s+vlan:\s+(?P<destination_vlan>\d+)$")

        # RSPAN src vlan: 0
        p15 = re.compile(r"^RSPAN\s+src\s+vlan:\s+(?P<source_vlan>\d+)$")

        # RSPAN src vlan sav: 0
        p16 = re.compile(r"^RSPAN\s+src\s+vlan\s+sav:\s+(?P<source_vlan_sav>\d+)$")

        # Dest port encap = 0x0000
        p17 = re.compile(r"^Dest\s+port\s+encap\s+=\s+(?P<destination_port_encap>\S+)$")

        # Dest port ingress encap = 0x0000
        p18 = re.compile(r"^Dest\s+port\s+ingress\s+encap\s+=\s+(?P<destination_port_ingress_encap>\S+)$")

        # Dest port ingress vlan = 0x0
        p19 = re.compile(r"^Dest\s+port\s+ingress\s+vlan\s+=\s+(?P<destination_port_ingress_vlan>\S+)$")

        # SrcSess: 1  DstSess: 0 DstPortCfgd: 0  RspnDstCfg: 0  RspnSrcVld: 0
        p20 = re.compile(r"^SrcSess:\s+(?P<source_session>\d+)\s+DstSess:\s+(?P<destination_session>\d+)\s+DstPortCfgd:\s+(?P<destination_port_cfgd>\d+)\s+RspnDstCfg:\s+(?P<rspn_destination_cfg>\d+)\s+RspnSrcVld:\s+(?P<rspn_source_vld>\d+)$")

        # DstCliCfg: 0  DstPrtInit: 0  PsLclCfgd: 0
        p21 = re.compile(r"^DstCliCfg:\s+(?P<dstination_cli_cfg>\d+)\s+DstPrtInit:\s+(?P<dstination_prt_init>\d+)\s+PsLclCfgd:\s+(?P<pslclcfgd>\d+)$")

        # Flags: 0x00000002 VSPAN
        p22 = re.compile(r"^Flags:\s+(?P<flags>.+)$")

        # Remote dest port: 0   Dest port group: 0
        p23 = re.compile(r"^Remote dest port:\s(?P<remote_destination_port>\w+)\s+Dest port group:\s(?P<destination_port_group>\w+)$")

        # ERSPAN Id    : 11
        p24 = re.compile(r"^ERSPAN\sId\s+:\s+(?P<id>\d+)$")

        # ERSPAN Org Ip: 0.0.0.0
        p25 = re.compile(r"^ERSPAN\s+Org\s+Ip:\s+(?P<org_ip>[\d.]+)$")

        # ERSPAN Dst Ip: 0.0.0.0
        p26 = re.compile(r"^ERSPAN\s+Dst\s+Ip:\s+(?P<destination_ip>[\d.]+)$")

        #  ERSPAN Org Ipv6: 2002::1
        p27 = re.compile(r"^ERSPAN\s+Org\s+Ipv6:\s+(?P<org_ipv6>[\d:]+)$")

        # ERSPAN Dst Ipv6: 2001::1
        p28 = re.compile(r"^ERSPAN\s+Dst\s+Ipv6:\s+(?P<destination_ipv6>[\d:]+)$")

        # ERSPAN Ip Ttl: 255
        p29 = re.compile(r"^ERSPAN\s+Ip\s+Ttl:\s+(?P<ip_ttl>\d+)$")

        # ERSPAN DSCP  : 0
        p30 = re.compile(r"^ERSPAN DSCP\s+:\s+(?P<dscp>\d+)$")

        # ERSPAN Ipv6 flow label: 0
        p31 = re.compile(r"^ERSPAN Ipv6 flow label:\s+(?P<ipv6_flow_label>\d+)$")

        # ERSPAN VRFID   : 0
        p32 = re.compile(r"^ERSPAN VRFID\s+:\s+(?P<vrfid>\d+)$")

        # ERSPAN State : Enabled
        p33 = re.compile(r"^ERSPAN State :\s+(?P<state>\w+)$")

        # ERSPAN Tun id: 1251
        p34 = re.compile(r"^ERSPAN Tun id:\s+(?P<tun_id>\d+)$")

        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()

            # Span Session 3 (FED Session 2):
            m = p1.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # Type:      ERSPAN Source
            m = p2.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # Prev type: Unknown
            m = p3.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # Ingress Src Ports: Fif2/0/2
            m = p4.match(line)
            if m:
                ret_dict['ingress_source_ports'] = Common.convert_intf_name(m.groupdict()['ingress_source_ports'])
                continue

            # Egress Src Ports: Fif2/0/4
            m = p5.match(line)
            if m:
                ret_dict['egress_source_ports'] = Common.convert_intf_name(m.groupdict()['egress_source_ports'])
                continue

            # Ingress Local Src Ports: (null)
            m = p6.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # Egress Local Src Ports: (null)
            m = p7.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # Destination Ports: Fif2/0/10 2/0/5
            m = p8.match(line)
            if m:
                dst_ports = [Common.convert_intf_name(port) for port in m.groupdict()['destination_ports'].split()]
                ret_dict['destination_ports'] = dst_ports
                continue

            # Ingress Src Vlans: 3
            m = p9.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # Egress Src Vlans: 3
            m = p10.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # Ingress Up Src Vlans: 3
            m = p11.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # Egress Up Src Vlans:  (null)
            m = p12.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # Src Trunk filter Vlans: 3
            m = p13.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # RSPAN dst vlan: 0
            m = p14.match(line)
            if m:
                rspan_dict = ret_dict.setdefault('rspan', {})
                rspan_dict.setdefault('destination_vlan', int(m.groupdict()['destination_vlan']))
                continue

            # RSPAN src vlan: 0
            m = p15.match(line)
            if m:
                rspan_dict.setdefault('source_vlan', int(m.groupdict()['source_vlan']))
                continue

            # RSPAN src vlan sav: 0
            m = p16.match(line)
            if m:
                rspan_dict.setdefault('source_vlan_sav', int(m.groupdict()['source_vlan_sav']))
                continue

            # Dest port encap = 0x0000
            m = p17.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # Dest port ingress encap = 0x0000
            m = p18.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # Dest port ingress vlan = 0x0
            m = p19.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # SrcSess: 1  DstSess: 0 DstPortCfgd: 0  RspnDstCfg: 0  RspnSrcVld: 0
            m = p20.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # DstCliCfg: 0  DstPrtInit: 0  PsLclCfgd: 0
            m = p21.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # Flags: 0x00000002 VSPAN
            m = p22.match(line)
            if m:
                ret_dict['flags'] = m.groupdict()['flags'].split(' ')
                continue

            # Remote dest port: 0   Dest port group: 0
            m = p23.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

            # ERSPAN Id    : 11
            m = p24.match(line)
            if m:
                erspan_dict = ret_dict.setdefault('erspan', {})
                erspan_dict.setdefault('id', m.groupdict()['id'])
                continue

            # ERSPAN Org Ip: 0.0.0.0
            m = p25.match(line)
            if m:
                erspan_dict.update(m.groupdict())
                continue

            # ERSPAN Dst Ip: 0.0.0.0
            m = p26.match(line)
            if m:
                erspan_dict.update(m.groupdict())
                continue

            # ERSPAN Org Ipv6: 2002::1
            m = p27.match(line)
            if m:
                erspan_dict.update(m.groupdict())
                continue

            # ERSPAN Dst Ipv6: 2001::1
            m = p28.match(line)
            if m:
                erspan_dict.update(m.groupdict())
                continue

            # ERSPAN Ip Ttl: 255
            m = p29.match(line)
            if m:
                erspan_dict.setdefault('ip_ttl', int(m.groupdict()['ip_ttl']))
                continue

            # ERSPAN DSCP  : 0
            m = p30.match(line)
            if m:
                erspan_dict.setdefault('dscp', int(m.groupdict()['dscp']))
                continue

            # ERSPAN Ipv6 flow label: 0
            m = p31.match(line)
            if m:
                erspan_dict.setdefault('ipv6_flow_label', int(m.groupdict()['ipv6_flow_label']))
                continue

            # ERSPAN VRFID   : 0
            m = p32.match(line)
            if m:
                erspan_dict.setdefault('vrfid', int(m.groupdict()['vrfid']))
                continue

            # ERSPAN State : Enabled
            m = p33.match(line)
            if m:
                erspan_dict.update(m.groupdict())
                continue

            # ERSPAN Tun id: 1251
            m = p34.match(line)
            if m:
                erspan_dict.setdefault('tun_id', int(m.groupdict()['tun_id']))
                continue

        return ret_dict


class ShowSwitchStackRingSpeedSchema(MetaParser):
    """Schema for show switch stack-ring speed"""

    schema = {
        'speed': str,
        'configuration': str,
        'protocol': str
    }


class ShowSwitchStackRingSpeed(ShowSwitchStackRingSpeedSchema):
    """Parser for show switch stack-ring speed"""

    cli_command = 'show switch stack-ring speed'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        # Stack Ring Speed        : 240G
        p1 = re.compile(r'^Stack\s+Ring\s+Speed\s+:\s+(?P<speed>\w+)$')

        # Stack Ring Configuration: Half
        p2 = re.compile(r'^Stack\s+Ring\s+Configuration:\s+(?P<configuration>\w+)$')

        # Stack Ring Protocol     : StackWise
        p3 = re.compile(r'^Stack\s+Ring\s+Protocol\s+:\s+(?P<protocol>\w+)$')

        ret_dict = dict()

        for line in output.splitlines():
            line = line.strip()

            match = p1.match(line)
            if match:
                ret_dict.update(match.groupdict())
                continue

            match = p2.match(line)
            if match:
                ret_dict.update(match.groupdict())
                continue

            match = p3.match(line)
            if match:
                ret_dict.update(match.groupdict())
                continue

        return ret_dict

# ======================================================
# Parser for 'show platform software fed switch active ifm if-id
# ======================================================
class ShSoftwareFedSchema(MetaParser):
    """Schema for show platform software fed switch active ifm if-id """
    schema = {
        'intf_id': str,
        'intf_name': str,
        'intf_block_pointer': str,
        'intf_block_state': str,
        'intf_state': str,
        'intf_admin_mode': str,
        'intf_status': str,
        'int_ref_cnt': int,
        'interface_type': {
            'intf_type': str,
            'port_type': str,
            'port_location': str,
            'slot': int,
            'unit': int,
            'slot_unit': int,
            'snmp_index': int,
            'gpn': int,
            'ec_channel': int,
            'ec_index': int,
            'ipv4_mtu': int,
            'ipv6_mtu': int,
            Optional('ipv4_vrf_id'): int,
            Optional('ipv6_vrf_id'): int,
            'protocol_flags': str,
            Optional('misc_flags'): str,
            'icmpv4_flags': str,
            'icmpv6_flags': str,
            'mac_address': str,
            'qos_trust_type': str,
        },
        'ref_count': str,
        'port_phy_sub': {
            'affinity': str,
            'lpn': int,
            'gpn': int,
            'speed': str,
            'type': str,
            'mtu': int,
            'ac_profile': str,
        },
        'port_sub': {
            'mac_port_oid': int,
            'system_port_oid': int,
            'system_port_gid': int,
            'ethernet_port_oid': int,
            'vog_oid': int,
        },
        'platform_sub': {
            'asic': int,
            'core': int,
            'asic_port': int,
            'asic_sub_port': int,
            'ifg_id': int,
            'mac_num': int,
            'first_serdes': int,
            'last_serdes': int,
            'fc_mode': int,
            'fec_mode': int,
            'context_id': int,
        },
        'port_l2_sub': {
            'port_mode': str,
            'port_mode_set': str,
            'vlan': int,
            'ethertype': int,
            'bd_vlan': int,
            'status': int,
            'ac_profile': str,
        },
        Optional('port_l3_sub'): {
            Optional('vrf_id'): int,
            Optional('ipv4_routing'): str,
            Optional('ipv6_routing'): str,
            Optional('mpls'): str,
            Optional('pimv4'): str,
            Optional('pimv6'): str,
            Optional('ipv4_mtu'): int,
            Optional('ipv6_mtu'): int,
            Optional('l3_srv'): int,
            Optional('l3_srv_oid'): int,
        },
    }
class ShSoftwareFed(ShSoftwareFedSchema):

    """Parser for show platform software fed switch active ifm if-id {if_id}"""

    cli_command = ['show platform software fed switch {switch_type} ifm {if_id}',
    'show platform software fed active ifm {if_id}']

    def cli(self, if_id, switch_type="", out=None):

        if out is None:
            if switch_type is not None:
                cmd = self.cli_command[0].format(if_id=if_id, switch_type=switch_type)
            else:
                cmd = self.cli_command[1].format(if_id=if_id)

            out = self.device.execute(cmd)

        # Interface IF_ID : 0x0000000000000561
        p1 = re.compile(r"^Interface\s+IF_ID\s+:\s+(?P<intf_id>\S+)$")

        # Interface Name : HundredGigE1/6/0/19
        p2 = re.compile(r"^Interface\s+Name\s+:\s+(?P<intf_name>\S+)$")

        # Interface Block Pointer : 0x7feaa50bbc28
        p3 = re.compile(r"^Interface\s+Block\s+Pointer\s+:\s+(?P<intf_block_pointer>\S+)$")

        # Interface Block State : Ready
        p4 = re.compile(r"^Interface\s+Block\s+State\s+:\s+(?P<intf_block_state>\w+)$")

        # Interface State : Enabled
        p5 = re.compile(r"^Interface\s+State\s+:\s+(?P<intf_state>\w+)$")

        # Interface Admin mode : Admin Up
        p6 = re.compile(r"^Interface\s+Admin\s+mode\s+:\s+(?P<intf_admin_mode>\S+\s+\S+)$")

        # Interface Status : NPD
        p7 = re.compile(r"^Interface\s+Status\s+:\s+(?P<intf_status>\w.+)$")

        # Interface Ref-Cnt : 1
        p8 = re.compile(r"^Interface\s+Ref-Cnt\s+:\s+(?P<int_ref_cnt>\d+)$")

        # Interface Type : ETHER
        p9 = re.compile(r"^Interface\s+Type\s+:\s+(?P<intf_type>\w+)$")

        # Port Type : ROUTE PORT
        p9_1 = re.compile(r"^\s+Port\s+Type\s+:\s+(?P<port_type>\S+\s+\S+)$")

        # Port Location : LOCAL
        p9_2 = re.compile(r"^\s+Port\s+Location\s+:\s+(?P<port_location>\w+)$")

        # Slot : 13
        p9_3 = re.compile(r"^\s+Slot\s+:\s+(?P<slot>\d+)$")

        # Unit : 0
        p9_4 = re.compile(r"^\s+Unit\s+:\s+(?P<unit>\d+)$")

        # Slot Unit : 19
        p9_5 = re.compile(r"^\s+Slot\s+Unit\s+:\s+(?P<slot_unit>\d+)$")

        # SNMP IF Index : 119
        p9_6 = re.compile(r"^\s+SNMP\s+IF\s+Index\s+:\s+(?P<snmp_index>\d+)$")

        # GPN : 979
        p9_7 = re.compile(r"^\s+GPN\s+:\s+(?P<gpn>\d+)$")

        # EC Channel : 0
        p9_8 = re.compile(r"^\s+EC\s+Channel\s+:\s+(?P<ec_channel>\d+)$")

        # EC Index : 0
        p9_9 = re.compile(r"^\s+EC\s+Index\s+:\s+(?P<ec_index>\d+)$")

        # IPv4 MTU : 2000
        p9_10 = re.compile(r"^\s+IPv4\s+MTU\s+:\s+(?P<ipv4_mtu>\d+)$")

        # IPv6 MTU : 0
        p9_11 = re.compile(r"^\s+IPv6\s+MTU\s+:\s+(?P<ipv6_mtu>\d+)$")

        # IPv4 VRF ID : 0
        p9_12 = re.compile(r"^\s+IPv4\s+VRF\s+ID\s+:\s+(?P<ipv4_vrf_id>\d+)$")

        # IPv6 VRF ID : 65535
        p9_13 = re.compile(r"^\s+IPv6\s+VRF\s+ID\s+:\s+(?P<ipv6_vrf_id>\d+)$")

        # Protocol flags : 0x0003 [ ipv4 ipv6 ]
        p9_14 = re.compile(r"^\s+Protocol\s+flags\s+:\s+(?P<protocol_flags>\S+\s+\S+\s+\S+\s+\S+\s+\S+)$")

        # Misc flags : 0x0041 [ ipv4 --- ]
        p9_15 = re.compile(r"^\s+Misc\s+flags\s+:\s+(?P<misc_flags>\S+\s+\S+\s+\S+\s+\S+\s+\S+)$")

        # ICMPv4 flags : 0x03 [ unreachable redirect ]
        p9_16 = re.compile(r"^\s+ICMPv4\s+flags\s+:\s+(?P<icmpv4_flags>\S+\s+\S+\s+\S+\s+\S+\s+\S+)$")

        # ICMPv6 flags : 0x03 [ unreachable redirect ]
        p9_17 = re.compile(r"^\s+ICMPv6\s+flags\s+:\s+(?P<icmpv6_flags>\S+\s+\S+\s+\S+\s+\S+\s+\S+)$")

        # Mac Address : 6c:b2:ae:4a:54:c5
        p9_18 = re.compile(r"^\s+Mac\s+Address\s+:\s+(?P<mac_address>\S+)$")

        # QoS Trust Type : 3 (DSCP)
        p9_19 = re.compile(r"^\s+QoS\s+Trust\s+Type\s+:\s+(?P<qos_trust_type>\S+\s+\S+)$")

        # Ref Count : 1 (feature Ref Counts + 1)
        p10 = re.compile(r"^Ref\s+Count\s+:\s+(?P<ref_count>\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+)$")

        # Affinity .......... [local]
        p11 = re.compile(r"^\s+Affinity\s+\.\.\.\.\.\.\.\.\.\.\s+\[(?P<affinity>\w+)\]$")

        # LPN ............... [19]
        p11_1 = re.compile(r"^\s+LPN\s+\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<lpn>\d+)\]$")

        # GPN ............... [979]
        p11_2 = re.compile(r"^\s+GPN\s+\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<gpn>\d+)\]$")

        # Speed ............. [40GB]
        p11_3 = re.compile(r"^\s+Speed\s+\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<speed>\S+)\]$")

        # type .............. [IFM_PORT_TYPE_L3]
        p11_4 = re.compile(r"^\s+type\s+\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<type>\S+)\]$")

        # MTU ............... [2022]
        p11_5 = re.compile(r"^\s+MTU\s+\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<mtu>\d+)\]$")

        # ac profile ........ [IFM_AC_PROFILE_DEFAULT]
        p11_6 = re.compile(r"^\s+ac\s+profile\s+\.\.\.\.\.\.\.\.\s+\[(?P<ac_profile>\S+)\]$")

        # Mac port oid................... [4444]
        p12 = re.compile(r"^\s+Mac\s+port\s+oid\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<mac_port_oid>\d+)\]$")

        # System port oid................ [4448]
        p12_1 = re.compile(r"^\s+System\s+port\s+oid\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<system_port_oid>\d+)\]$")

        # System port gid................ [223]
        p12_2 = re.compile(r"^\s+System\s+port\s+gid\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<system_port_gid>\d+)\]$")

        # Ethernet port oid.............. [4459]
        p12_3 = re.compile(r"^\s+Ethernet\s+port\s+oid\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<ethernet_port_oid>\d+)\]$")

        # Voq oid........................ [4446]
        p12_4 = re.compile(r"^\s+Voq\s+oid\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<vog_oid>\d+)\]$")

        # Asic.............. [0]
        p13 = re.compile(r"^\s+Asic\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<asic>\d+)\]$")

        # Core.............. [5]
        p13_1 = re.compile(r"^\s+Core\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<core>\d+)\]$")

        # Asic Port......... [0]
        p13_2 = re.compile(r"^\s+Asic\s+Port\.\.\.\.\.\.\.\.\.\s+\[(?P<asic_port>\d+)\]$")

        # Asic Sub Port..... [65535]
        p13_3 = re.compile(r"^\s+Asic\s+Sub\s+Port\.\.\.\.\.\s+\[(?P<asic_sub_port>\d+)\]$")

        # Ifg Id............ [0]
        p13_4 = re.compile(r"^\s+Ifg\s+Id\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<ifg_id>\d+)\]$")

        # Mac Num........... [211]
        p13_5 = re.compile(r"^\s+Mac\s+Num\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<mac_num>\d+)\]$")

        # First Serdes...... [10]
        p13_6 = re.compile(r"^\s+First\s+Serdes\.\.\.\.\.\.\s+\[(?P<first_serdes>\d+)\]$")

        # Last Serdes....... [11]
        p13_7 = re.compile(r"^\s+Last\s+Serdes\.\.\.\.\.\.\.\s+\[(?P<last_serdes>\d+)\]$")

        # FC Mode........... [0]
        p13_8 = re.compile(r"^\s+FC\s+Mode\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<fc_mode>\d+)\]$")

        # FEC Mode.......... [0]
        p13_9 = re.compile(r"^\s+FEC\s+Mode\.\.\.\.\.\.\.\.\.\.\s+\[(?P<fec_mode>\d+)\]$")

        # Context Id........ [0]
        p13_10 = re.compile(r"^\s+Context\s+Id\.\.\.\.\.\.\.\.\s+\[(?P<context_id>\d+)\]$")

        # L2 Port Mode ................ [port_mode_dynamic]
        p14 = re.compile(r"^\s+L2\s+Port\s+Mode\s+\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<port_mode>\S+)\]$")

        # L2 Port Mode set............. [No]
        p14_1 = re.compile(r"^\s+L2\s+Port\s+Mode\s+set\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<port_mode_set>\w+)\]$")

        # Default vlan ................ [0]
        p14_2 = re.compile(r"^\s+Default\s+vlan\s+\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<vlan>\d+)\]$")

        # Ethertype.................... [8100]
        p14_3 = re.compile(r"^\s+Ethertype\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<ethertype>\d+)\]$")

        # untagged port bd vlan ....... [0]
        p14_4 = re.compile(r"^\s+untagged\s+port\s+bd\s+vlan\s+\.\.\.\.\.\.\.\s+\[(?P<bd_vlan>\d+)\]$")

        # status....................... [0]
        p14_5 = re.compile(r"^\s+status\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<status>\d+)\]$")

        # ac profile .................. [IFM_AC_PROFILE_DEFAULT]
        p14_6 = re.compile(r"^\s+ac\s+profile\s+\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<ac_profile>\S+)\]$")

        # VRF ID .................. [0]
        p15 = re.compile(r"^\s+VRF\s+ID\s+\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<vrf_id>\d+)\]$")

        # IPv4 Routing Enabled .... [Yes]
        p15_1 = re.compile(r"^\s+IPv4\s+Routing\s+Enabled\s+\.\.\.\.\s+\[(?P<ipv4_routing>\w+)\]$")

        # IPv6 Routing Enabled .... [No]
        p15_2 = re.compile(r"^\s+IPv6\s+Routing\s+Enabled\s+\.\.\.\.\s+\[(?P<ipv6_routing>\w+)\]$")

        # MPLS Enabled ............ [No]
        p15_3 = re.compile(r"^\s+MPLS\s+Enabled\s+\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<mpls>\w+)\]$")

        # Pimv4 Enabled ........... [No]
        p15_4 = re.compile(r"^\s+Pimv4\s+Enabled\s+\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<pimv4>\w+)\]$")

        # Pimv6 Enabled ........... [No]
        p15_5 = re.compile(r"^\s+Pimv6\s+Enabled\s+\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<pimv6>\w+)\]$")

        # IPv4 MTU ................ [2018]
        p15_6 = re.compile(r"^\s+IPv4\s+MTU\s+\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<ipv4_mtu>\d+)\]$")

        # IPv6 MTU ................ [18]
        p15_7 = re.compile(r"^\s+IPv6\s+MTU\s+\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\.\s+\[(?P<ipv6_mtu>\d+)\]$")

        # L3 srv port gid ......... [4312]
        p15_8 = re.compile(r"^\s+L3\s+srv\s+port\s+gid\s+\.\.\.\.\.\.\.\.\.\s+\[(?P<l3_srv>\d+)\]$")

        # L3 srv port oid ......... [5489]
        p15_9 = re.compile(r"^\s+L3\s+srv\s+port\s+oid\s+\.\.\.\.\.\.\.\.\.\s+\[(?P<l3_srv_oid>\d+)\]$")

        ret_dict = {}

        for line in out.splitlines():

            # Interface IF_ID : 0x0000000000000561
            match_obj = p1.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                ret_dict['intf_id'] = dict_val['intf_id']
                continue

            # Interface Name : HundredGigE1/6/0/19
            match_obj = p2.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                ret_dict['intf_name'] = dict_val['intf_name']
                continue

            # Interface Block Pointer : 0x7feaa50bbc28
            match_obj = p3.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                ret_dict['intf_block_pointer'] = dict_val['intf_block_pointer']
                continue

            # Interface Block State : Ready
            match_obj = p4.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                ret_dict['intf_block_state'] = dict_val['intf_block_state']
                continue

            # Interface State : Enabled
            match_obj = p5.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                ret_dict['intf_state'] = dict_val['intf_state']
                continue

            # Interface Admin mode : Admin Up
            match_obj = p6.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                ret_dict['intf_admin_mode'] = dict_val['intf_admin_mode']
                continue

            # Interface Status : NPD
            match_obj = p7.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                ret_dict['intf_status'] = dict_val['intf_status']
                continue

            # Interface Ref-Cnt : 1
            match_obj = p8.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                ret_dict['int_ref_cnt'] = int(dict_val['int_ref_cnt'])
                continue

            # Interface Type : ETHER
            match_obj = p9.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['intf_type'] = dict_val['intf_type']
                continue

            # Port Type : ROUTE PORT
            match_obj = p9_1.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['port_type'] = dict_val['port_type']
                continue

            # Port Location : LOCAL
            match_obj = p9_2.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['port_location'] = dict_val['port_location']
                continue

            # Slot : 13
            match_obj = p9_3.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['slot'] = int(dict_val['slot'])
                continue

            # Unit : 0
            match_obj = p9_4.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['unit'] = int(dict_val['unit'])
                continue

            # Slot Unit : 19
            match_obj = p9_5.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['slot_unit'] = int(dict_val['slot_unit'])
                continue

            # SNMP IF Index : 119
            match_obj = p9_6.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['snmp_index'] = int(dict_val['snmp_index'])
                continue

            # GPN : 979
            match_obj = p9_7.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['gpn'] = int(dict_val['gpn'])
                continue

            # EC Channel : 0
            match_obj = p9_8.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['ec_channel'] = int(dict_val['ec_channel'])
                continue

            # EC Index : 0
            match_obj = p9_9.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['ec_index'] = int(dict_val['ec_index'])
                continue

            # IPv4 MTU : 2000
            match_obj = p9_10.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['ipv4_mtu'] = int(dict_val['ipv4_mtu'])
                continue

            # IPv6 MTU : 0
            match_obj = p9_11.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['ipv6_mtu'] = int(dict_val['ipv6_mtu'])
                continue

            # IPv4 VRF ID : 0
            match_obj = p9_12.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['ipv4_vrf_id'] = int(dict_val['ipv4_vrf_id'])
                continue

            # IPv6 VRF ID : 65535
            match_obj = p9_13.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['ipv6_vrf_id'] = int(dict_val['ipv6_vrf_id'])
                continue

            # Protocol flags : 0x0003 [ ipv4 ipv6 ]
            match_obj = p9_14.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['protocol_flags'] = dict_val['protocol_flags']
                continue

            # Misc flags : 0x0041 [ ipv4 --- ]
            match_obj = p9_15.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['misc_flags'] = dict_val['misc_flags']
                continue

            # ICMPv4 flags : 0x03 [ unreachable redirect ]
            match_obj = p9_16.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['icmpv4_flags'] = dict_val['icmpv4_flags']
                continue

            # ICMPv6 flags : 0x03 [ unreachable redirect ]
            match_obj = p9_17.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['icmpv6_flags'] = dict_val['icmpv6_flags']
                continue

            #  Mac Address : 6c:b2:ae:4a:54:c5
            match_obj = p9_18.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['mac_address'] = dict_val['mac_address']
                continue

            # QoS Trust Type : 3 (DSCP)
            match_obj = p9_19.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'interface_type' not in ret_dict:
                    interface_type = ret_dict.setdefault('interface_type', {})
                interface_type['qos_trust_type'] = dict_val['qos_trust_type']
                continue

            # Ref Count : 1 (feature Ref Counts + 1)
            match_obj = p10.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                ret_dict['ref_count'] = dict_val['ref_count']
                continue

            # Affinity .......... [local]
            match_obj = p11.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_phy_sub' not in ret_dict:
                    port_phy_sub = ret_dict.setdefault('port_phy_sub', {})
                port_phy_sub['affinity'] = dict_val['affinity']
                continue

            # LPN ............... [19]
            match_obj = p11_1.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_phy_sub' not in ret_dict:
                    port_phy_sub = ret_dict.setdefault('port_phy_sub', {})
                port_phy_sub['lpn'] = int(dict_val['lpn'])
                continue

            # GPN ............... [979]
            match_obj = p11_2.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_phy_sub' not in ret_dict:
                    port_phy_sub = ret_dict.setdefault('port_phy_sub', {})
                port_phy_sub['gpn'] = int(dict_val['gpn'])
                continue

            # Speed ............. [40GB]
            match_obj = p11_3.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_phy_sub' not in ret_dict:
                    port_phy_sub = ret_dict.setdefault('port_phy_sub', {})
                port_phy_sub['speed'] = dict_val['speed']
                continue

            # type .............. [IFM_PORT_TYPE_L3]
            match_obj = p11_4.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_phy_sub' not in ret_dict:
                    port_phy_sub = ret_dict.setdefault('port_phy_sub', {})
                port_phy_sub['type'] = dict_val['type']
                continue

            # MTU ............... [2022]
            match_obj = p11_5.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_phy_sub' not in ret_dict:
                    port_phy_sub = ret_dict.setdefault('port_phy_sub', {})
                port_phy_sub['mtu'] = int(dict_val['mtu'])
                continue

            # ac profile ........ [IFM_AC_PROFILE_DEFAULT]
            match_obj = p11_6.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_phy_sub' not in ret_dict:
                    port_phy_sub = ret_dict.setdefault('port_phy_sub', {})
                port_phy_sub['ac_profile'] = dict_val['ac_profile']
                continue

            # Mac port oid................... [4444]
            match_obj = p12.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_sub' not in ret_dict:
                    port_sub = ret_dict.setdefault('port_sub', {})
                port_sub['mac_port_oid'] = int(dict_val['mac_port_oid'])
                continue

            # System port oid................ [4448]
            match_obj = p12_1.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_sub' not in ret_dict:
                    port_sub = ret_dict.setdefault('port_sub', {})
                port_sub['system_port_oid'] = int(dict_val['system_port_oid'])
                continue

            # System port gid................ [223]
            match_obj = p12_2.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_sub' not in ret_dict:
                    port_sub = ret_dict.setdefault('port_sub', {})
                port_sub['system_port_gid'] = int(dict_val['system_port_gid'])
                continue

            # Ethernet port oid.............. [4459]
            match_obj = p12_3.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_sub' not in ret_dict:
                    port_sub = ret_dict.setdefault('port_sub', {})
                port_sub['ethernet_port_oid'] = int(dict_val['ethernet_port_oid'])
                continue

            # Voq oid........................ [4446]
            match_obj = p12_4.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_sub' not in ret_dict:
                    port_sub = ret_dict.setdefault('port_sub', {})
                port_sub['vog_oid'] = int(dict_val['vog_oid'])
                continue

            # Asic.............. [0]
            match_obj = p13.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'platform_sub' not in ret_dict:
                    platform_sub = ret_dict.setdefault('platform_sub', {})
                platform_sub['asic'] = int(dict_val['asic'])
                continue

            # Core.............. [5]
            match_obj = p13_1.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'platform_sub' not in ret_dict:
                    platform_sub = ret_dict.setdefault('platform_sub', {})
                platform_sub['core'] = int(dict_val['core'])
                continue

            # Asic Port......... [0]
            match_obj = p13_2.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'platform_sub' not in ret_dict:
                    platform_sub = ret_dict.setdefault('platform_sub', {})
                platform_sub['asic_port'] = int(dict_val['asic_port'])
                continue

            # Asic Sub Port..... [65535]
            match_obj = p13_3.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'platform_sub' not in ret_dict:
                    platform_sub = ret_dict.setdefault('platform_sub', {})
                platform_sub['asic_sub_port'] = int(dict_val['asic_sub_port'])
                continue

            # Ifg Id............ [0]
            match_obj = p13_4.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'platform_sub' not in ret_dict:
                    platform_sub = ret_dict.setdefault('platform_sub', {})
                platform_sub['ifg_id'] = int(dict_val['ifg_id'])
                continue

            # Mac Num........... [211]
            match_obj = p13_5.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'platform_sub' not in ret_dict:
                    platform_sub = ret_dict.setdefault('platform_sub', {})
                platform_sub['mac_num'] = int(dict_val['mac_num'])
                continue

            # First Serdes...... [10]
            match_obj = p13_6.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'platform_sub' not in ret_dict:
                    platform_sub = ret_dict.setdefault('platform_sub', {})
                platform_sub['first_serdes'] = int(dict_val['first_serdes'])
                continue

            # Last Serdes....... [11]
            match_obj = p13_7.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'platform_sub' not in ret_dict:
                    platform_sub = ret_dict.setdefault('platform_sub', {})
                platform_sub['last_serdes'] = int(dict_val['last_serdes'])
                continue

            # FC Mode........... [0]
            match_obj = p13_8.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'platform_sub' not in ret_dict:
                    platform_sub = ret_dict.setdefault('platform_sub', {})
                platform_sub['fc_mode'] = int(dict_val['fc_mode'])
                continue

            # FEC Mode.......... [0]
            match_obj = p13_9.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'platform_sub' not in ret_dict:
                    platform_sub = ret_dict.setdefault('platform_sub', {})
                platform_sub['fec_mode'] = int(dict_val['fec_mode'])
                continue

            # Context Id........ [0]
            match_obj = p13_10.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'platform_sub' not in ret_dict:
                    platform_sub = ret_dict.setdefault('platform_sub', {})
                platform_sub['context_id'] = int(dict_val['context_id'])
                continue

            # L2 Port Mode ................ [port_mode_dynamic]
            match_obj = p14.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l2_sub' not in ret_dict:
                    port_l2_sub = ret_dict.setdefault('port_l2_sub', {})
                port_l2_sub['port_mode'] = dict_val['port_mode']
                continue

            # L2 Port Mode set............. [No]
            match_obj = p14_1.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l2_sub' not in ret_dict:
                    port_l2_sub = ret_dict.setdefault('port_l2_sub', {})
                port_l2_sub['port_mode_set'] = dict_val['port_mode_set']
                continue

            # Default vlan ................ [0]
            match_obj = p14_2.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l2_sub' not in ret_dict:
                    port_l2_sub = ret_dict.setdefault('port_l2_sub', {})
                port_l2_sub['vlan'] = int(dict_val['vlan'])
                continue

            # Ethertype.................... [8100]
            match_obj = p14_3.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l2_sub' not in ret_dict:
                    port_l2_sub = ret_dict.setdefault('port_l2_sub', {})
                port_l2_sub['ethertype'] = int(dict_val['ethertype'])
                continue

            # untagged port bd vlan ....... [0]
            match_obj = p14_4.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l2_sub' not in ret_dict:
                    port_l2_sub = ret_dict.setdefault('port_l2_sub', {})
                port_l2_sub['bd_vlan'] = int(dict_val['bd_vlan'])
                continue

            # status....................... [0]
            match_obj = p14_5.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l2_sub' not in ret_dict:
                    port_l2_sub = ret_dict.setdefault('port_l2_sub', {})
                port_l2_sub['status'] = int(dict_val['status'])
                continue

            # ac profile .................. [IFM_AC_PROFILE_DEFAULT]
            match_obj = p14_6.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l2_sub' not in ret_dict:
                    port_l2_sub = ret_dict.setdefault('port_l2_sub', {})
                port_l2_sub['ac_profile'] = dict_val['ac_profile']
                continue

            # VRF ID .................. [0]
            match_obj = p15.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l3_sub' not in ret_dict:
                    port_l3_sub = ret_dict.setdefault('port_l3_sub', {})
                port_l3_sub['vrf_id'] = int(dict_val['vrf_id'])
                continue

            # IPv4 Routing Enabled .... [Yes]
            match_obj = p15_1.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l3_sub' not in ret_dict:
                    port_l3_sub = ret_dict.setdefault('port_l3_sub', {})
                port_l3_sub['ipv4_routing'] = dict_val['ipv4_routing']
                continue

            # IPv6 Routing Enabled .... [No]
            match_obj = p15_2.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l3_sub' not in ret_dict:
                    port_l3_sub = ret_dict.setdefault('port_l3_sub', {})
                port_l3_sub['ipv6_routing'] = dict_val['ipv6_routing']
                continue

            # MPLS Enabled ............ [No]
            match_obj = p15_3.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l3_sub' not in ret_dict:
                    port_l3_sub = ret_dict.setdefault('port_l3_sub', {})
                port_l3_sub['mpls'] = dict_val['mpls']
                continue

            # Pimv4 Enabled ........... [No]
            match_obj = p15_4.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l3_sub' not in ret_dict:
                    port_l3_sub = ret_dict.setdefault('port_l3_sub', {})
                port_l3_sub['pimv4'] = dict_val['pimv4']
                continue

            # Pimv6 Enabled ........... [No]
            match_obj = p15_5.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l3_sub' not in ret_dict:
                    port_l3_sub = ret_dict.setdefault('port_l3_sub', {})
                port_l3_sub['pimv6'] = dict_val['pimv6']
                continue

            # IPv4 MTU ................ [2018]
            match_obj = p15_6.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l3_sub' not in ret_dict:
                    port_l3_sub = ret_dict.setdefault('port_l3_sub', {})
                port_l3_sub['ipv4_mtu'] = int(dict_val['ipv4_mtu'])
                continue

            # IPv6 MTU ................ [18]
            match_obj = p15_7.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l3_sub' not in ret_dict:
                    port_l3_sub = ret_dict.setdefault('port_l3_sub', {})
                port_l3_sub['ipv6_mtu'] = int(dict_val['ipv6_mtu'])
                continue

            # L3 srv port gid ......... [4312]
            match_obj = p15_8.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l3_sub' not in ret_dict:
                    port_l3_sub = ret_dict.setdefault('port_l3_sub', {})
                port_l3_sub['l3_srv'] = int(dict_val['l3_srv'])
                continue

            # L3 srv port oid ......... [5489]
            match_obj = p15_9.match(line)
            if match_obj:
                dict_val = match_obj.groupdict()
                if 'port_l3_sub' not in ret_dict:
                    port_l3_sub = ret_dict.setdefault('port_l3_sub', {})
                port_l3_sub['l3_srv_oid'] = int(dict_val['l3_srv_oid'])
                continue

        return ret_dict


class ShowPlatformUsbStatusSchema(MetaParser):
    '''Schema for show platform usb status'''
    schema = {
        'status': str
    }


class ShowPlatformUsbStatus(ShowPlatformUsbStatusSchema):
    '''Parser for show platform usb status'''

    cli_command = 'show platform usb status'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        # USB enabled
        p1 = re.compile(r'^USB\s+(?P<status>\S+)$')

        ret_dict = dict()

        for line in output.splitlines():
            line = line.strip()

            # USB enabled
            m = p1.match(line)
            if m:
                ret_dict.update(m.groupdict())
                continue

        return ret_dict

# ======================================================
# Parser for 'show platform software fed active vp summary interface if_id {interface_id} '
# ======================================================

class ShPlatformSoftwareFedActiveVpSummaryInterfaceIf_idSchema(MetaParser):
    """Schema for show platform software fed active vp summary interface if_id {interface_id}"""

    schema = {
        'interfaces': {
            Any(): {
                'if_id': str,
                'vlan_id': int,
                'pvln_mode': str,
                'pvlan': str,
                'stp_state': str,
                'vtp_pruned': str,
                'untag': str,
            },
        },
    }

class ShPlatformSoftwareFedActiveVpSummaryInterfaceIf_id(ShPlatformSoftwareFedActiveVpSummaryInterfaceIf_idSchema):
    """Parser for show platform software fed active vp summary interface if_id {interface_id}"""

    cli_command = ['show platform software fed {mode} vp summary interface if_id {interface_id}', 
                'show platform software fed {switch} {mode} vp summary interface if_id {interface_id}']

    def cli(self, interface_id, mode, switch=None, output=None):
        if output is None:
            if switch:
                cmd = self.cli_command[1].format(interface_id=interface_id, mode=mode, switch=switch)
            else:
                cmd = self.cli_command[0].format(interface_id=interface_id, mode=mode)
            
            output = self.device.execute(cmd)

        #              102           80        trunk            1  forwarding          No                Yes
        p1 = re.compile(r"(?P<if_id>\d+)\s+(?P<vlan_id>\d+)\s+(?P<pvln_mode>\w+)\s+(?P<pvlan>\d+)\s+(?P<stp_state>\w+)\s+(?P<vtp_pruned>\w+)\s+(?P<untag>\w+)$")

        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()

            #              102           80        trunk            1  forwarding          No                Yes
            m = p1.match(line)
            if m:
                dict_val = m.groupdict()
                vlan_id_var = dict_val['vlan_id']
                interfaces = ret_dict.setdefault('interfaces', {})
                vlan_id_dict = ret_dict['interfaces'].setdefault(vlan_id_var, {})
                vlan_id_dict['if_id'] = dict_val['if_id']
                vlan_id_dict['vlan_id'] = int(dict_val['vlan_id'])
                vlan_id_dict['pvln_mode'] = dict_val['pvln_mode']
                vlan_id_dict['pvlan'] = dict_val['pvlan']
                vlan_id_dict['stp_state'] = dict_val['stp_state']
                vlan_id_dict['vtp_pruned'] = dict_val['vtp_pruned']
                vlan_id_dict['untag'] = dict_val['untag']
                continue


        return ret_dict

# ======================================================
# Parser for 'show platform hardware fed switch {switch} fwd-asic resource utilization'
# ======================================================
class ShowPlatformHardwareFedSwitchResourceUtilizationSchema(MetaParser):
    """Schema for show platform hardware fed switch {switch} fwd-asic resource utilization """
    schema = {
        'asic_instance': {
            Any(): {
                'resource': {
                    Any(): {
                        'resource_name': str,
                        'allocated': int,
                        'free': int
                    }
                }
            },
        },
    }
class ShowPlatformHardwareFedSwitchResourceUtilization(ShowPlatformHardwareFedSwitchResourceUtilizationSchema):
    """Parser for show platform hardware fed switch {switch} fwd-asic resource utilization """
    cli_command = ['show platform hardware fed active fwd-asic resource utilization',
        'show platform hardware fed switch {switch} fwd-asic resource utilization']

    def cli(self, switch=None, output=None):

        if output is None:
            if switch:
                cmd = self.cli_command[1].format(switch=switch)
            else:
                cmd = self.cli_command[0]

            output = self.device.execute(cmd)

        #Resource Info for ASIC Instance:    0
        p1 = re.compile(r"^Resource Info for ASIC Instance:\s+(?P<asic_instance>\d+)$")

        # RSC_DI                     149       41525
        p2 = re.compile(r"^(?P<resource_name>\w+)\s+(?P<allocated>\d+)\s+(?P<free>\d+)$")

        ret_dict = {}
        current_asic = '0'

        for line in output.splitlines():
            line = line.strip()

            #Resource Info for ASIC Instance: 0
            m = p1.match(line)
            if m:
                dict_val = m.groupdict()
                current_asic = dict_val['asic_instance']

            # RSC_DI                      149       41525
            m = p2.match(line)
            if m:
                dict_val = m.groupdict()
                asic_group = ret_dict.setdefault('asic_instance', {})
                asic_dict = ret_dict['asic_instance'].setdefault(current_asic, {})
                resource_var = dict_val['resource_name']
                resource_group = ret_dict['asic_instance'][current_asic].setdefault('resource', {})
                resource_dict = ret_dict['asic_instance'][current_asic]['resource'].setdefault(resource_var, {})
                resource_dict['resource_name'] = dict_val['resource_name']
                resource_dict['allocated'] = int(dict_val['allocated'])
                resource_dict['free'] = int(dict_val['free'])
                continue

        return ret_dict


# Parser for 'show platform pm interface-numbers '
# ======================================================

class ShowPlatformPmInterfaceNumbersSchema(MetaParser):
    """Schema for show platform pm interface-numbers"""
    schema = {
        'interfaces': {
            Any(): {
                'interface': str,
                'iif_id': int,
                'gid': int,
                'slot': int,
                'unit': int,
                'slun': int,
                'hwidb_ptr': str,
                'status': str,
                'status2': str,
                'state': str,
                'snmp_if_index': int,
            },
        },
    }

class ShowPlatformPmInterfaceNumbers(ShowPlatformPmInterfaceNumbersSchema):
    """Parser for show platform pm interface-numbers"""

    cli_command = 'show platform pm interface-numbers'
    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        # Gi1/0/1       9  1    1    1    1    0x7F2C5B930F40 0x10040    0x20001B   0x4        9

        p1 = re.compile(r"^(?P<interface>\S+)\s+(?P<iif_id>\d+)\s+(?P<gid>\d+)\s+(?P<slot>\d+)\s+(?P<unit>\d+)\s+(?P<slun>\d+)\s+(?P<hwidb_ptr>\S+)\s+(?P<status>\S+)\s+(?P<status2>\S+)\s+(?P<state>\S+)\s+(?P<snmp_if_index>\d+)$")
        ret_dict = {}
        for line in output.splitlines():
            line = line.strip()
            # Gi1/0/1       9  1    1    1    1    0x7F2C5B930F40 0x10040    0x20001B   0x4        9
            m = p1.match(line)
            if m:
                dict_val = m.groupdict()
                interface_var = dict_val['interface']
                if 'interfaces' not in ret_dict:
                    interfaces = ret_dict.setdefault('interfaces', {})
                if interface_var not in ret_dict['interfaces']:
                    interface_dict = ret_dict['interfaces'].setdefault(interface_var, {})
                interface_dict['interface'] = dict_val['interface']
                interface_dict['iif_id'] = int(dict_val['iif_id'])
                interface_dict['gid'] = int(dict_val['gid'])
                interface_dict['slot'] = int(dict_val['slot'])
                interface_dict['unit'] = int(dict_val['unit'])
                interface_dict['slun'] = int(dict_val['slun'])
                interface_dict['hwidb_ptr'] = dict_val['hwidb_ptr']
                interface_dict['status'] = dict_val['status']
                interface_dict['status2'] = dict_val['status2']
                interface_dict['state'] = dict_val['state']
                interface_dict['snmp_if_index'] = int(dict_val['snmp_if_index'])
                continue

        return ret_dict


# ======================================================
# Parser for 'show platform software fed switch active matm adjacencies vlan {vlan_id} '
# ======================================================

class ShowPlatformSoftwareFedSwitchActiveMatmAdjacenciesVlanSchema(MetaParser):
    """Schema for show platform software fed switch active matm adjacencies vlan {vlan_id}"""

    schema = {
        'adj_id': {
            Any(): {
                'vlan_id': int,
                'adj_key': str,
                'encap': str,
                'link_type': str,
                'si_handle': str,
                'ri_handle': str,
                'l3_mri_handle': str,
                'di_handle': str,
                'obj_type': str,
                'shared': str,
            },
        },
    }

class ShowPlatformSoftwareFedSwitchActiveMatmAdjacenciesVlan(ShowPlatformSoftwareFedSwitchActiveMatmAdjacenciesVlanSchema):
    """Parser for show platform software fed switch active matm adjacencies vlan {vlan_id}"""

    cli_command = ['show platform software fed {switch} active matm adjacencies vlan {vlan_id}',
                   'show platform software fed active matm adjacencies vlan {vlan_id}']

    def cli(self, vlan_id, switch=None, output=None):
        if output is None:
            if switch:
                output = self.device.execute(self.cli_command[0].format(switch=switch,vlan_id=vlan_id))
            else:
                output = self.device.execute(self.cli_command[1].format(vlan_id=vlan_id))

        #v99     966         0x3000003c6      VXLAN  V4     0x0              0x0              0x0              0x0              UC         No
        p1 = re.compile(r"^(?P<vlan_id>\d+)\s+(?P<adj_id>\d+)\s+(?P<adj_key>\S+)\s+(?P<encap>\S+)\s+(?P<link_type>\w+)\s+(?P<si_handle>\w+)\s+(?P<ri_handle>\w+)\s+(?P<l3_mri_handle>\S+)\s+(?P<di_handle>\w+)\s+(?P<obj_type>\S+)\s+(?P<shared>\w+)$")
        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()

            # V99     966         0x3000003c6      VXLAN  V4     0x0              0x0              0x0              0x0              UC         No
            m = p1.match(line)
            if m:
                group = m.groupdict()
                adj_id = int(group['adj_id'])
                matm_adj_dict = ret_dict.setdefault('adj_id', {})
                adj_id_dict = matm_adj_dict.setdefault(adj_id, {})
                adj_id_dict['vlan_id'] = int(group['vlan_id'])
                adj_id_dict['adj_key'] = group['adj_key']
                adj_id_dict['encap'] = group['encap']
                adj_id_dict['link_type'] = group['link_type']
                adj_id_dict['si_handle'] = group['si_handle']
                adj_id_dict['ri_handle'] = group['ri_handle']
                adj_id_dict['l3_mri_handle'] = group['l3_mri_handle']
                adj_id_dict['di_handle'] = group['di_handle']
                adj_id_dict['obj_type'] = group['obj_type']
                adj_id_dict['shared'] = group['shared']
                continue

        return ret_dict

# ======================================================
# Parser for 'show platform software fed switch active matm adjacencies adjkey {adj_key} '
# ======================================================

class ShowPlatformSoftwareFedSwitchActiveMatmAdjacenciesAdjkeySchema(MetaParser):
    """Schema for show platform software fed switch active matm adjacencies adjkey {adj_key}"""

    schema = {
        'adj_id': {
            Any(): {
                'if_number': str,
                'vni_id': int,
                'len': int,
                'vlan_id': int,
                'encap': str,
                'link_type': str,
                'source_ip': str,
                'destination_ip': str,
                'si_handle': str,
                'ri_handle': str,
                'l3_mri_handle': str,
                'di_handle': str,
                'object_type': str,
            },
        },
        'created_time': str,
        'last_modified': str,
        'current_time': str,
        Optional('asic_instance'): {
            Any(): {
                Optional('ri'): int,
                Optional('rewrite_type'): str,
                Optional('mapped_ri'): str,
                Optional('src_ip'): str,
                Optional('dst_ip'): str,
                Optional('dst_mac'): str,
                Optional('src_mac'): str,
                Optional('ipv4_ttl'): int,
                Optional('iid_present'): int,
                Optional('lisp_iid'): int,
                Optional('lisp_flags'): int,
                Optional('dst_port'): int,
                Optional('update_l3if'): int,
                Optional('is_ttl_prop'): int,
                Optional('l3if_le'): str,
                Optional('port_le'): str,
                Optional('vlan_le'): str
            },
        }
    }

class ShowPlatformSoftwareFedSwitchActiveMatmAdjacenciesAdjkey(ShowPlatformSoftwareFedSwitchActiveMatmAdjacenciesAdjkeySchema):
    """Parser for show platform software fed switch active matm adjacencies adjkey {adj_key}"""

    cli_command = ['show platform software fed {switch} active matm adjacencies adjkey {adj_key}',
                   'show platform software fed active matm adjacencies adjkey {adj_key}']

    def cli(self, adj_key, switch=None, output=None):
        if output is None:
            if switch:
                output = self.device.execute(self.cli_command[0].format(switch=switch, adj_key=adj_key))
            else:
                output = self.device.execute(self.cli_command[1].format(adj_key=adj_key))

        # 3849        0x420065   200199     60     99     VXLAN  V4     172.11.1.1        172.11.1.22       0x7f95815d74d8       0x7f95815a4528       0x0              0x0          UC
        p1 = re.compile(
            r"^(?P<adj_id>\d+)\s+(?P<if_number>\S+)\s+(?P<vni_id>\d+)\s+(?P<len>\d+)\s+(?P<vlan_id>\d+)\s+(?P<encap>\w+)\s+(?P<link_type>\S+)\s+(?P<source_ip>(\d{1,3}\.){3}\d{1,3})\s+(?P<destination_ip>(\d{1,3}\.){3}\d{1,3})\s+(?P<si_handle>\S+)\s+(?P<ri_handle>\S+)\s+(?P<l3_mri_handle>\S+)\s+(?P<di_handle>\S+)\s+(?P<object_type>\w+)$")

        # Created Time       : 2023/01/24 05:25:43.658
        p2 = re.compile(r"^Created\s+Time\s+:\s+(?P<created_time>.*)$")

        # Last Modified Time : 2023/01/24 05:25:43.658
        p3 = re.compile(r"^Last\s+Modified\s+Time\s+:\s+(?P<last_modified>.*)$")

        # Current Time       : 2023/01/24 07:52:27.709
        p4 = re.compile(r"^Current\s+Time\s+:\s+(?P<current_time>.*)$")

        # ASIC#:0 RI:226 Rewrite_type:AL_RRM_REWRITE_LVX_IPV4_L2_PAYLOAD_ENCAP_EPG(116) Mapped_rii:LVX_L3_ENCAP_L2_PAYLOAD_EPG(135)
        p5 = re.compile(
            r"^ASIC#:+(?P<asic_instance>\d+)\s+RI:+(?P<ri>\d+)+\s+Rewrite_type:+(?P<rewrite_type>\S+)\s+Mapped_rii:+(?P<mapped_ri>\S+)$")

        # Src IP:    172.11.1.1
        p6 = re.compile(r"^Src\s+IP:\s+(?P<src_ip>\S+)$")

        # Dst IP:    172.11.1.22
        p7 = re.compile(r"^Dst\s+IP:\s+(?P<dst_ip>\S+)$")

        # iVxlan dstMac:     0x9f:0x00:0x00
        p8 = re.compile(r"^iVxlan\s+dstMac:\s+(?P<dst_mac>\S+)$")

        # iVxlan srcMac:     0x00:0x00:0x00
        p9 = re.compile(r"^iVxlan\s+srcMac:\s+(?P<src_mac>\S+)$")

        # IPv4 TTL:  0
        p10 = re.compile(r"^IPv4\s+TTL:\s+(?P<ipv4_ttl>\d+)$")

        # iid present:   0
        p11 = re.compile(r"^iid\s+present:\s+(?P<iid_present>\d+)$")

        # lisp iid:  200199
        p12 = re.compile(r"^lisp\s+iid:\s+(?P<lisp_iid>\d+)$")

        # lisp flags:    0
        p13 = re.compile(r"^lisp\s+flags:\s+(?P<lisp_flags>\d+)$")

        # dst Port:  4789
        p14 = re.compile(r"^dst\s+Port:\s+(?P<dst_port>\d+)$")

        # update only l3if:  0
        p15 = re.compile(r"^update\s+only\s+l3if:\s+(?P<update_l3if>\d+)$")

        # is Sgt:    0
        p16 = re.compile(r"^is\s+sgt:\s+(?P<is_sgt>\d+)$")

        # is TTL Prop:   0
        p17 = re.compile(r"^is\s+TTL\s+Prop:\s+(?P<is_ttl_prop>\d+)$")

        # L3if LE:   126 (0)
        p18 = re.compile(r"^L3if\s+LE:\s+(?P<l3if_le>.*)$")

        # Port LE:   318 (0)
        p19 = re.compile(r"^Port\s+LE:\s+(?P<port_le>.*)$")

        # Vlan LE:   68 (0)
        p20 = re.compile(r"^Vlan\s+LE:\s+(?P<vlan_le>.*)$")


        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()

            # 3849        0x420065   200199     60     99     VXLAN  V4     172.11.1.1        172.11.1.22       0x7f95815d74d8       0x7f95815a4528       0x0              0x0          UC
            m = p1.match(line)
            if m:
                group = m.groupdict()
                adj_id = int(group['adj_id'])
                matm_adj_dict = ret_dict.setdefault('adj_id', {})
                adj_id_dict = matm_adj_dict.setdefault(adj_id, {})
                adj_id_dict['if_number'] = group['if_number']
                adj_id_dict['vni_id'] = int(group['vni_id'])
                adj_id_dict['len'] = int(group['len'])
                adj_id_dict['vlan_id'] = int(group['vlan_id'])
                adj_id_dict['encap'] = group['encap']
                adj_id_dict['link_type'] = group['link_type']
                adj_id_dict['source_ip'] = group['source_ip']
                adj_id_dict['destination_ip'] = group['destination_ip']
                adj_id_dict['si_handle'] = group['si_handle']
                adj_id_dict['ri_handle'] = group['ri_handle']
                adj_id_dict['l3_mri_handle'] = group['l3_mri_handle']
                adj_id_dict['di_handle'] = group['di_handle']
                adj_id_dict['object_type'] = group['object_type']

            # Created Time       : 2023/01/24 05:25:43.658
            m = p2.match(line)
            if m:
                group = m.groupdict()
                ret_dict['created_time'] = group['created_time']
                continue

            # Last Modified Time : 2023/01/24 05:25:43.658
            m = p3.match(line)
            if m:
                group = m.groupdict()
                ret_dict['last_modified'] = group['last_modified']
                continue

            # Current Time       : 2023/01/24 07:52:27.709
            m = p4.match(line)
            if m:
                group = m.groupdict()
                ret_dict['current_time'] = group['current_time']
                continue

            # ASIC#:0 RI:226 Rewrite_type:AL_RRM_REWRITE_LVX_IPV4_L2_PAYLOAD_ENCAP_EPG(116) Mapped_rii:LVX_L3_ENCAP_L2_PAYLOAD_EPG(135)
            m = p5.match(line)
            if m:
                group = m.groupdict()
                asic_instance = int(group['asic_instance'])
                asic_dict = ret_dict.setdefault('asic_instance', {})
                res_info_dict = asic_dict.setdefault(asic_instance, {})
                res_info_dict['ri'] = int(group['ri'])
                res_info_dict['rewrite_type'] = group['rewrite_type']
                res_info_dict['mapped_ri'] = group['mapped_ri']
                continue

            # Src IP:    172.11.1.1
            m = p6.match(line)
            if m:
                group = m.groupdict()
                res_info_dict['src_ip'] = group['src_ip']
                continue

            # Dst IP:    172.11.1.22
            m = p7.match(line)
            if m:
                group = m.groupdict()
                res_info_dict['dst_ip'] = group['dst_ip']
                continue

            # iVxlan dstMac:     0x9f:0x00:0x00
            m = p8.match(line)
            if m:
                group = m.groupdict()
                res_info_dict['dst_mac'] = group['dst_mac']
                continue

            # iVxlan srcMac:     0x00:0x00:0x00
            m = p9.match(line)
            if m:
                group = m.groupdict()
                res_info_dict['src_mac'] = group['src_mac']
                continue

            # IPv4 TTL:  0
            m = p10.match(line)
            if m:
                group = m.groupdict()
                res_info_dict['ipv4_ttl'] = int(group['ipv4_ttl'])
                continue

            # iid present:   0
            m = p11.match(line)
            if m:
                group = m.groupdict()
                res_info_dict['iid_present'] = int(group['iid_present'])
                continue

            # lisp iid:  200199
            m = p12.match(line)
            if m:
                group = m.groupdict()
                res_info_dict['lisp_iid'] = int(group['lisp_iid'])
                continue

            # lisp flags:    0
            m = p13.match(line)
            if m:
                group = m.groupdict()
                res_info_dict['lisp_flags'] = int(group['lisp_flags'])
                continue

            # dst Port:  4789
            m = p14.match(line)
            if m:
                group = m.groupdict()
                res_info_dict['dst_port'] = int(group['dst_port'])
                continue

            # update only l3if:  0
            m = p15.match(line)
            if m:
                group = m.groupdict()
                res_info_dict['update_l3if'] = int(group['update_l3if'])
                continue

            # is Sgt:    0
            m = p16.match(line)
            if m:
                group = m.groupdict()
                res_info_dict['is_sgt'] = int(group['is_sgt'])
                continue

            # is TTL Prop:   0
            m = p17.match(line)
            if m:
                group = m.groupdict()
                res_info_dict['is_ttl_prop'] = int(group['is_ttl_prop'])
                continue

            # L3if LE:   126 (0)
            m = p18.match(line)
            if m:
                group = m.groupdict()
                res_info_dict['l3if_le'] = group['l3if_le']
                continue

            # Port LE:   318 (0)
            m = p19.match(line)
            if m:
                group = m.groupdict()
                res_info_dict['port_le'] = group['port_le']
                continue

            # Vlan LE:   68 (0)
            m = p20.match(line)
            if m:
                group = m.groupdict()
                res_info_dict['vlan_le'] = group['vlan_le']
                continue

        return ret_dict


class ShowPlatformSoftwareFedActiveMonitorSchema(MetaParser):
    '''
        Schema for 'show platform software fed active monitor {session}'
    '''
    schema = {
        'session_type': str,
        'source_ports': {
            'rx': list,
            'tx': list
        },
        Optional('destination_ports'): list,
        Optional('source_vlans'): list,
        Optional('destination_vlans'): list,
        'source_rspan_vlan': int,
        'destination_rspan_vlan': int,
        'encap': str,
        'ingress_forwarding': str,
        Optional('filter_vlans'): list,
        'erspan_enable': int,
        'erspan_hw_programmed': int,
        'erspan_mandatory_cfg': int,
        'erspan_id': int,
        Optional('gre_protocol'): str,
        'mtu': int,
        'ip_tos': int,
        'ip_ttl': int,
        'cos': int,
        'vrf_id': int,
        'tunnel_if_id': int,
        'destination_ip': str,
        'org_ip': str,
        Optional('sgt_count'): int,
        Optional('sgt_tag'): str
    }


class ShowPlatformSoftwareFedActiveMonitor(ShowPlatformSoftwareFedActiveMonitorSchema):
    '''
        Parser for 'show platform software fed active monitor {session}'
    '''

    cli_command = 'show platform software fed active monitor {session}'

    def cli(self, session, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(session=session))

        # Session Type         : ERSPAN Source Session
        p1 = re.compile(r'^Session Type\s+:\s+(?P<session_type>[\w\s]+)$')

        # Source Ports         : RX: GigabitEthernet1/0/1 TenGigabitEthernet1/1/3 TX: None
        p2 = re.compile(r'^Source Ports\s+: RX:\s+(?P<rx>[\w\/\s]+)\sTX:\s+(?P<tx>[\w\/\s]+)$')

        # Destination Ports    : TwoGigabitEthernet1/0/13
        p3 = re.compile(r'^Destination Ports\s+:\s+(?P<destination_ports>[\w\/\s]+(?<!None))$')

        # Source VLANs         : None
        p4 = re.compile(r'^Source VLANs\s+:\s+(?P<source_vlans>[\w\-\d\s]+(?<!None))$')

        # Destination VLANs    : None
        p5 = re.compile(r'^Destination VLANs\s+:\s+(?P<destination_vlans>[\w\-\d\s]+(?<!None))$')

        # Source RSPAN VLAN    : 0
        p6 = re.compile(r'^Source RSPAN VLAN\s+:\s+(?P<source_rspan_vlan>\d+)$')

        # DST RSPAN VLAN       : 0
        p7 = re.compile(r'^DST RSPAN VLAN\s+:\s+(?P<destination_rspan_vlan>\d+)$')

        # Encap                : Native
        p8 = re.compile(r'^Encap\s+:\s+(?P<encap>\S+)$')

        # Ingress Forwarding   : Disabled
        p9 = re.compile(r'^Ingress Forwarding\s+:\s+(?P<ingress_forwarding>\S+)$')

        # Filter VLANs         : None
        p10 = re.compile(r'^Filter VLANs\s+:\s+(?P<filter_vlans>[\d\s]+(?<!None))$')

        # ERSPAN Enable        : 1
        p11 = re.compile(r'^ERSPAN Enable\s+:\s+(?P<erspan_enable>\d+)$')

        # ERSPAN Hw Programmed : 1
        p12 = re.compile(r'^ERSPAN Hw Programmed\s+:\s+(?P<erspan_hw_programmed>\d+)$')

        # ERSPAN Mandatory Cfg : 1
        p13 = re.compile(r'^ERSPAN Mandatory Cfg\s+:\s+(?P<erspan_mandatory_cfg>\d+)$')

        # ERSPAN Id            : 3
        p14 = re.compile(r'^ERSPAN Id\s+:\s+(?P<erspan_id>\d+)$')

        # Gre Prot             : 88be
        p15 = re.compile(r'^Gre Prot\s+:\s+(?P<gre_protocol>\S+)$')

        # MTU                  : 9000
        p16 = re.compile(r'^MTU\s+:\s+(?P<mtu>\d+)$')

        # Ip Tos               : 0 (DSCP:0)
        p17 = re.compile(r'^Ip Tos\s+:\s+(?P<ip_tos>\d+).+$')

        # Ip Ttl               : 255
        p18 = re.compile(r'^Ip Ttl\s+:\s+(?P<ip_ttl>\d+)$')

        # Cos                  : 0
        p19 = re.compile(r'^Cos\s+:\s+(?P<cos>\d+)$')

        # Vrf Id               : 0
        p20 = re.compile(r'^Vrf Id\s+:\s+(?P<vrf_id>\d+)$')

        # Tunnel IfId          : 65
        p21 = re.compile(r'^Tunnel IfId\s+:\s+(?P<tunnel_if_id>\d+)$')

        # Dst Ip               : 1.1.3.2
        p22 = re.compile(r'^Dst Ip\s+:\s+(?P<destination_ip>\S+)$')

        # Org Ip               : 1.1.3.1
        p23 = re.compile(r'^Org Ip\s+:\s+(?P<org_ip>\S+)$')

        # SGT count            : 0
        p24 = re.compile(r'^SGT count\s+:\s+(?P<sgt_count>\d+)$')

        # SGT Tag(s)           :
        p25 = re.compile(r'^SGT Tag\(s\)\s+:\s+(?P<sgt_tag>\S+)$')

        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                # ret_dict.update(m.groupdict())
                ret_dict['session_type'] = m.groupdict()['session_type']
                continue

            m = p2.match(line)
            if m:
                port_dict = ret_dict.setdefault('source_ports', {})
                port_dict['rx'] = m.groupdict()['rx'].split()
                port_dict['tx'] = m.groupdict()['tx'].split()
                continue

            m = p3.match(line)
            if m:
                ret_dict.setdefault('destination_ports', m.groupdict()['destination_ports'].split(' '))
                continue

            m = p4.match(line)
            if m:
                ret_dict.setdefault('source_vlans', m.groupdict()['source_vlans'].split(' '))
                continue

            m = p5.match(line)
            if m:
                ret_dict.setdefault('destination_vlans', m.groupdict()['destination_vlans'].split(' '))
                continue

            m = p6.match(line)
            if m:
                ret_dict.setdefault('source_rspan_vlan', int(m.groupdict()['source_rspan_vlan']))
                continue

            m = p7.match(line)
            if m:
                ret_dict.setdefault('destination_rspan_vlan', int(m.groupdict()['destination_rspan_vlan']))
                continue

            m = p8.match(line)
            if m:
                ret_dict.setdefault('encap', m.groupdict()['encap'])
                continue

            m = p9.match(line)
            if m:
                ret_dict.setdefault('ingress_forwarding', m.groupdict()['ingress_forwarding'])
                continue

            m = p10.match(line)
            if m:
                ret_dict.setdefault('filter_vlans', m.groupdict()['filter_vlans'])
                continue

            m = p11.match(line)
            if m:
                ret_dict.setdefault('erspan_enable', int(m.groupdict()['erspan_enable']))
                continue

            m = p12.match(line)
            if m:
                ret_dict.setdefault('erspan_hw_programmed', int(m.groupdict()['erspan_hw_programmed']))
                continue

            m = p13.match(line)
            if m:
                ret_dict.setdefault('erspan_mandatory_cfg', int(m.groupdict()['erspan_mandatory_cfg']))
                continue

            m = p14.match(line)
            if m:
                ret_dict.setdefault('erspan_id', int(m.groupdict()['erspan_id']))
                continue

            m = p15.match(line)
            if m:
                ret_dict.setdefault('gre_protocol', m.groupdict()['gre_protocol'])
                continue

            m = p16.match(line)
            if m:
                ret_dict.setdefault('mtu', int(m.groupdict()['mtu']))
                continue

            m = p17.match(line)
            if m:
                ret_dict.setdefault('ip_tos', int(m.groupdict()['ip_tos']))
                continue

            m = p18.match(line)
            if m:
                ret_dict.setdefault('ip_ttl', int(m.groupdict()['ip_ttl']))
                continue

            m = p19.match(line)
            if m:
                ret_dict.setdefault('cos', int(m.groupdict()['cos']))
                continue

            m = p20.match(line)
            if m:
                ret_dict.setdefault('vrf_id', int(m.groupdict()['vrf_id']))
                continue

            m = p21.match(line)
            if m:
                ret_dict.setdefault('tunnel_if_id', int(m.groupdict()['tunnel_if_id']))
                continue

            m = p22.match(line)
            if m:
                ret_dict.setdefault('destination_ip', m.groupdict()['destination_ip'])
                continue

            m = p23.match(line)
            if m:
                ret_dict.setdefault('org_ip', m.groupdict()['org_ip'])
                continue

            m = p24.match(line)
            if m:
                ret_dict.setdefault('sgt_count', int(m.groupdict()['sgt_count']))
                continue

            m = p25.match(line)
            if m:
                ret_dict.setdefault('sgt_tag', m.groupdict()['sgt_tag'])
                continue

        return ret_dict


class ShowPlatformSoftwareFedSwitchActiveMonitor(ShowPlatformSoftwareFedActiveMonitor):
    '''
        Parser for 'show platform software fed switch active monitor {session}'
    '''

    cli_command = 'show platform software fed switch active monitor {session}'

    def cli(self, session, output=None):
        return super().cli(session=session, output=output)


class ShowPlatformSoftwareTdlContentBpConfigSchema(MetaParser):
    '''
        Schema for 'show platform software tdl-database content bp config {mode}'
    '''
    schema = {
        'node': {
            Any(): {
                'node': int,
                Optional('domain'): int,
                Optional('mode'): str,
                Optional('router_id'): str,
                Optional('priority') : int,
            },
       }
    }

class ShowPlatformSoftwareTdlContentBpConfig(ShowPlatformSoftwareTdlContentBpConfigSchema):
    '''
        Parser for 'show platform software tdl-database content bp config {mode}'
    '''

    cli_command = 'show platform software tdl-database content bp config {mode}'

    def cli(self, mode, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(mode=mode))

        # initial variables
        ret_dict = {}

        # Node    Domain    Mode          Router-ID
        # 1       2         Aggregation
        p1=re.compile('^(?P<node>\d+)\s+(?P<domain>\d+)\s+(?P<mode>\w+)(\s+(?P<router_id>\w+))?$')

        # Node    Priority
        # 1       1
        p2 = re.compile('^(?P<node>\d+)\s+(?P<priority>\d+)$')

        for line in output.splitlines():
            line = line.strip()

            # Node    Domain    Mode          Router-ID
            # 1       2         Aggregation
            m = p1.match(line)
            if m:
                group=m.groupdict()
                node = group.pop('node')
                node_dict = ret_dict.setdefault('node', {})
                n_node_dict = node_dict.setdefault(int(node), {})

                n_node_dict.update({
                        'node': int(node),
                        'domain': int(group['domain']),
                        'mode': group['mode']})
                if group['router_id']:
                    n_node_dict.update({'router_id': group['router_id']})
                continue

            # Node    Priority
            # 1       1
            m = p2.match(line)
            if m:
                group = m.groupdict()
                node = group.pop('node')
                node_dict = ret_dict.setdefault('node', {})
                n_node_dict = node_dict.setdefault(int(node), {})
                n_node_dict.update({
                    'node': int(node),
                    'priority': int(group['priority'])
                })
                continue

        return ret_dict


# ======================================================
# Parser for 'show platform software fed {switch} active ifm interfaces vlan',
#            'show platform software fed active ifm interfaces vlan'
# ======================================================

class ShowPlatformSoftwareFedIfmInterfacesSchema(MetaParser):
    """Schema for 'show platform software fed {switch} active ifm interfaces vlan',
                  'show platform software fed active ifm interfaces vlan'"""

    schema = {
            'interfaces': {
                Any(): {
                    'if_id': str,
                    'state': str
                }
             }
    }

class ShowPlatformSoftwareFedIfmInterfaces(ShowPlatformSoftwareFedIfmInterfacesSchema):
    """Parser for 'show platform software fed {switch} active ifm interfaces vlan',
                  'show platform software fed active ifm interfaces vlan'"""

    cli_command = ['show platform software fed {switch} active ifm interfaces vlan',
                   'show platform software fed active ifm interfaces vlan']

    def cli(self, switch='', output=None):
        if output is None:
            if switch:
                out = self.device.execute(self.cli_command[0].format(switch=switch))
            else:
                out = self.device.execute(self.cli_command[1])
        else:
            out = output

        ret_dict = {}

        # Vlan10 0x0000005d READY
        p1 = re.compile(r'^(?P<interface>\S+)\s+(?P<if_id>\d+x+\w+)\s+(?P<state>[\w\s]+)$')

        for line in out.splitlines():
            line = line.strip()

            # Vlan10 0x0000005d READY
            m=p1.match(line)
            if m:
                group = m.groupdict()
                interface = group['interface']
                interface_dict = ret_dict.setdefault('interfaces', {}).setdefault(interface, {})
                interface_dict['if_id'] = group['if_id']
                interface_dict['state'] = str(group['state'])
                continue

        return ret_dict

# ======================================================
# Parser for 'show platform software fed switch active matm adjacencies '
# ======================================================
class ShowPlatformSoftwareFedSwitchActiveMatmAdjacenciesSchema(MetaParser):
    """Schema for show platform software fed switch active matm adjacencies"""
    schema = {
        'adjacencies': {
            Any(): {
                'adj_id': int,
                'adj_key': str,
                'encap': str,
                'link': str,
                'sihandle': str,
                'rihandle': str,
                'dihandle': str,
                'obj_type': str,
            },
        },
    }

class ShowPlatformSoftwareFedSwitchActiveMatmAdjacencies(ShowPlatformSoftwareFedSwitchActiveMatmAdjacenciesSchema):
    """Parser for show platform software fed switch active matm adjacencies"""

    cli_command = 'show platform software fed switch active matm adjacencies'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        # 201    89          0x100000059      VXLAN  V4     0x7fd728bf1be8   0x7fd728bf17a8   0x0              CP

        # 201    89          0x100000059      VXLAN  V4     0x7fd728bf1be8   0x7fd728bf17a8   0x0              CP
        p2 = re.compile(r"^(?P<vlan>\d+)\s+(?P<adj_id>\d+)\s+(?P<adj_key>\S+)\s+(?P<encap>\w+)\s+(?P<link>\S+)\s+(?P<sihandle>\S+)\s+(?P<rihandle>\S+)\s+(?P<dihandle>\S+)\s+(?P<obj_type>\w+)$")

        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()
            #201    89          0x100000059      VXLAN  V4     0x7fd728bf1be8   0x7fd728bf17a8   0x0              CP
            m = p2.match(line)
            if m:
                dict_val = m.groupdict()
                adjacencies = ret_dict.setdefault('adjacencies', {})
                vlan_id = int(dict_val['vlan'])
                index_adjacencies = ret_dict['adjacencies'].setdefault(vlan_id, {})
                index_adjacencies['adj_id'] = int(dict_val['adj_id'])
                index_adjacencies['adj_key'] = dict_val['adj_key']
                index_adjacencies['encap'] = dict_val['encap']
                index_adjacencies['link'] = dict_val['link']
                index_adjacencies['sihandle'] = dict_val['sihandle']
                index_adjacencies['rihandle'] = dict_val['rihandle']
                index_adjacencies['dihandle'] = dict_val['dihandle']
                index_adjacencies['obj_type'] = dict_val['obj_type']
                continue

        return ret_dict

# ======================================================
# Parser for 'show platform software fed active qos policy summary '
# ======================================================

class ShowPlatformSoftwareFedActiveQosPolicySummarySchema(MetaParser):
    """Schema for show platform software fed active qos policy summary"""

    schema = {
        'cg_id': {
            Any(): {
                'classes': int,
                'targets': int,
                'child': int,
                'cfg_err': int,
                'in_hw': int,
                'op_error': int,
                'policy_name': str,
            },
        },
    }

class ShowPlatformSoftwareFedActiveQosPolicySummary(ShowPlatformSoftwareFedActiveQosPolicySummarySchema):
    """Parser for show platform software fed active qos policy summary"""

    cli_command = 'show platform software fed active qos policy summary'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        # 15212688   22     33      0     0      33    0     system-cpp-policy
        p1 = re.compile(r"^(?P<cg_id>\d+)\s+(?P<classes>\d+)\s+(?P<targets>\d+)\s+(?P<child>\d+)\s+(?P<cfg_err>\d+)\s+(?P<in_hw>\d+)\s+(?P<op_error>\d+)\s+(?P<policy_name>\S+)$")

        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()

            # 15212688   22     33      0     0      33    0     system-cpp-policy
            m = p1.match(line)
            if m:
                dict_val = m.groupdict()
                cg_id = int(dict_val['cg_id'])
                cg_id_dict = ret_dict.setdefault('cg_id', {})
                policy_map_dict = cg_id_dict.setdefault(cg_id, {})
                policy_map_dict['classes'] = int(dict_val['classes'])
                policy_map_dict['targets'] = int(dict_val['targets'])
                policy_map_dict['child'] = int(dict_val['child'])
                policy_map_dict['cfg_err'] = int(dict_val['cfg_err'])
                policy_map_dict['in_hw'] = int(dict_val['in_hw'])
                policy_map_dict['op_error'] = int(dict_val['op_error'])
                policy_map_dict['policy_name'] = dict_val['policy_name']
                continue

        return ret_dict

# ======================================================
# Parser for 'show platform hardware fed switch active qos dscp-cos counters interface {interface} '
# ======================================================
class ShowPlatformHardwareFedSwitchActiveQosDscpCosCountersInterfaceSchema(MetaParser):
    """Schema for show platform hardware fed switch active qos dscp-cos counters interface {interface}"""
    schema = {
        'direction': {
            Any(): {
                'qos': {
                    Any(): {
                        'frames': int,
                        'bytes': int
                    }
                }
            }
        }
    }

class ShowPlatformHardwareFedSwitchActiveQosDscpCosCountersInterface(
    ShowPlatformHardwareFedSwitchActiveQosDscpCosCountersInterfaceSchema):
    """Parser for show platform hardware fed {switch} qos dscp-cos counters interface {interface}"""

    cli_command = ['show platform hardware fed {switch} {switch_var} qos dscp-cos counters interface {interface}',
                   'show platform hardware fed {switch_var} qos dscp-cos counters interface {interface}']

    def cli(self, interface, switch_var, switch="", output=None):
        if output is None:
            if switch:
                cmd = self.cli_command[0].format(switch= switch, switch_var=switch_var, interface=interface)
            else:
                cmd = self.cli_command[1].format(switch_var=switch_var, interface=interface)
            output = self.device.execute(cmd)

        # Ingress DSCP0 0             0
        # Egress DSCP0 0             0
        p1 = re.compile(r"^(?P<direction>\w+)\s+(?P<qos>\S+)\s+(?P<frames>\d+)\s+(?P<bytes>\d+)$")

        ret_dict = {}

        for line in output.splitlines():

            line = line.strip()

            # Ingress DSCP0 0             0
            # Egress DSCP0 0             0
            m = p1.match(line)
            if m:
                dict_val = m.groupdict()
                dir_dict = ret_dict.setdefault('direction', {}).setdefault(dict_val['direction'].lower(), {})
                qos_dict = dir_dict.setdefault('qos', {}).setdefault(dict_val['qos'], {})
                qos_dict['frames'] = int(dict_val['frames'])
                qos_dict['bytes'] = int(dict_val['bytes'])
                continue

        return ret_dict


# ======================================================
# Schema for 'show platform software fed switch {mode} matm stats'
# ======================================================

class ShowPlatformSoftwareFedSwitchMatmStatsSchema(MetaParser):
    """Schema for 'show platform software fed switch {mode} matm stats'"""

    schema = {
        'matm_counters': {
            Any():int
        },
    }

# ======================================================
# Parser for 'show platform software fed switch {mode} matm stats'
# ======================================================
class ShowPlatformSoftwareFedSwitchMatmStats(ShowPlatformSoftwareFedSwitchMatmStatsSchema):
    """Parser for 'show platform software fed switch {mode} matm stats'"""

    cli_command = ['show platform software fed active matm stats', 
        'show platform software fed switch {mode} matm stats']

    def cli(self, mode=None, output=None):
        if output is None:
            if mode:
                cmd = self.cli_command[1].format(mode=mode)
            else:
                cmd = self.cli_command[0]
            output = self.device.execute(cmd)

        #   Total non-cpu mac entries       : 3
        #   Mac Learn SPI Msg Count         : 0
        #   Mac Learn SPI Err Count         : 0
        p = re.compile(r'^(?P<key>[\S\s]+)\s+:\s+(?P<count>\d+)$')

        ret_dict = {}

        for line in output.splitlines():

            line = line.strip()

            #   Total non-cpu mac entries       : 3
            #   Mac Learn SPI Msg Count         : 0
            #   Mac Learn SPI Err Count         : 0
            m = p.match(line)
            if m:
                group = m.groupdict()
                key = group['key'].lower().strip().replace(" ","_").replace("-","_").replace("/","_")
                matm_dict = ret_dict.setdefault('matm_counters', {})
                matm_dict[key] = int(group['count'])
                continue

        return ret_dict

class ShowPlatformHwFedActiveQosQStatsInternalCpuPolicerSchema(MetaParser):
    """Schema for show platform hardware fed active qos queue stats internal cpu policer"""

    schema = {
        'cpu_queue_statistics': {
            Any():{
                'cpu_qid': int,
                'cpu_picidx': int,
                'cpu_queue_name': str,
                'cpu_enabled': str,
                'cpu_default_rate': int,
                'cpu_set_rate': int,
                'q_drop_bytes': int,
                'q_drop_frames': int
            }
        },
        'cpu_policer_stats': {
            Any():{
                'index': int,
                'accept_bytes': int,
                'accept_frames': int,
                'drop_bytes': int,
                'drop_frames': int
            }
        },
        'cpp_classes_qmap': {
            Any():{
                'cpp_picidx': int,
                'cpp_class': str,
                'cpp_enabled': str
            }
        },
        'sec_policer_config': {
            Any():{
                'sec_qid': int,
                'sec_level1_picidx': int,
                'sec_level2_picidx': str,
                'sec_queue_name': str,
                'sec_enabled': str,
            }
        },
        'policer_index_map': {
            Any():{
                'cpp_level2_picidx': int,
                'cpp_level1_picidx': str,
                'cpp_default_rate': int,
                'cpp_set_rate': int,
            }
        }
    }

class ShowPlatformHwFedActiveQosQStatsInternalCpuPolicer(ShowPlatformHwFedActiveQosQStatsInternalCpuPolicerSchema):
    """Parser for show platform hardware fed active qos queue stats internal cpu policer"""

    cli_command = ['show platform hardware fed {state} qos queue stats internal cpu policer',
                   'show platform hardware fed {switch} {state} qos queue stats internal cpu policer']

    def cli(self, state="active", switch=None, output=None):
        if output is None:
            if state and switch:
                cmd = self.cli_command[1].format(state=state,switch=switch)
            else:
                cmd = self.cli_command[0].format(state=state)
            output = self.device.execute(cmd)

        # 0    11     DOT1X Auth                  Yes     1000      1000     0            0
        p1 = re.compile(r"^(?P<cpu_qid>\d+)\s+(?P<cpu_picidx>\d+)\s+(?P<cpu_queue_name>[\w\s]+)\s+(?P<cpu_enabled>Yes|No)\s+(?P<cpu_default_rate>\d+)\s+(?P<cpu_set_rate>\d+)\s+(?P<q_drop_bytes>\d+)\s+(?P<q_drop_frames>\d+)$")

        # 1          281306           1403            0             0
        p2 = re.compile(r"^(?P<index>\d+)\s+(?P<accept_bytes>\d+)\s+(?P<accept_frames>\d+)\s+(?P<drop_bytes>\d+)\s+(?P<drop_frames>\d+)$")

        # 20        :   1  2  8                        17000     17000
        p3 = re.compile(r"^(?P<cpp_level2_picidx>\d+)\s+:(?P<cpp_level1_picidx>[\w\s]+)\s+(?P<cpp_default_rate>[\d]+)\s+(?P<cpp_set_rate>[\d]+)$")

        # 0      system-cpp-police-data                   :  ICMP GEN/ BROADCAST/ ICMP Redirect/
        p4 = re.compile(r"^(?P<cpp_picidx>\d+)\s+(?P<cpp_class>[\-\w\s]+)\s+:(?P<cpp_enabled>[\-\w\s\/]+)$")

        # 30   9       21      MCAST Data                  Yes
        # 31   3       -       Gold Pkt                    No
        p5 = re.compile(r"^(?P<sec_qid>\d+)\s+(?P<sec_level1_picidx>\d+)\s+(?P<sec_level2_picidx>[\-\d]+)\s+(?P<sec_queue_name>[\w\s]+)\s+(?P<sec_enabled>Yes|No)$")

        ret_dict = {}
        for line in output.splitlines():
            line = line.strip()

            # 0    11     DOT1X Auth                  Yes     1000      1000     0            0
            m= p1.match(line)
            if m:
                dict_val = m.groupdict()
                template_var=dict_val['cpu_queue_name'].strip()
                if 'cpu_queue_statistics' not in ret_dict:
                    cpu_queue_statistics = ret_dict.setdefault('cpu_queue_statistics', {})
                if template_var not in ret_dict['cpu_queue_statistics']:
                    cpu_queue_stats = ret_dict['cpu_queue_statistics'].setdefault(template_var, {})
                cpu_queue_stats['cpu_qid'] = int(dict_val['cpu_qid'])
                cpu_queue_stats['cpu_picidx'] = int(dict_val['cpu_picidx'])
                cpu_queue_stats['cpu_queue_name'] = dict_val['cpu_queue_name'].strip()
                cpu_queue_stats['cpu_enabled'] = dict_val['cpu_enabled']
                cpu_queue_stats['cpu_default_rate'] = int(dict_val['cpu_default_rate'])
                cpu_queue_stats['cpu_set_rate'] = int(dict_val['cpu_set_rate'])
                cpu_queue_stats['q_drop_bytes'] = int(dict_val['q_drop_bytes'])
                cpu_queue_stats['q_drop_frames'] = int(dict_val['q_drop_frames'])
                continue

            # 1          281306           1403            0             0
            m= p2.match(line)
            if m:
                dict_val = m.groupdict()
                if 'cpu_policer_stats' not in ret_dict:
                    cpu_policer_stats = ret_dict.setdefault('cpu_policer_stats', {})
                template_var=int(dict_val['index'])
                if template_var not in ret_dict['cpu_policer_stats']:
                    cpu_policer_stats = ret_dict['cpu_policer_stats'].setdefault(template_var, {})
                cpu_policer_stats['index'] = int(dict_val['index'])
                cpu_policer_stats['accept_bytes'] = int(dict_val['accept_bytes'])
                cpu_policer_stats['accept_frames'] = int(dict_val['accept_frames'])
                cpu_policer_stats['drop_bytes'] = int(dict_val['drop_bytes'])
                cpu_policer_stats['drop_frames'] = int(dict_val['drop_frames'])
                continue

            # 20        :   1  2  8                        17000     17000
            m= p3.match(line)
            if m:
                dict_val = m.groupdict()
                if 'policer_index_map' not in ret_dict:
                    policer_index_map = ret_dict.setdefault('policer_index_map', {})
                template_var=dict_val['cpp_level2_picidx']
                if template_var not in ret_dict['policer_index_map']:
                    policer_index_map = ret_dict['policer_index_map'].setdefault(template_var, {})
                policer_index_map['cpp_level2_picidx'] = int(dict_val['cpp_level2_picidx'])
                policer_index_map['cpp_level1_picidx'] = dict_val['cpp_level1_picidx']
                policer_index_map['cpp_default_rate'] = int(dict_val['cpp_default_rate'])
                policer_index_map['cpp_set_rate'] = int(dict_val['cpp_set_rate'])
                continue

            # 0      system-cpp-police-data                   :  ICMP GEN/ BROADCAST/ ICMP Redirect/
            m= p4.match(line)
            if m:
                dict_val = m.groupdict()
                if 'cpp_classes_qmap' not in ret_dict:
                    cpp_classes_qmap = ret_dict.setdefault('cpp_classes_qmap', {})
                template_var=dict_val['cpp_picidx'].strip()
                if template_var not in ret_dict['cpp_classes_qmap']:
                    cpp_classes_qmap = ret_dict['cpp_classes_qmap'].setdefault(template_var, {})
                cpp_classes_qmap['cpp_picidx'] = int(dict_val['cpp_picidx'])
                cpp_classes_qmap['cpp_class'] = dict_val['cpp_class'].strip()
                cpp_classes_qmap['cpp_enabled'] = dict_val['cpp_enabled']
                continue

            # 31   3       -       Gold Pkt                    No
            m= p5.match(line)
            if m:
                dict_val = m.groupdict()
                if 'sec_policer_config' not in ret_dict:
                    sec_policer_config = ret_dict.setdefault('sec_policer_config', {})
                template_var=dict_val['sec_qid'].strip()
                if template_var not in ret_dict['sec_policer_config']:
                    sec_policer_config = ret_dict['sec_policer_config'].setdefault(template_var, {})
                sec_policer_config['sec_qid'] = int(dict_val['sec_qid'])
                sec_policer_config['sec_level1_picidx'] = int(dict_val['sec_level1_picidx'])
                sec_policer_config['sec_level2_picidx'] = dict_val['sec_level2_picidx']
                sec_policer_config['sec_queue_name'] = dict_val['sec_queue_name'].strip()
                sec_policer_config['sec_enabled'] = dict_val['sec_enabled']
                continue

        return ret_dict

# ======================================================
# Parser for 'show platform software install-manager chassis active r0 operation history summary'
# ======================================================

class ShowPlatformSoftwareInstallManagerChassisActiveR0OperationHistorySummary(ShowPlatformSoftwareInstallManagerRpActiveOperationHistorySummary):
    '''
        Parser for 'show platform software install-manager chassis active r0 operation history summary'
    '''

    cli_command = 'show platform software install-manager chassis active r0 operation history summary'

    def cli(self,output=None):
        if output is None:
            output = self.device.execute(self.cli_command)
        return super().cli(output=output)

# ==========================================================================================
# Parser Schema for 'show platform software fed active vt hardware if-id'
# ==========================================================================================

class ShowPlatformSoftwareFedActiveVtHardwareIfIdSchema(MetaParser):
    """
    Schema for
        * 'show platform software fed active vt hardware if-id {if_id}'
    """

    schema = {
        'mapping': {
            Any(): {
                'vlan_id': int,
                'translated_vlan_id': int,
            }
        }
    }

# ==========================================================================================
# Parser for 'show platform software fed active vt hardware if-id'
# ==========================================================================================

class ShowPlatformSoftwareFedActiveVtHardwareIfId(ShowPlatformSoftwareFedActiveVtHardwareIfIdSchema):
    """
    Parser for
        * 'show platform software fed active vt hardware if-id {if_id}'
    """
    cli_command = 'show platform software fed active vt hardware if-id {if_id}'

    def cli(self, if_id, output=None):
        cmd = self.cli_command.format(if_id=if_id)

        if output is None:
            output = self.device.execute(cmd)

        ret_dict = {}
        # Forward Mapping
        # Reverse Mapping
        p1 = re.compile(r'^(?P<mapping>\S+) Mapping$')

        # 40            30
        p2 = re.compile(r'^(?P<vlan_id>\d+)\s*(?P<translated_id>\d+)$')

        for line in output.splitlines():
            line = line.strip()
            # Forward Mapping
            # Reverse Mapping
            m = p1.match(line)
            if m:
                group = m.groupdict()
                root_dict = ret_dict.setdefault('mapping',{}).setdefault(group['mapping'].lower(),{})
                continue

            # 40            30
            m = p2.match(line)
            if m:
                group = m.groupdict()
                root_dict['vlan_id'] = int(group['vlan_id'])
                root_dict['translated_vlan_id'] = int(group['translated_id'])

        return ret_dict


class ShowPlatformSoftwareFedActiveMonitorSchema(MetaParser):
    '''
        Schema for 'show platform software fed active monitor {session}'
    '''
    schema = {
        'session_type': str,
        'source_ports': {
            'rx': list,
            'tx': list
        },
        Optional('destination_ports'): list,
        Optional('source_vlans'): list,
        Optional('destination_vlans'): list,
        'source_rspan_vlan': int,
        'destination_rspan_vlan': int,
        'encap': str,
        'ingress_forwarding': str,
        Optional('filter_vlans'): list,
        'erspan_enable': int,
        'erspan_hw_programmed': int,
        'erspan_mandatory_cfg': int,
        'erspan_id': int,
        Optional('gre_protocol'): str,
        'mtu': int,
        'ip_tos': int,
        'ip_ttl': int,
        'cos': int,
        'vrf_id': int,
        'tunnel_if_id': int,
        'destination_ip': str,
        'org_ip': str,
        Optional('sgt_count'): int,
        Optional('sgt_tag'): str
    }


class ShowPlatformSoftwareFedActiveMonitor(ShowPlatformSoftwareFedActiveMonitorSchema):
    '''
        Parser for 'show platform software fed active monitor {session}'
    '''

    cli_command = 'show platform software fed active monitor {session}'

    def cli(self, session, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(session=session))

        # Session Type         : ERSPAN Source Session
        p1 = re.compile(r'^Session Type\s+:\s+(?P<session_type>[\w\s]+)$')

        # Source Ports         : RX: GigabitEthernet1/0/1 TenGigabitEthernet1/1/3 TX: None
        p2 = re.compile(r'^Source Ports\s+: RX:\s+(?P<rx>[\w\/\s]+)\sTX:\s+(?P<tx>[\w\/\s]+)$')

        # Destination Ports    : TwoGigabitEthernet1/0/13
        p3 = re.compile(r'^Destination Ports\s+:\s+(?P<destination_ports>[\w\/\s]+(?<!None))$')

        # Source VLANs         : None
        p4 = re.compile(r'^Source VLANs\s+:\s+(?P<source_vlans>[\w\-\d\s]+(?<!None))$')

        # Destination VLANs    : None
        p5 = re.compile(r'^Destination VLANs\s+:\s+(?P<destination_vlans>[\w\-\d\s]+(?<!None))$')

        # Source RSPAN VLAN    : 0
        p6 = re.compile(r'^Source RSPAN VLAN\s+:\s+(?P<source_rspan_vlan>\d+)$')

        # DST RSPAN VLAN       : 0
        p7 = re.compile(r'^DST RSPAN VLAN\s+:\s+(?P<destination_rspan_vlan>\d+)$')

        # Encap                : Native
        p8 = re.compile(r'^Encap\s+:\s+(?P<encap>\S+)$')

        # Ingress Forwarding   : Disabled
        p9 = re.compile(r'^Ingress Forwarding\s+:\s+(?P<ingress_forwarding>\S+)$')

        # Filter VLANs         : None
        p10 = re.compile(r'^Filter VLANs\s+:\s+(?P<filter_vlans>[\d\s]+(?<!None))$')

        # ERSPAN Enable        : 1
        p11 = re.compile(r'^ERSPAN Enable\s+:\s+(?P<erspan_enable>\d+)$')

        # ERSPAN Hw Programmed : 1
        p12 = re.compile(r'^ERSPAN Hw Programmed\s+:\s+(?P<erspan_hw_programmed>\d+)$')

        # ERSPAN Mandatory Cfg : 1
        p13 = re.compile(r'^ERSPAN Mandatory Cfg\s+:\s+(?P<erspan_mandatory_cfg>\d+)$')

        # ERSPAN Id            : 3
        p14 = re.compile(r'^ERSPAN Id\s+:\s+(?P<erspan_id>\d+)$')

        # Gre Prot             : 88be
        p15 = re.compile(r'^Gre Prot\s+:\s+(?P<gre_protocol>\S+)$')

        # MTU                  : 9000
        p16 = re.compile(r'^MTU\s+:\s+(?P<mtu>\d+)$')

        # Ip Tos               : 0 (DSCP:0)
        p17 = re.compile(r'^Ip Tos\s+:\s+(?P<ip_tos>\d+).+$')

        # Ip Ttl               : 255
        p18 = re.compile(r'^Ip Ttl\s+:\s+(?P<ip_ttl>\d+)$')

        # Cos                  : 0
        p19 = re.compile(r'^Cos\s+:\s+(?P<cos>\d+)$')

        # Vrf Id               : 0
        p20 = re.compile(r'^Vrf Id\s+:\s+(?P<vrf_id>\d+)$')

        # Tunnel IfId          : 65
        p21 = re.compile(r'^Tunnel IfId\s+:\s+(?P<tunnel_if_id>\d+)$')

        # Dst Ip               : 1.1.3.2
        p22 = re.compile(r'^Dst Ip\s+:\s+(?P<destination_ip>\S+)$')

        # Org Ip               : 1.1.3.1
        p23 = re.compile(r'^Org Ip\s+:\s+(?P<org_ip>\S+)$')

        # SGT count            : 0
        p24 = re.compile(r'^SGT count\s+:\s+(?P<sgt_count>\d+)$')

        # SGT Tag(s)           :
        p25 = re.compile(r'^SGT Tag\(s\)\s+:\s+(?P<sgt_tag>\S+)$')

        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()

            m = p1.match(line)
            if m:
                # ret_dict.update(m.groupdict())
                ret_dict['session_type'] = m.groupdict()['session_type']
                continue

            m = p2.match(line)
            if m:
                port_dict = ret_dict.setdefault('source_ports', {})
                port_dict['rx'] = m.groupdict()['rx'].split()
                port_dict['tx'] = m.groupdict()['tx'].split()
                continue

            m = p3.match(line)
            if m:
                ret_dict.setdefault('destination_ports', m.groupdict()['destination_ports'].split(' '))
                continue

            m = p4.match(line)
            if m:
                ret_dict.setdefault('source_vlans', m.groupdict()['source_vlans'].split(' '))
                continue

            m = p5.match(line)
            if m:
                ret_dict.setdefault('destination_vlans', m.groupdict()['destination_vlans'].split(' '))
                continue

            m = p6.match(line)
            if m:
                ret_dict.setdefault('source_rspan_vlan', int(m.groupdict()['source_rspan_vlan']))
                continue

            m = p7.match(line)
            if m:
                ret_dict.setdefault('destination_rspan_vlan', int(m.groupdict()['destination_rspan_vlan']))
                continue

            m = p8.match(line)
            if m:
                ret_dict.setdefault('encap', m.groupdict()['encap'])
                continue

            m = p9.match(line)
            if m:
                ret_dict.setdefault('ingress_forwarding', m.groupdict()['ingress_forwarding'])
                continue

            m = p10.match(line)
            if m:
                ret_dict.setdefault('filter_vlans', m.groupdict()['filter_vlans'])
                continue

            m = p11.match(line)
            if m:
                ret_dict.setdefault('erspan_enable', int(m.groupdict()['erspan_enable']))
                continue

            m = p12.match(line)
            if m:
                ret_dict.setdefault('erspan_hw_programmed', int(m.groupdict()['erspan_hw_programmed']))
                continue

            m = p13.match(line)
            if m:
                ret_dict.setdefault('erspan_mandatory_cfg', int(m.groupdict()['erspan_mandatory_cfg']))
                continue

            m = p14.match(line)
            if m:
                ret_dict.setdefault('erspan_id', int(m.groupdict()['erspan_id']))
                continue

            m = p15.match(line)
            if m:
                ret_dict.setdefault('gre_protocol', m.groupdict()['gre_protocol'])
                continue

            m = p16.match(line)
            if m:
                ret_dict.setdefault('mtu', int(m.groupdict()['mtu']))
                continue

            m = p17.match(line)
            if m:
                ret_dict.setdefault('ip_tos', int(m.groupdict()['ip_tos']))
                continue

            m = p18.match(line)
            if m:
                ret_dict.setdefault('ip_ttl', int(m.groupdict()['ip_ttl']))
                continue

            m = p19.match(line)
            if m:
                ret_dict.setdefault('cos', int(m.groupdict()['cos']))
                continue

            m = p20.match(line)
            if m:
                ret_dict.setdefault('vrf_id', int(m.groupdict()['vrf_id']))
                continue

            m = p21.match(line)
            if m:
                ret_dict.setdefault('tunnel_if_id', int(m.groupdict()['tunnel_if_id']))
                continue

            m = p22.match(line)
            if m:
                ret_dict.setdefault('destination_ip', m.groupdict()['destination_ip'])
                continue

            m = p23.match(line)
            if m:
                ret_dict.setdefault('org_ip', m.groupdict()['org_ip'])
                continue

            m = p24.match(line)
            if m:
                ret_dict.setdefault('sgt_count', int(m.groupdict()['sgt_count']))
                continue

            m = p25.match(line)
            if m:
                ret_dict.setdefault('sgt_tag', m.groupdict()['sgt_tag'])
                continue

        return ret_dict


class ShowPlatformSoftwareFedSwitchActiveMonitor(ShowPlatformSoftwareFedActiveMonitor):
    '''
        Parser for 'show platform software fed switch active monitor {session}'
    '''

    cli_command = 'show platform software fed switch active monitor {session}'

    def cli(self, session, output=None):
        return super().cli(session=session, output=output)



class ShowPlatformSoftwareBpCrimsonStatisticsSchema(MetaParser):
    """
    Schema for show platform software bp crimson statistics
    """
    schema = {
        'bp_crimson_statistics':{            
            'initialized': str,
            'config_database_init_d': str,
            'config_db_persist': str,
            'config_db_restorable': str,
            'config_lock_mgr_dbid': int,
            'oper_database_init_d': str,
            'oper_lock_mgr_dbid': int,
            'garbage_collections': int,         
        },
        Optional('bp_svl_crimson_statistics'):{            
            'config_notify_mgr_id': int,
            'config_dyn_tables_reg_d': int,
            'config_dyn_reg_failures': int,
            'config_dyn_tables_dereg_d': int,
            'config_dereg_deferred': int,
            'config_dereg_failures': int,
            'config_table_updates': int,
            'config_applied': int,
            'config_skipped': int,
            'oper_notify_mgr_dbid': int,
            'oper_dyn_tables_reg_d': int,
            'oper_dyn_reg_failures': int,
            'oper_dyn_tables_dereg_d': int,
            'oper_dereg_s_deferred': int,
            'oper_dereg_failures': int,
            'oper_table_updates': int,
            'dyn_table_failures': int,
            'dyn_table_dereg_failures': int,
            'pending_notifications': int,
            'notifications_highwater': int,
            'notifications_processed': int,
            'notification_failures': int,
        },
        Optional('bp_remote_db_statistics'):{
            'get_requests':{
                'total_requests': int,
                'pending_requests': int,
                'timed_out_requests': int,
                'failed_requests': int,
            },
            'set_requests':{
                'total_requests': int,
                'pending_requests': int,
                'timed_out_requests': int,
                'failed_requests': int,
            },
            'in_progress_requests':{
                'type': str,
                'db_id': int,
                'batch_id': int,
                'op_id': int,
                'task_pid': int,
            },
            Optional('dbal_response_time'):{
                'max': int,
            },
            Optional('record_free_failures'):{
                'total_failures':int,
            },
            
        }
 }

class ShowPlatformSoftwareBpCrimsonStatistics(ShowPlatformSoftwareBpCrimsonStatisticsSchema):
    """ Parser for show platform software bp crimson statistics"""

    cli_command = 'show platform software bp crimson statistics'

    def cli(self, output=None):
        # excute command to get output
        output = self.device.execute(self.cli_command)

        # initial variables
        ret_dict = {}

        # BP Crimson Statistics
        p1 = re.compile('^(?P<bp_crimson_statistics>BP Crimson Statistics)$')

        # Regexp  for  all the  lines  which fals in the below  pattern
		# Initialized            : Yes
        p2 = re.compile('^(?P<description>[\w\'\s]+)\:\s+(?P<value>\w+)$')

        # BP SVL Crimson Statistics
        p3 = re.compile('^(?P<bp_svl_crimson_statistics>BP SVL Crimson Statistics)$')
		
		# BP Remote DB Statistics
        p4 = re.compile('^(?P<bp_remote_db_statistics>BP Remote DB Statistics)$')
        
		# GET Requests:
        p5 = re.compile('^(?P<get_requests>GET Requests\:)$')

		# SET Requests:
        p6 = re.compile('^(?P<set_requests>SET Requests\:)$')
		
		# In Progress Requests: 
        p7 = re.compile('^(?P<in_progress_requests>In Progress Requests\:)$')
		
		# DBAL Response Time:
        p8 = re.compile('^(?P<dbal_response_time>DBAL Response Time\:)$')

		# Record Free Failures:
        p9 = re.compile('^(?P<record_free_failures>Record Free Failures\:)$')
		
		#  MAX (ms)         : 49
        p10 = re.compile('^\s*MAX +\(ms\) +\:\s*(?P<max>\d+)$')


        for line in output.splitlines():
            line=line.strip()
            
			# BP Crimson Statistics
            m=p1.match(line)
            if m:
                group=m.groupdict()
                root_dict = ret_dict.setdefault('bp_crimson_statistics',{})
                continue

            # Initialized            : Yes
            m=p2.match(line)
            if m:
                group=m.groupdict()
                if group['value'].isdigit():
                    group['value'] = int(group['value'])
                root_dict[group['description'].strip().lower().replace(' ','_').replace('"','').replace('\'','_')] = group['value']
                continue

            # BP SVL Crimson Statistics
            m=p3.match(line)
            if m:
                group=m.groupdict()
                root_dict = ret_dict.setdefault('bp_svl_crimson_statistics',{})
                continue
			
			# BP Remote DB Statistics
            m = p4.match(line)
            if m:
                group=m.groupdict()
                root_dict = ret_dict.setdefault('bp_remote_db_statistics',{})
                continue
            
			# GET Requests:
            m = p5.match(line)
            if m:
                group=m.groupdict()
                root_dict = ret_dict.setdefault('bp_remote_db_statistics',{}).setdefault('get_requests', {})
                continue
			
			# SET Requests:
            m = p6.match(line)
            if m:
                group=m.groupdict()
                root_dict = ret_dict.setdefault('bp_remote_db_statistics',{}).setdefault('set_requests', {})
                continue
			
			# In Progress Requests: 
            m = p7.match(line)
            if m:
                group=m.groupdict()
                root_dict = ret_dict.setdefault('bp_remote_db_statistics',{}).setdefault('in_progress_requests', {})
                continue
			
			# DBAL Response Time:
            m = p8.match(line)
            if m:
                group=m.groupdict()
                root_dict = ret_dict.setdefault('bp_remote_db_statistics',{}).setdefault('dbal_response_time', {})
                continue

            # Record Free Failures:
            m = p9.match(line)
            if m:
                group=m.groupdict()
                root_dict = ret_dict.setdefault('bp_remote_db_statistics',{}).setdefault('record_free_failures', {})
                continue

            #  MAX (ms)         : 49
            m = p10.match(line)
            if m:
                group=m.groupdict()
                root_dict.update({'max' : int(group['max'])})
                continue

        return ret_dict


class ShowPlatformSoftwareNodeClusterManagerSwitchB0LocalSchema(MetaParser):
    """
    Schema for show platform software node cluster-manager switch {mode} B0 local
    """
    schema = {        
        'local_node_number': int,
        'node_status_is': str,
        'tunnel_status_is': str,
        'node_role_is': str,
        'mac_address_is': str,
        'slot_number_is': int,
        'priority_set_to': int,
        'leader_node_num_is': int,
        'follower_node_is': int,
        'total_node_present_in_cluster': int,
    }

class ShowPlatformSoftwareNodeClusterManagerSwitchB0Local(ShowPlatformSoftwareNodeClusterManagerSwitchB0LocalSchema):
    """ Parser for show platform software node cluster-manager switch {mode} B0 local"""

    cli_command = 'show platform software node cluster-manager switch {mode} B0 local'

    def cli(self, mode, output=None): 
        if output is None:
            output = self.device.execute(self.cli_command.format(mode=mode))

        # initial variables
        ret_dict = {}
        #p1 = re.compile('^(?P<node_description>[\w\s]+)\: (?P<status>.*)$')
		# Local Node Number: 1
        p1 = re.compile('^Local +Node +Number\: +(?P<local_node_number>\d+)$')
        
		# Node status is: NODE_STATUS_UP
        p2 = re.compile('^Node +status +is\: +(?P<node_status_is>.*)$')
        
		# Tunnel status is: NODE_TUNNEL_UP
        p3 = re.compile('^Tunnel +status +is\: +(?P<tunnel_status_is>.*)$')
		
		# Node role is: CLUSTER_NODE_ROLE_LEADER
        p4 = re.compile('^Node +role +is\: +(?P<node_role_is>.*)$')
		
		# MAC address is : 64 181 193 255 238 0
        p5 = re.compile('^MAC +address +is +\: +(?P<mac_address_is>.*)$')

		# Slot number is : 0
        p6 = re.compile('^Slot +number +is +\: +(?P<slot_number_is>\d+)$')
		
		# priority set to: 1
        p7 = re.compile('^priority +set +to\: +(?P<priority_set_to>\d+)$')
		
		# Leader node num is: 1
        p8 = re.compile('^Leader +node +num is\: +(?P<leader_node_num_is>\d+)$')
		
		# Follower node is: 2
        p9 = re.compile('^Follower +node +is\: +(?P<follower_node_is>\d+)$')
		
		# Total node present in cluster: 2
        p10 = re.compile('^Total +node +present +in +cluster\: +(?P<total_node_present_in_cluster>\d+)$')




        for line in output.splitlines():
            line = line.strip()

			# Local Node Number: 1
            m = p1.match(line)
            if m:
                group = m.groupdict()               
                ret_dict['local_node_number'] = int (group['local_node_number'])
                continue
			
			# Node status is: NODE_STATUS_UP
            m = p2.match(line)
            if m:
                group = m.groupdict()
                ret_dict['node_status_is'] = group['node_status_is']
                continue
			
			# Tunnel status is: NODE_TUNNEL_UP
            m = p3.match(line)
            if m:
                group = m.groupdict()
                ret_dict['tunnel_status_is'] = group['tunnel_status_is']
                continue
			
			# Node role is: CLUSTER_NODE_ROLE_LEADER
            m = p4.match(line)
            if m:
                group = m.groupdict()
                ret_dict['node_role_is'] = group['node_role_is']
                continue
			
			# MAC address is : 64 181 193 255 238 0
            m = p5.match(line)
            if m:
                group = m.groupdict()
                ret_dict['mac_address_is'] = group['mac_address_is']
                continue
			
			# Slot number is : 0
            m = p6.match(line)
            if m:
                group = m.groupdict()
                ret_dict['slot_number_is'] = int(group['slot_number_is'])
                continue
			
			# priority set to: 1
            m = p7.match(line)
            if m:
                group = m.groupdict()
                ret_dict['priority_set_to'] = int(group['priority_set_to'])
                continue
			
			# Leader node num is: 1
            m = p8.match(line)
            if m:
                group = m.groupdict()
                ret_dict['leader_node_num_is'] = int(group['leader_node_num_is'])
                continue
			
			# Follower node is: 2
            m = p9.match(line)
            if m:
                group = m.groupdict()
                ret_dict['follower_node_is'] = int(group['follower_node_is'])
                continue
			
			# Total node present in cluster: 2
            m = p10.match(line)
            if m:
                group = m.groupdict()
                ret_dict['total_node_present_in_cluster'] = int(group['total_node_present_in_cluster'])
                continue

        return ret_dict



# ======================================================
# Parser for 'show platform software fed switch active matm adjacencies '
# ======================================================

class ShowPlatformSoftwareFedSwitchActiveMatmAdjacenciesSchema(MetaParser):
    """Schema for show platform software fed switch active matm adjacencies"""
    schema = {
        'adjacencies': {
            Any(): {
                'adj_id': int,
                'adj_key': str,
                'encap': str,
                'link': str,
                'sihandle': str,
                'rihandle': str,
                'dihandle': str,
                'obj_type': str,
            },
        },
    }

class ShowPlatformSoftwareFedSwitchActiveMatmAdjacencies(ShowPlatformSoftwareFedSwitchActiveMatmAdjacenciesSchema):
    """Parser for show platform software fed switch active matm adjacencies"""

    cli_command = 'show platform software fed switch active matm adjacencies'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)


        # 201    89          0x100000059      VXLAN  V4     0x7fd728bf1be8   0x7fd728bf17a8   0x0              CP
        p2 = re.compile(r"^(?P<vlan>\d+)\s+(?P<adj_id>\d+)\s+(?P<adj_key>\S+)\s+(?P<encap>\w+)\s+(?P<link>\S+)\s+(?P<sihandle>\S+)\s+(?P<rihandle>\S+)\s+(?P<dihandle>\S+)\s+(?P<obj_type>\w+)$")

        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()
            #201    89          0x100000059      VXLAN  V4     0x7fd728bf1be8   0x7fd728bf17a8   0x0              CP
            m = p2.match(line)
            if m:
                dict_val = m.groupdict()
                adjacencies = ret_dict.setdefault('adjacencies', {})
                vlan_id = int(dict_val['vlan'])
                index_adjacencies = ret_dict['adjacencies'].setdefault(vlan_id, {})
                index_adjacencies['adj_id'] = int(dict_val['adj_id'])
                index_adjacencies['adj_key'] = dict_val['adj_key']
                index_adjacencies['encap'] = dict_val['encap']
                index_adjacencies['link'] = dict_val['link']
                index_adjacencies['sihandle'] = dict_val['sihandle']
                index_adjacencies['rihandle'] = dict_val['rihandle']
                index_adjacencies['dihandle'] = dict_val['dihandle']
                index_adjacencies['obj_type'] = dict_val['obj_type']
                continue

        return ret_dict


# ======================================================
# Parser for 'show platform hardware fed switch active qos dscp-cos counters interface {interface} '
# ======================================================
class ShowPlatformHardwareFedSwitchActiveQosDscpCosCountersInterfaceSchema(MetaParser):
    """Schema for show platform hardware fed switch active qos dscp-cos counters interface {interface}"""


# =====================================================================
# Super Parser for:
#   * 'show platform software fed {switch} {mode} qos interface {interface} ingress npd detailed',
#   * 'show platform software fed {mode} qos interface {interface} ingress npd detailed',
#   * 'show platform software fed {switch} {mode} qos interface {interface} ingress npd',
#   * 'show platform software fed {mode} qos interface {interface} ingress npd',
#   * 'show platform software fed {switch} {mode} qos interface {interface} egress sdk detailed',
#   * 'show platform software fed {mode} qos interface {interface} egress sdk detailed',
#   * 'show policy-map target service-group {num}',
#   * 'show policy-map control-plane'
#   * 'show policy-map interface',
# =====================================================================
class ShowPlatformSoftwareFedQosInterfaceSuperParserSchema(MetaParser):
    """Schema for show platform software fed {switch} {mode} qos interface {interface} ingress npd detailed"""
    schema = {
        Optional('interface'): {
            Any(): {
                'cgid': str,
                'no_of_classes': int,
                'tcg_ref_count': int,
                'filter_state': str,
                'vmr_state': str
            }
        },
        'qos_profile_information': {
            'oid': str,
            'ref_count': int,
            'no_of_counter': int,
            Optional('no_of_meters'): int,
            Optional('marking_source'): str,
            'tunnel_mode': str,
            'need_filter_table_update': str,
            Optional('dscp'): {
                Any(): {
                    'remap': int,
                    Optional('encap'): int,
                    Optional('etos'): int,
                    Optional('qos_group'): int,
                    Optional('epcp'): int,
                    Optional('tc'): int,
                    Optional('eexp'): int,
                    Optional('ile'): str,
                    Optional('dp'): str,
                    Optional('meter'): str,
                    Optional('counteroffset'): int,
                    Optional('mc_offset'): int
                }
            },
            Optional('cos_dei'): {
                Any(): {
                    'remap': int,
                    Optional('encap'): int,
                    Optional('etos'): int,
                    Optional('qos_group'): int,
                    Optional('epcp'): int,
                    Optional('tc'): int,
                    Optional('eexp'): int,
                    Optional('ile'): str,
                    Optional('dp'): str,
                    Optional('meter'): str,
                    Optional('counteroffset'): int,
                    Optional('mc_offset'): int
                }
            },
            Optional('exp'): {
                Any(): {
                    'remap': int,
                    Optional('encap'): int,
                    Optional('etos'): int,
                    Optional('qos_group'): int,
                    Optional('epcp'): int,
                    Optional('tc'): int,
                    Optional('eexp'): int,
                    Optional('ile'): str,
                    Optional('dp'): str,
                    Optional('meter'): str,
                    Optional('counteroffset'): int,
                    Optional('mc_offset'): int
                }
            }
        },
        Optional('markdown_table'): {
            'oid': str,
            'dscp': {
                Any(): {
                    'green': int,
                    'yellow': int,
                    'red': int
                }
            },
            'pcpdei': {
                Any(): {
                    'green': int,
                    'yellow': int,
                    'red': int
                }
            },
            'exp': {
                Any(): {
                    'green': int,
                    'yellow': int,
                    'red': int
                }
            },
            'encapexp': {
                Any(): {
                    'green': int,
                    'yellow': int,
                    'red': int
                }
            }
        },
        Optional('ipv4_acl'):{
            'oid': str,
            'number_of_aces': int,
            Optional('ace'): {
                Any(): {
                    'class_id': str,
                    'ipv4_src_address': str,
                    'ipv4_src_mask': str,
                    'ipv4_dst_address': str,
                    'ipv4_dst_mask': str,
                    'protocol': str,
                    'protocol_mask': str,
                    'dscp': str,
                    'dscp_mask': str,
                    'ttl_start': str,
                    'ttl_end': str,
                    'tcp_flags': str,
                    'tcp_mask': str,
                    'ip_flags': str,
                    'ip_mask': str,
                    'src_port_start': str,
                    'src_port_end': str,
                    'dst_port_start': str,
                    'dst_port_end': str,
                    Optional('result_action'): {
                        'remark_value': str,
                        'encap_value': str,
                        'qos_group': str,
                        'traffic_class': str,
                        'drop_precedence': str,
                        'overwrite_phb': str,
                        'overwrite_qos_group': str,
                        'overwrite_encap': str,
                        'overwrite_fwd_tag': str,
                        'meter_enabled': str,
                        'meter_counter_offset': str
                    }
                }
            }
        },
        Optional('ipv6_acl'):{
            'oid': str,
            'number_of_aces': int,
            Optional('ace'): {
                Any(): {
                    'class_id': str,
                    'ipv6_src_address': str,
                    'ipv6_src_mask': str,
                    'ipv6_dst_address': str,
                    'ipv6_dst_mask': str,
                    'protocol': str,
                    'protocol_mask': str,
                    'dscp': str,
                    'dscp_mask': str,
                    'ttl_start': str,
                    'ttl_end': str,
                    'tcp_flags': str,
                    'tcp_mask': str,
                    'ip_flags': str,
                    'ip_mask': str,
                    'src_port_start': str,
                    'src_port_end': str,
                    'dst_port_start': str,
                    'dst_port_end': str,
                    Optional('result_action'): {
                        'remark_value': str,
                        'encap_value': str,
                        'qos_group': str,
                        'traffic_class': str,
                        'drop_precedence': str,
                        'overwrite_phb': str,
                        'overwrite_qos_group': str,
                        'overwrite_encap': str,
                        'overwrite_fwd_tag': str,
                        'meter_enabled': str,
                        'meter_counter_offset': str
                    }
                }
            }
        },
        Optional('bind_information'): {
            'port_type': str,
            Optional('iqp_counter_size'): int,
            Optional('iqp_counter_oid'): str,
            Optional('eqp_counter_size'): int,
            Optional('eqp_counter_oid'): str,
            Optional('meter_type'): str,
            Optional('meter_set_oid'): str,
            Optional('no_of_meters'): int,
            'system_port_oid': str,
            'port_oid': str,
            'speed': int,
            'port_internal_state': str,
            Optional('meter_set_info'): {
                Any(): {
                    'cir': int,
                    'eir': int,
                    'profile_oid': str,
                    'action_profile_oid': str
                }
            }
        }
    }


# =====================================================================
# Super Parser for:
#   * 'show platform software fed {switch} {mode} qos interface {interface} ingress npd detailed',
#   * 'show platform software fed {mode} qos interface {interface} ingress npd detailed',
#   * 'show platform software fed {switch} {mode} qos interface {interface} ingress npd',
#   * 'show platform software fed {mode} qos interface {interface} ingress npd',
#   * 'show platform software fed {switch} {mode} qos interface {interface} egress sdk detailed',
#   * 'show platform software fed {mode} qos interface {interface} egress sdk detailed',
#   * 'show policy-map target service-group {num}',
#   * 'show policy-map control-plane'
#   * 'show policy-map interface',
# =====================================================================
class ShowPlatformSoftwareFedQosInterfaceSuperParser(ShowPlatformSoftwareFedQosInterfaceSuperParserSchema):
    """Parser for show platform software fed {switch} {mode} qos interface {interface} ingress npd detailed"""

    cli_command = ['show platform software fed {switch} {mode} qos interface {interface} ingress npd detailed',
        'show platform software fed {mode} qos interface {interface} ingress npd detailed']

    def cli(self, mode, interface, switch=None, output=None):
        if output is None:
            if switch:
                cmd = self.cli_command[0].format(switch=switch, mode=mode, interface=interface)
            else:
                cmd = self.cli_command[1].format(mode=mode, interface=interface)

            output = self.device.execute(cmd)

        # [HundredGigE1/0/5, map1, Ingress]: CGID = 0x738310
        # [HundredGigE1/0/1.1, map1, Ingress]: CGID = 0x738310
        p1 = re.compile(r'^\[(?P<interface>[\w\/\.]+),.+$')

        # cgid: 0x738310
        p1_1 = re.compile(r'^cgid:\s+(?P<cgid>\w+)$')

        # No of classes: 4
        p1_2 = re.compile(r'^No of classes:\s+(?P<no_of_classes>\d+)$')

        # TCG ref count: 1
        p1_3 = re.compile(r'^TCG ref count:\s+(?P<tcg_ref_count>\d+)$')

        # Filter state: UP TO DATE
        p1_4 = re.compile(r'^Filter state:\s+(?P<filter_state>[\w\s]+)$')

        # VMR state: UP TO DATE
        p1_5 = re.compile(r'^VMR state:\s+(?P<vmr_state>[\w\s]+)$')

        # NPD: Ingress QOS Profile information
        # SDK: Egress QOS Profile information
        # SDK: Ingress QOS Profile information
        p2 = re.compile(r'^(NPD|SDK): (Ingress|Egress) QOS Profile information$')

        # OID: 0x82E
        p2_1 = re.compile(r'^OID:\s+(?P<oid>\w+)$')

        # Ref Count: 1
        p2_2 = re.compile(r'^Ref Count:\s+(?P<ref_count>\d+)$')

        # No of  Counter: 1
        p2_3 = re.compile(r'^No of\s+Counter:\s+(?P<no_of_counter>\d+)$')

        # No of meters: 3
        p2_4 = re.compile(r'^No of meters:\s+(?P<no_of_meters>\d+)$')

        # Tunnel Mode: RE-EVALUATE
        p2_5 = re.compile(r'^Tunnel Mode:\s+(?P<tunnel_mode>[\w\-\s]+)$')

        # Need filter table update: UPTODATE
        p2_6 = re.compile(r'^Need filter table update:\s+(?P<need_filter_table_update>[\w\s]+)$')

        # Marking source: Tag
        p2_7 = re.compile(r'^Marking source:\s+(?P<marking_source>\w+)$')

        # DSCP      Remap   Encap   Qos Group   TC  DP  Meter MCOffset
        # COS_DEI   Remap   Encap   Qos Group   TC  DP  Meter MCOffset
        # EXP      Remap   Encap   Qos Group   TC  DP  Meter MCOffset
        # DSCP      Remap   ETOS    EPCP    EExp   ILE   CounterOffset
        p3 = re.compile(r'^(?P<table>DSCP|COS_DEI|EXP)\s+Remap\s+(Encap|ETOS)\s+(Qos Group|EPCP)\s+(TC|EExp)\s+(DP|ILE)\s+(Meter|CounterOffset)(\s+MCOffset)?$')

        # 0          0       0         0       0   G     N      3
        p3_1 = re.compile(r'^(?P<counter>\d+)\s+(?P<remap>\d+)\s+(?P<encap>\d+)\s+(?P<qos_group>\d+)\s+'
            r'(?P<tc>\d+)\s+(?P<dp>\w+)\s+(?P<meter>\w+)\s+(?P<mc_offset>\d+)$')

        # 0          0       0         0       0   G     N      3
        p3_2 = re.compile(r'^(?P<counter>\d+)\s+(?P<remap>\d+)\s+(?P<etos>\d+)\s+(?P<epcp>\d+)\s+'
            r'(?P<eexp>\d+)\s+(?P<ile>\w+)\s+(?P<counteroffset>\w+)$')

        # Markdown Table-Map OID: 0x5EE
        p4 = re.compile(r'^Markdown Table-Map OID: (?P<oid>\w+)$')

        # DSCP       Green   Yellow     Red
        # PCPDEI      Green   Yellow     Red
        # EXP        Green   Yellow     Red
        p4_0 = re.compile(r'^(?P<table>\w+)\s+Green\s+Yellow\s+Red$')

        # 1           1       1        1
        p4_1 = re.compile(r'^(?P<counter>\d+)\s+(?P<green>\d+)\s+(?P<yellow>\d+)\s+(?P<red>\d+)$')

        # IPV4 ACL (OID: 0x593, No of ACEs: 3)
        # IPV6 ACL (OID: 0x5DC, No of ACEs: 3)
        p5 = re.compile(r'^(?P<acl_version>\w+ ACL) \(OID: (?P<oid>\w+), No of ACEs: (?P<number_of_aces>\d+)\)$')

        # IPV4 ACE Key/Mask
        # IPV6 ACE Key/Mask
        p5_0 = re.compile(r'^(IPV4|IPV6) ACE Key/Mask$')

        # Class id: 0x0
        p5_1 = re.compile(r'^Class id: (?P<class_id>\w+)$')

        # IPv4 Src/Mask: 0.0.0.0/0.0.0.0
        # IPv6 Src/Mask: ::/::
        p5_2 = re.compile(r'^(?P<ip_version>\w+)\sSrc\/Mask:\s(?P<src_address>\S+)\/(?P<src_mask>\S+)$')

        # IPv4 Dst/Mask: 0.0.0.0/0.0.0.0
        # IPv6 Dst/Mask: ::/::
        p5_3 = re.compile(r'^(?P<ip_version>\w+)\sDst\/Mask:\s(?P<dst_address>\S+)\/(?P<dst_mask>\S+)$')

        # Protocol/Mask: 0x0/0x0
        p5_4 = re.compile(r'^Protocol\/Mask:\s(?P<protocol>\w+)\/(?P<protocol_mask>\w+)$')

        # DSCP/Mask: 0x8/0x3f
        p5_5 = re.compile(r'^DSCP\/Mask:\s(?P<dscp>\w+)\/(?P<dscp_mask>\w+)$')

        # TTL Start/End: 0x0/0x0
        p5_6 = re.compile(r'^TTL Start\/End:\s(?P<ttl_start>\w+)\/(?P<ttl_end>\w+)$')

        # TCP Flags/Mask: 0x0/0x0
        p5_7 = re.compile(r'^TCP Flags\/Mask:\s(?P<tcp_flags>\w+)\/(?P<tcp_mask>\w+)$')

        # IP Flags/Mask: 0x0/0x0
        p5_8 = re.compile(r'^IP Flags\/Mask:\s(?P<ip_flags>\w+)\/(?P<ip_mask>\w+)$')

        # Src Port Start/End: 0x0/0x0
        p5_9 = re.compile(r'^Src Port Start\/End:\s(?P<src_port_start>\w+)\/(?P<src_port_end>\w+)$')

        # Dst Port Start/End: 0x0/0x0
        p5_10 = re.compile(r'^Dst Port Start\/End:\s(?P<dst_port_start>\w+)\/(?P<dst_port_end>\w+)$')

        # Result Action
        p6 = re.compile(r'^Result Action$')

        # Remark value: 0
        p6_1 = re.compile(r'^Remark value:\s(?P<remark_value>\w+)$')

        # Encap value: 0
        p6_2 = re.compile(r'^Encap value:\s(?P<encap_value>\w+)$')

        # QOS Group: 0
        p6_3 = re.compile(r'^QOS Group:\s(?P<qos_group>\w+)$')

        # Traffic Class: 0
        p6_4 = re.compile(r'^Traffic Class:\s(?P<traffic_class>\w+)$')

        # Drop Precedence: G
        p6_5 = re.compile(r'^Drop Precedence:\s(?P<drop_precedence>\w+)$')

        # Overwrite PHB: N
        p6_6 = re.compile(r'^Overwrite PHB:\s(?P<overwrite_phb>\w+)$')

        # Overwrite QOS Group: N
        p6_7 = re.compile(r'^Overwrite QOS Group:\s(?P<overwrite_qos_group>\w+)$')

        # Overwrite Encap: N
        p6_8 = re.compile(r'^Overwrite Encap:\s(?P<overwrite_encap>\w+)$')

        # Overwrite Fwd Tag: N
        p6_9 = re.compile(r'^Overwrite Fwd Tag:\s(?P<overwrite_fwd_tag>\w+)$')

        # Meter Enabled: Y
        p6_10 = re.compile(r'^Meter Enabled:\s(?P<meter_enabled>\w+)$')

        # Meter or Counter offset: 0
        p6_11 = re.compile(r'^Meter or Counter offset:\s(?P<meter_counter_offset>\w+)$')

        # NPD: Bind Information
        # SDK: Bind Information
        p7 = re.compile(r'^(NPD|SDK): Bind Information$')

        # Port Type: L3
        p7_1 = re.compile(r'^Port Type:\s+(?P<port_type>\w+)$')

        # IQP counter size: 1
        p7_2 = re.compile(r'^IQP counter size:\s+(?P<iqp_counter_size>\d+)$')

        # IQP Counter OID: 0x0
        p7_3 = re.compile(r'^IQP Counter OID:\s+(?P<iqp_counter_oid>\w+)$')

        # Meter Type: EXACT
        # Meter Type: IFG EXACT
        p7_4 = re.compile(r'^Meter Type:\s+(?P<meter_type>[\w\s]+)$')

        # Meter set OID: 0x831
        p7_5 = re.compile(r'^Meter set OID:\s+(?P<meter_set_oid>\w+)$')

        # No of meters: 4
        p7_6 = re.compile(r'^No of meters:\s+(?P<no_of_meters>\d+)$')

        # System port OID: 0x5ED
        p7_7 = re.compile(r'^System port OID:\s+(?P<system_port_oid>\w+)$')

        # Port OID: 0x5E9
        p7_8 = re.compile(r'^Port OID:\s+(?P<port_oid>\w+)$')

        # Speed: 10000000000
        p7_9 = re.compile(r'^Speed:\s+(?P<speed>\w+)$')

        # Port Internal State: Active
        p7_10 = re.compile(r'^Port Internal State:\s+(?P<port_internal_state>\w+)$')

        # EQP counter size: 5
        p7_11 = re.compile(r'^EQP counter size:\s+(?P<eqp_counter_size>\d+)$')
        
        # EQP Counter OID: 0xAC6
        p7_12 = re.compile(r'^EQP Counter OID:\s+(?P<eqp_counter_oid>\w+)$')

        # Meter Set info
        p8 = re.compile(r'^Meter Set info$')

        # CIR: 1000000000
        p8_1 = re.compile(r'^CIR:\s+(?P<cir>\d+)$')

        # EIR: 1000000000
        p8_2 = re.compile(r'^EIR:\s+(?P<eir>\d+)$')

        # Profile OID: 0x832
        p8_3 = re.compile(r'^Profile OID:\s+(?P<profile_oid>\w+)$')

        # Action Profile OID: 0x110
        p8_4 = re.compile(r'^Action Profile OID:\s+(?P<action_profile_oid>\w+)$')

        ret_dict = {}
        meter_set_count = 0
        ace_count = 0

        for line in output.splitlines():
            line = line.strip()

            # [HundredGigE1/0/5, map1, Ingress]: CGID = 0x738310
            # [HundredGigE1/0/1.1, map1, Ingress]: CGID = 0x738310
            m = p1.match(line)
            if m:
                int_dict = ret_dict.setdefault('interface', {}).setdefault(Common.convert_intf_name(m.groupdict()['interface']), {})
                continue

            # cgid: 0x738310
            m = p1_1.match(line)
            if m:
                int_dict.setdefault('cgid', m.groupdict()['cgid'])
                continue

            # No of classes: 4
            m = p1_2.match(line)
            if m:
                int_dict.setdefault('no_of_classes', int(m.groupdict()['no_of_classes']))
                continue

            # TCG ref count: 1
            m = p1_3.match(line)
            if m:
                int_dict.setdefault('tcg_ref_count', int(m.groupdict()['tcg_ref_count']))
                continue

            # Filter state: UP TO DATE
            m = p1_4.match(line)
            if m:
                int_dict.setdefault('filter_state', m.groupdict()['filter_state'])
                continue

            # VMR state: UP TO DATE
            m = p1_5.match(line)
            if m:
                int_dict.setdefault('vmr_state', m.groupdict()['vmr_state'])
                continue

            # NPD: Ingress QOS Profile information
            # SDK: Egress QOS Profile information
            # SDK: Ingress QOS Profile information
            m = p2.match(line)
            if m:
                qos_dict = ret_dict.setdefault('qos_profile_information', {})
                continue

            # OID: 0x82E
            m = p2_1.match(line)
            if m:
                qos_dict.setdefault('oid', m.groupdict()['oid'])
                continue

            # Ref Count: 1
            m = p2_2.match(line)
            if m:
                qos_dict.setdefault('ref_count', int(m.groupdict()['ref_count']))
                continue

            # No of  Counter: 1
            m = p2_3.match(line)
            if m:
                qos_dict.setdefault('no_of_counter', int(m.groupdict()['no_of_counter']))
                continue

            # No of meters: 3
            m = p2_4.match(line)
            if m and 'no_of_meters' not in qos_dict:
                qos_dict.setdefault('no_of_meters', int(m.groupdict()['no_of_meters']))
                continue

            # Tunnel Mode: RE-EVALUATE
            m = p2_5.match(line)
            if m:
                qos_dict.setdefault('tunnel_mode', m.groupdict()['tunnel_mode'])
                continue

            # Need filter table update: UPTODATE
            m = p2_6.match(line)
            if m:
                qos_dict.setdefault('need_filter_table_update', m.groupdict()['need_filter_table_update'])
                continue

            # Marking source: Tag
            m = p2_7.match(line)
            if m:
                qos_dict.setdefault('marking_source', m.groupdict()['marking_source'])
                continue

            # DSCP      Remap   Encap   Qos Group   TC  DP  Meter MCOffset
            # COS_DEI   Remap   Encap   Qos Group   TC  DP  Meter MCOffset
            # EXP      Remap   Encap   Qos Group   TC  DP  Meter MCOffset
            # DSCP      Remap   ETOS    EPCP    EExp   ILE   CounterOffset
            m = p3.match(line)
            if m:
                table_dict = qos_dict.setdefault(m.groupdict()['table'].lower(), {})
                continue

            # 0          0       0         0       0   G     N      3
            m = p3_1.match(line)
            if m:
                result = m.groupdict()
                table_count_dict = table_dict.setdefault(result['counter'], {})
                table_count_dict['remap'] = int(result['remap'])
                table_count_dict['encap'] = int(result['encap'])
                table_count_dict['qos_group'] = int(result['qos_group'])
                table_count_dict['tc'] = int(result['tc'])
                table_count_dict['dp'] = result['dp']
                table_count_dict['meter'] = result['meter']
                table_count_dict['mc_offset'] = int(result['mc_offset'])
                continue

            # 0          0       0         0       0   G     N      3
            m = p3_2.match(line)
            if m:
                result = m.groupdict()
                table_count_dict = table_dict.setdefault(result['counter'], {})
                table_count_dict['remap'] = int(result['remap'])
                table_count_dict['etos'] = int(result['etos'])
                table_count_dict['epcp'] = int(result['epcp'])
                table_count_dict['eexp'] = int(result['eexp'])
                table_count_dict['ile'] = result['ile']
                table_count_dict['counteroffset'] = int(result['counteroffset'])
                continue

            # Markdown Table-Map OID: 0x5EE
            m = p4.match(line)
            if m:
                markdown_dict = ret_dict.setdefault('markdown_table', {})
                markdown_dict['oid'] = m.groupdict()['oid']
                continue

            # DSCP       Green   Yellow     Red
            # PCPDEI      Green   Yellow     Red
            # EXP        Green   Yellow     Red
            m = p4_0.match(line)
            if m:
                table_name = m.groupdict()['table'].lower().replace(' ', '_')
                markdown_table_dict = markdown_dict.setdefault(table_name, {})
                continue

            # 1           1       1        1
            m = p4_1.match(line)
            if m:
                values = m.groupdict()
                markdown_each_table = markdown_table_dict.setdefault(values['counter'], {})
                markdown_each_table['green'] = int(values['green'])
                markdown_each_table['yellow'] = int(values['yellow'])
                markdown_each_table['red'] = int(values['red'])
                continue

            # IPV4 ACL (OID: 0x593, No of ACEs: 3)
            # IPV6 ACL (OID: 0x5DC, No of ACEs: 3)
            m = p5.match(line)
            if m:
                values = m.groupdict()
                acl_name = values["acl_version"].lower().replace(' ', '_')
                acl_dict = ret_dict.setdefault(acl_name, {})
                acl_dict['oid'] = values['oid']
                acl_dict['number_of_aces'] = int(values['number_of_aces'])
                ace_count = 0

            # IPV4 ACE Key/Mask
            # IPV6 ACE Key/Mask
            m = p5_0.match(line)
            if m:
                ace_dict = acl_dict.setdefault('ace', {}).setdefault(ace_count, {})
                ace_count += 1
                continue

            # Class id: 0x0
            m = p5_1.match(line)
            if m:
                ace_dict['class_id'] = m.groupdict()['class_id']
                continue

            # IPv4 Src/Mask: 0.0.0.0/0.0.0.0
            # IPv6 Src/Mask: ::/::
            m = p5_2.match(line)
            if m:
                values = m.groupdict()
                ip_version = values['ip_version'].lower()
                ace_dict[f'{ip_version}_src_address'] = values['src_address']
                ace_dict[f'{ip_version}_src_mask'] = values['src_mask']
                continue

            # IPv4 Dst/Mask: 0.0.0.0/0.0.0.0
            # IPv6 Dst/Mask: ::/::
            m = p5_3.match(line)
            if m:
                values = m.groupdict()
                ip_version = values['ip_version'].lower()
                ace_dict[f'{ip_version}_dst_address'] = values['dst_address']
                ace_dict[f'{ip_version}_dst_mask'] = values['dst_mask']
                continue

            # Protocol/Mask: 0x0/0x0
            m = p5_4.match(line)
            if m:
                ace_dict['protocol'] = m.groupdict()['protocol']
                ace_dict['protocol_mask'] = m.groupdict()['protocol_mask']
                continue

            # DSCP/Mask: 0x8/0x3f
            m = p5_5.match(line)
            if m:
                ace_dict['dscp'] = m.groupdict()['dscp']
                ace_dict['dscp_mask'] = m.groupdict()['dscp_mask']
                continue

            # TTL Start/End: 0x0/0x0
            m = p5_6.match(line)
            if m:
                ace_dict['ttl_start'] = m.groupdict()['ttl_start']
                ace_dict['ttl_end'] = m.groupdict()['ttl_end']
                continue

            # TCP Flags/Mask: 0x0/0x0
            m = p5_7.match(line)
            if m:
                ace_dict['tcp_flags'] = m.groupdict()['tcp_flags']
                ace_dict['tcp_mask'] = m.groupdict()['tcp_mask']
                continue

            # IP Flags/Mask: 0x0/0x0
            m = p5_8.match(line)
            if m:
                ace_dict['ip_flags'] = m.groupdict()['ip_flags']
                ace_dict['ip_mask'] = m.groupdict()['ip_mask']
                continue

            # Src Port Start/End: 0x0/0x0
            m = p5_9.match(line)
            if m:
                ace_dict['src_port_start'] = m.groupdict()['src_port_start']
                ace_dict['src_port_end'] = m.groupdict()['src_port_end']
                continue

            # Dst Port Start/End: 0x0/0x0
            m = p5_10.match(line)
            if m:
                ace_dict['dst_port_start'] = m.groupdict()['dst_port_start']
                ace_dict['dst_port_end'] = m.groupdict()['dst_port_end']
                continue

            # Result Action
            m = p6.match(line)
            if m:
                ace_action_dict = ace_dict.setdefault('result_action', {})
                continue

            # Remark value: 0
            m = p6_1.match(line)
            if m:
                ace_action_dict['remark_value'] = m.groupdict()['remark_value']
                continue

            # Encap value: 0
            m = p6_2.match(line)
            if m:
                ace_action_dict['encap_value'] = m.groupdict()['encap_value']
                continue

            # QOS Group: 0
            m = p6_3.match(line)
            if m:
                ace_action_dict['qos_group'] = m.groupdict()['qos_group']
                continue

            # Traffic Class: 0
            m = p6_4.match(line)
            if m:
                ace_action_dict['traffic_class'] = m.groupdict()['traffic_class']
                continue

            # Drop Precedence: G
            m = p6_5.match(line)
            if m:
                ace_action_dict['drop_precedence'] = m.groupdict()['drop_precedence']
                continue

            # Overwrite PHB: N
            m = p6_6.match(line)
            if m:
                ace_action_dict['overwrite_phb'] = m.groupdict()['overwrite_phb']
                continue

            # Overwrite QOS Group: N
            m = p6_7.match(line)
            if m:
                ace_action_dict['overwrite_qos_group'] = m.groupdict()['overwrite_qos_group']
                continue

            # Overwrite Encap: N
            m = p6_8.match(line)
            if m:
                ace_action_dict['overwrite_encap'] = m.groupdict()['overwrite_encap']
                continue

            # Overwrite Fwd Tag: N
            m = p6_9.match(line)
            if m:
                ace_action_dict['overwrite_fwd_tag'] = m.groupdict()['overwrite_fwd_tag']
                continue

            # Meter Enabled: Y
            m = p6_10.match(line)
            if m:
                ace_action_dict['meter_enabled'] = m.groupdict()['meter_enabled']
                continue

            # Meter or Counter offset: 0
            m = p6_11.match(line)
            if m:
                ace_action_dict['meter_counter_offset'] = m.groupdict()['meter_counter_offset']
                continue

            # NPD: Bind Information
            # SDK: Bind Information
            m = p7.match(line)
            if m:
                bind_dict = ret_dict.setdefault('bind_information', {})
                continue

            # Port Type: L3
            m = p7_1.match(line)
            if m:
                bind_dict.setdefault('port_type', m.groupdict()['port_type'])
                continue

            # IQP counter size: 1
            m = p7_2.match(line)
            if m:
                bind_dict.setdefault('iqp_counter_size', int(m.groupdict()['iqp_counter_size']))
                continue

            # IQP Counter OID: 0x0
            m = p7_3.match(line)
            if m:
                bind_dict.setdefault('iqp_counter_oid', m.groupdict()['iqp_counter_oid'])
                continue

            # Meter Type: EXACT
            # Meter Type: IFG EXACT
            m = p7_4.match(line)
            if m:
                bind_dict.setdefault('meter_type', m.groupdict()['meter_type'])
                continue

            # Meter set OID: 0x831
            m = p7_5.match(line)
            if m:
                bind_dict.setdefault('meter_set_oid', m.groupdict()['meter_set_oid'])
                continue

            # No of meters: 4
            m = p7_6.match(line)
            if m:
                bind_dict.setdefault('no_of_meters', int(m.groupdict()['no_of_meters']))
                continue

            # System port OID: 0x5ED
            m = p7_7.match(line)
            if m:
                bind_dict.setdefault('system_port_oid', m.groupdict()['system_port_oid'])
                continue

            # Port OID: 0x5E9
            m = p7_8.match(line)
            if m:
                bind_dict.setdefault('port_oid', m.groupdict()['port_oid'])
                continue

            # Speed: 10000000000
            m = p7_9.match(line)
            if m:
                bind_dict.setdefault('speed', int(m.groupdict()['speed']))
                continue

            # Port Internal State: Active
            m = p7_10.match(line)
            if m:
                bind_dict.setdefault('port_internal_state', m.groupdict()['port_internal_state'])
                continue

            # EQP counter size: 1
            m = p7_11.match(line)
            if m:
                bind_dict.setdefault('eqp_counter_size', int(m.groupdict()['eqp_counter_size']))
                continue

            # EQP Counter OID: 0x0
            m = p7_12.match(line)
            if m:
                bind_dict.setdefault('eqp_counter_oid', m.groupdict()['eqp_counter_oid'])
                continue

            # Meter Set info
            m = p8.match(line)
            if m:
                meter_info_dict = bind_dict.setdefault('meter_set_info', {})
                continue

            # CIR: 1000000000
            m = p8_1.match(line)
            if m:
                meter_cnt_dict = meter_info_dict.setdefault(str(meter_set_count), {})
                meter_cnt_dict.setdefault('cir', int(m.groupdict()['cir']))
                meter_set_count += 1
                continue

            # EIR: 1000000000
            m = p8_2.match(line)
            if m:
                meter_cnt_dict.setdefault('eir', int(m.groupdict()['eir']))
                continue

            # Profile OID: 0x832
            m = p8_3.match(line)
            if m:
                meter_cnt_dict.setdefault('profile_oid', m.groupdict()['profile_oid'])
                continue

            # Action Profile OID: 0x110
            m = p8_4.match(line)
            if m:
                meter_cnt_dict.setdefault('action_profile_oid', m.groupdict()['action_profile_oid'])
                continue

        return ret_dict


class ShowPlatformSoftwareFedQosInterfaceIngressNpdDetailed(ShowPlatformSoftwareFedQosInterfaceSuperParser):
    """Parser for show platform software fed {switch} {mode} qos interface {interface} ingress npd detailed"""

    cli_command = ['show platform software fed {switch} {mode} qos interface {interface} ingress npd detailed',
        'show platform software fed {mode} qos interface {interface} ingress npd detailed']

    def cli(self, mode, interface, switch=None, output=None):
        return super().cli(mode=mode, interface=interface, switch=switch, output=output)


class ShowPlatformSoftwareFedQosInterfaceIngressNpd(ShowPlatformSoftwareFedQosInterfaceSuperParser):
    """Parser for show platform software fed {switch} {mode} qos interface {interface} ingress npd"""

    cli_command = ['show platform software fed {switch} {mode} qos interface {interface} ingress npd',
        'show platform software fed {mode} qos interface {interface} ingress npd']
    def cli(self, mode, interface, switch=None, output=None):
        return super().cli(mode=mode, interface=interface, switch=switch, output=output)


class ShowPlatformSoftwareFedQosInterfaceEgressSdkDetailed(ShowPlatformSoftwareFedQosInterfaceSuperParser):
    """Parser for show platform software fed {switch} {mode} qos interface {interface} egress sdk detailed"""

    cli_command = ['show platform software fed {switch} {mode} qos interface {interface} egress sdk detailed',
        'show platform software fed {mode} qos interface {interface} egress sdk detailed']

    def cli(self, mode, interface, switch=None, output=None):
        return super().cli(mode=mode, interface=interface, switch=switch, output=output)


class ShowPlatformSoftwareFedQosInterfaceIngressSdk(ShowPlatformSoftwareFedQosInterfaceSuperParser):
    """Parser for show platform software fed {switch} {mode} qos interface {interface} ingress sdk"""

    cli_command = ['show platform software fed {switch} {mode} qos interface {interface} ingress sdk',
        'show platform software fed {mode} qos interface {interface} ingress sdk']

    def cli(self, mode, interface, switch=None, output=None):
        return super().cli(mode=mode, interface=interface, switch=switch, output=output)


class ShowPlatformSoftwareFedQosInterfaceIngressSdkDetailed(ShowPlatformSoftwareFedQosInterfaceSuperParser):
    """Parser for show platform software fed {switch} {mode} qos interface {interface} ingress sdk detailed"""

    cli_command = ['show platform software fed {switch} {mode} qos interface {interface} ingress sdk detailed',
        'show platform software fed {mode} qos interface {interface} ingress sdk detailed']

    def cli(self, mode, interface, switch=None, output=None):
        return super().cli(mode=mode, interface=interface, switch=switch, output=output)

# ====================
# Schema for:
#  * 'show processes <pid>'
# ====================
class ShowProcessesPidSchema(MetaParser):
    ''' Schema for "show processes <pid>" '''

    schema = {
        'pid': int,
        'process_name': str,
        'tty': int,
        'memory_usage': {
            'holding': int,
            'maximum': int,
            'allocated': int,
            'freed': int,
            'getbufs': int,
            'retbufs': int,
            'stack': str,
        },
        'cpu_usage': {
            'pc': str,
            'invoked': int,
            'giveups': int,
            'u_sec': int,
            '5sec_percent': float,
            '1min_percent': float,
            '5min_percent': float,
            'average': float,
            'age': int,
            'runtime': int,
            'state': str,
            'priority': str,
        }
    }

# ====================
# Parser for:
#  * 'show processes <pid>'
# ====================
class ShowProcessesPid(ShowProcessesPidSchema):
    ''' Parser for "show processes <processid>" '''

    # Process ID 3 [Network Synchronization Selection Control Process], TTY 0
    # Memory usage [in bytes]
    #   Holding: 41960, Maximum: 0, Allocated: 0, Freed: 0
    #   Getbufs: 0, Retbufs: 0, Stack: 34240/36000
    # CPU usage
    #   PC: 64448F4868F5, Invoked: 1, Giveups: 0, uSec: 0
    #   5Sec: 0.00%, 1Min: 0.00%, 5Min: 0.00%, Average: 0.00%
    #   Age: 511941589 msec, Runtime: 0 msec
    #   State: Waiting for Event, Priority: Critical

    cli_command = 'show processes {processid}'

    # Define a function to run the cli_command
    def cli(self, processid=None, output=None):
        if output is None:
            output = self.device.execute(self.cli_command.format(processid=processid))

        parsed_dict = {}

        # Define RegExes for each possible kind of line

        # Process ID 3 [Network Synchronization Selection Control Process], TTY 0
        p1 = re.compile(r'^Process +ID +(?P<pid>(\S+)) +\[ *(?P<process_name>([ a-zA-Z0-9]+)) *\], TTY +(?P<tty>(\S+))$')

        #   Holding: 41960, Maximum: 0, Allocated: 0, Freed: 0
        p2 = re.compile(r'^Holding: +(?P<holding>(\d+)), +Maximum: +(?P<maximum>(\d+)), +Allocated: +(?P<allocated>(\d+)), +Freed: +(?P<freed>(\d+))$')

        #   Getbufs: 0, Retbufs: 0, Stack: 34240/36000
        p3 = re.compile(r'^Getbufs: +(?P<getbufs>(\d+)), +Retbufs: +(?P<retbufs>(\d+)), Stack: +(?P<stack>(\S+))$')

        #   PC: 64448F4868F5, Invoked: 1, Giveups: 0, uSec: 0
        p4 = re.compile(r'^PC: +(?P<pc>(\S+)), +Invoked: +(?P<invoked>(\d+)), Giveups: +(?P<giveups>(\d+)), uSec: (?P<u_sec>(\d+))$')

        #   5Sec: 0.00%, 1Min: 0.00%, 5Min: 0.00%, Average: 0.00%
        p5 = re.compile(r'^5Sec: +(?P<five_sec_percent>(\S+))%, +1Min: +(?P<one_min_percent>(\S+))%, +5Min: +(?P<five_min_percent>(\S+))%, +Average: +(?P<average>(\S+))%$')

        #   Age: 511941589 msec, Runtime: 0 msec
        p6 = re.compile(r'^Age: +(?P<age>(\S+)) msec, +Runtime: +(?P<runtime>(\d+)) msec$')

        #   State: Waiting for Event, Priority: Critical
        p7 = re.compile(r'^State: +(?P<state>([ a-zA-Z0-9]+)), +Priority: +(?P<priority>(\S+))$')


        # Iterate over output lines to check which pattern is matched

        for line in output.splitlines():
            line = line.strip()

            # Try matching pattern 1
            # Process ID 3 [Network Synchronization Selection Control Process], TTY 0
            m = p1.match(line)
            if m:
                group = m.groupdict()
                parsed_dict.setdefault('pid',int(group["pid"]))
                parsed_dict.setdefault('process_name',group["process_name"])
                parsed_dict.setdefault('tty',int(group["tty"]))
                continue


            # Try matching pattern 2
            #   Holding: 41960, Maximum: 0, Allocated: 0, Freed: 0
            m = p2.match(line)
            if m:
                group = m.groupdict()
                memory_usage_dict = parsed_dict.setdefault('memory_usage',{})
                memory_usage_dict.update({
                    'holding': int(group["holding"]),
                    'maximum':int(group["maximum"]),
                    'allocated':int(group["allocated"]),
                    'freed':int(group["freed"])
                })
                continue

            # Try matching pattern 3
            #   Getbufs: 0, Retbufs: 0, Stack: 34240/36000
            m = p3.match(line)
            if m:
                group = m.groupdict()
                memory_usage_dict = parsed_dict.setdefault('memory_usage',{})
                memory_usage_dict.update({
                    'getbufs':int(group["getbufs"]),
                    'retbufs':int(group["retbufs"]),
                    'stack':group["stack"]
                })
                continue

            # Try matching pattern 4
            #   PC: 64448F4868F5, Invoked: 1, Giveups: 0, uSec: 0
            m = p4.match(line)
            if m:
                group = m.groupdict()
                cpu_usage_dict = parsed_dict.setdefault("cpu_usage",{})
                cpu_usage_dict.update({
                    'pc':group["pc"],
                    'invoked':int(group["invoked"]),
                    'giveups':int(group["giveups"]),
                    'u_sec':int(group["u_sec"])
                })
                continue

            # Try matching pattern 5
            #   5Sec: 0.00%, 1Min: 0.00%, 5Min: 0.00%, Average: 0.00%
            m = p5.match(line)
            if m:
                group = m.groupdict()
                cpu_usage_dict = parsed_dict.setdefault("cpu_usage",{})
                cpu_usage_dict.update({
                    '5sec_percent':float(group["five_sec_percent"]),
                    '1min_percent':float(group["one_min_percent"]),
                    '5min_percent':float(group["five_min_percent"]),
                    'average':float(group["average"])
                })
                continue

            # Try matching pattern 6
            #   Age: 511941589 msec, Runtime: 0 msec
            m = p6.match(line)
            if m:
                group = m.groupdict()
                cpu_usage_dict = parsed_dict.setdefault("cpu_usage",{})
                cpu_usage_dict.update({
                    'age': int(group["age"]),
                    'runtime': int(group["runtime"])
                })
                continue

            # Try matching pattern 7
            #   State: Waiting for Event, Priority: Critical
            m = p7.match(line)
            if m:
                group = m.groupdict()
                cpu_usage_dict = parsed_dict.setdefault("cpu_usage",{})
                cpu_usage_dict.update({
                    'state': group["state"],
                    'priority': group["priority"]
                })
                continue          
            

        return parsed_dict

# ==========================================================================================
# Parser Schema for 'show xfsu eligibility'
# ==========================================================================================

class ShowXfsuEligibilitySchema(MetaParser):
    """
    Schema for
        * 'show xfsu eligibility'
    """

    schema = {
        'reload_fast_supported': str,
        'reload_fast_platform_stauts': str,
        'stack_configuration': str,
        'eligibility_check': {
            Any(): {
                'status': str
            },
            'spanning_tree':{
                'status': str,
                Optional(Any()): str
            }
        }
    }

# ==========================================================================================
# Parser for 'show xfsu eligibility
# ==========================================================================================

class ShowXfsuEligibility(ShowXfsuEligibilitySchema):
    """
    Parser for
        * 'show xfsu eligibility'
    """
    cli_command = 'show xfsu eligibility'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        #Reload fast supported: Yes
        p1 = re.compile(r'^Reload fast supported: (?P<reload_fast_supported>\w+)$')
        #Reload Fast PLATFORM Status: Not started yet
        p2 = re.compile(r'^Reload Fast PLATFORM Status: (?P<platform_status>[\w\s]+)$')
        #Stack Configuration: Yes
        p3 = re.compile(r'^Stack Configuration: (?P<stack_configuration>\w+)$')
        #Eligibility Check         Status
        #=================         ======
        #Autoboot Enabled          Yes
        #Install Mode              Yes
        #Network Advantage License Yes
        #Full ring stack           Yes
        #Check macsec eligibility  Eligible
        p4 = re.compile(r'^(?P<eligibility_check>[\w+ ]+) +(?P<status>Yes|No|Eligible|Ineligible)$')
        #Spanning Tree             Ineligible:Root Switch with forwarding link:VLAN0069
        p5 = re.compile(r'^Spanning Tree\s+(?P<spanning_tree>\w+):(?P<status>[\w ]+):(?P<forwarding_link>\S+)$')
        ret_dict = {}
        for line in output.splitlines():
            line = line.strip()
            #Reload fast supported: Yes
            m = p1.match(line)
            if m:
                group = m.groupdict()
                ret_dict['reload_fast_supported'] = group['reload_fast_supported']
                continue

            #Reload Fast PLATFORM Status: Not started yet
            m = p2.match(line)
            if m:
                group = m.groupdict()
                ret_dict['reload_fast_platform_stauts'] = group['platform_status']
                continue
            #Stack Configuration: Yes
            m = p3.match(line)
            if m:
                group = m.groupdict()
                ret_dict['stack_configuration'] = group['stack_configuration']
                continue
            #Eligibility Check         Status
            #=================         ======
            #Autoboot Enabled          Yes
            #Install Mode              Yes
            #Network Advantage License Yes
            #Full ring stack           Yes
            #Check macsec eligibility  Eligible
            m = p4.match(line)
            if m:
                group = m.groupdict()
                root_dict = ret_dict.setdefault('eligibility_check',{})
                if group['eligibility_check'] != 'Eligibility Check':
                    if group['status'] != 'Status':
                        check_dict = root_dict.setdefault(group['eligibility_check'].lower().strip().replace(" ","_"),{})
                        check_dict['status'] = group['status']
                continue
            #Spanning Tree             Ineligible:Root Switch with forwarding link:VLAN0069
            m = p5.match(line)
            if m:
                group = m.groupdict()
                root_dict = ret_dict.setdefault('eligibility_check',{})
                spanning_dict = root_dict.setdefault('spanning_tree',{})
                spanning_dict['status'] = group['spanning_tree']
                spanning_dict[group['status'].lower().strip().replace(" ","_")] = group['forwarding_link']
                continue
        return ret_dict



# ==========================================================================================
# Parser Schema for 'show switch stack-ports detail'
# ==========================================================================================

class ShowSwitchStackPortsDetailSchema(MetaParser):
    """
    Schema for
        * 'show switch stack-ports detail'
    """
    schema = {
        'stackports': {
            Any(): {
                'switch_port_id': str,
                'status': str,
                'loopback': str,
                'cable_length': str,
                'neighbor': str,
                'link_ok': str,
                'sync_ok': str,
                'link_active': str,
                'changes_to_link_ok': int,
                'five_minute_input_rate': str,
                'five_minute_output_rate': str,
                'input_bytes': int,
                'output_bytes': int,
                'crc_errors': {
                    'data_crc': int,
                    'ringword_crc': int,
                    'inv_ringword': int,
                    'pcs_codeword': int,
                }
            }
        }
    }

# ==========================================================================================
# Parser for 'show switch stack-ports detail'
# ==========================================================================================

class ShowSwitchStackPortsDetail(ShowSwitchStackPortsDetailSchema):
    """
    Parser for
        * 'show switch stack-ports detail'
    """
    cli_command = 'show switch stack-ports detail'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)

        # initializing dictionary
        ret_dict = {}

        # 1/1 is DOWN Loopback No
        p1 = re.compile(r'^(?P<switch_port_id>\S+) is (?P<status>\S+) Loopback (?P<loopback>\S+)$')

        # Cable Length 50cm     Neighbor NONE
        p2 = re.compile(r'^Cable Length (?P<cable_length>\S+)\s+Neighbor (?P<neighbor>\S+)$')

        # Link Ok Yes Sync Ok Yes Link Active No
        p3 = re.compile(r'^Link Ok (?P<link_ok>\S+) Sync Ok (?P<sync_ok>\S+) Link Active (?P<link_active>\S+)$')

        # Changes to LinkOK 0
        p4 = re.compile(r'^Changes to LinkOK (?P<changes_to_link_ok>\d+)$')

        # Five minute input rate  0 bytes/sec
        p5 = re.compile(r'^Five minute input rate\s+(?P<five_minute_input_rate>[\S\s]+)$')

        # Five minute output rate 0 bytes/sec
        p6 = re.compile(r'^Five minute output rate\s+(?P<five_minute_output_rate>[\S\s]+)$')

        # 0 bytes input
        p7 = re.compile(r'^(?P<input_bytes>\d+) bytes input$')

        # 0 bytes output
        p8 = re.compile(r'^(?P<output_bytes>\d+) bytes output$')

        # Data CRC 0
        p9 = re.compile(r'^Data CRC\s+(?P<data_crc>\d+)$')

        # Ringword CRC 0
        p10 = re.compile(r'^Ringword CRC\s+(?P<ringword_crc>\d+)$')

        # InvRingWord  0 
        p11 = re.compile(r'^InvRingWord\s+(?P<inv_ringword>\d+)$')

        # PcsCodeWord 0
        p12 = re.compile(r'^PcsCodeWord\s+(?P<pcs_codeword>\d+)$')

        for line in output.splitlines():
            line = line.strip()
            # 1/1 is DOWN Loopback No
            m = p1.match(line)
            if m:
                group = m.groupdict()
                port_dict = ret_dict.setdefault('stackports',{}).setdefault(group['switch_port_id'],{})
                port_dict['switch_port_id'] = group['switch_port_id']
                port_dict['status'] = group['status']
                port_dict['loopback'] = group['loopback']
                continue

            # Cable Length 50cm     Neighbor NONE
            m = p2.match(line)
            if m:
                group = m.groupdict()
                port_dict['cable_length'] = group['cable_length']
                port_dict['neighbor'] = group['neighbor']
                continue

            # Link Ok Yes Sync Ok Yes Link Active No
            m = p3.match(line)
            if m:
                group = m.groupdict()
                port_dict['link_ok'] = group['link_ok']
                port_dict['sync_ok'] = group['sync_ok']
                port_dict['link_active'] = group['link_active']
                continue

            # Changes to LinkOK 0
            m = p4.match(line)
            if m:
                group = m.groupdict()
                port_dict['changes_to_link_ok'] = int(group['changes_to_link_ok'])
                continue

            # Five minute input rate  0 bytes/sec
            m = p5.match(line)
            if m:
                group = m.groupdict()
                port_dict['five_minute_input_rate'] = group['five_minute_input_rate']
                continue

            # Five minute output rate 0 bytes/sec
            m = p6.match(line)
            if m:
                group = m.groupdict()
                port_dict['five_minute_output_rate'] = group['five_minute_output_rate']
                continue

            # 0 bytes input
            m = p7.match(line)
            if m:
                group = m.groupdict()
                port_dict['input_bytes'] = int(group['input_bytes'])
                continue

            # 0 bytes output
            m = p8.match(line)
            if m:
                group = m.groupdict()
                port_dict['output_bytes'] = int(group['output_bytes'])
                continue

            # Data CRC 0
            m = p9.match(line)
            if m:
                group = m.groupdict()
                error_dict = port_dict.setdefault('crc_errors',{})
                error_dict['data_crc'] = int(group['data_crc'])
                continue

            # Ringword CRC 0
            m = p10.match(line)
            if m:
                group = m.groupdict()
                error_dict['ringword_crc'] = int(group['ringword_crc'])
                continue

            # InvRingWord  0
            m = p11.match(line)
            if m:
                group = m.groupdict()
                error_dict['inv_ringword'] = int(group['inv_ringword'])
                continue

            # PcsCodeWord 0
            m = p12.match(line)
            if m:
                group = m.groupdict()
                error_dict['pcs_codeword'] = int(group['pcs_codeword'])
                continue

        return ret_dict


# ============================================================================
# Schema for 'show platform software fed switch active vt hardware if-id <>'
# ============================================================================

class ShowPlatformSoftwareFedSwitchActiveVtHardwareSchema(MetaParser):
    """ Schema for show platfrom software fed switch active vt hardware if-id <> """
    
    schema = {
        'forward_mapping':{
            Optional('translated_vlan'): int,
            Optional('cvlan'): int
        },
        'reverse_mapping':{
            Optional('translated_vlan'): int,
            Optional('svlan'): int
        }
    }


# ============================================================================
# Parser for 'show platform software fed switch active vt hardware if-id <>'
# ============================================================================

class ShowPlatformSoftwareFedSwitchActiveVtHardware(ShowPlatformSoftwareFedSwitchActiveVtHardwareSchema):
    """ Parser for 'show platform software fed switch active vt hardware if-id <> """

    cli_command = ['show platform software fed active vt hardware if-id {ifid}', 'show platform software fed switch {switch_var} vt hardware if-id {ifid}']

    def cli(self, ifid, switch_var=None, output=None):
        if output is None:
            if switch_var:
                cmd = self.cli_command[1].format(ifid=ifid, switch_var=switch_var)
            else:
                cmd = self.cli_command[0].format(ifid=ifid)
            
            output = self.device.execute(cmd)
        
        # Cvlan-id      Translated vlan-id
        p1 = re.compile(r'^Cvlan\-id\s+Translated vlan\-id$')

        # Svlan-id      Translated vlan-id
        p2 = re.compile(r'^Svlan\-id\s+Translated vlan\-id$')
        
        # 30            20
        p3 = re.compile(r'^(?P<vlan_id>\d+)\s+(?P<translated_vlan>\d+)$')

        ret_dict ={}
        reverse_map_flag = False
        for line in output.splitlines():
            line = line.strip()

            # Cvlan-id      Translated vlan-id
            m = p1.match(line)
            if m:
                map_dict = ret_dict.setdefault('forward_mapping', {})
                continue

            # Svlan-id      Translated vlan-id
            m = p2.match(line)
            if m:
                map_dict = ret_dict.setdefault('reverse_mapping', {})
                reverse_map_flag = True
                continue
            
            # 30            20
            m = p3.match(line)
            if m:
                if reverse_map_flag:
                    map_dict['svlan'] = int(m.groupdict()['vlan_id'])
                else:
                    map_dict['cvlan'] = int(m.groupdict()['vlan_id'])
                map_dict['translated_vlan'] = int(m.groupdict()['translated_vlan'])
                continue

        return ret_dict



class ShowPlatformSoftwareAuditSummarySchema(MetaParser):
    """Schema for show platform software audit summary"""
    schema = {
        'chassis': {
            Any(): {
                Optional('route_process'): int,
                'avc_denial_count': int
            }
        }
    }


class ShowPlatformSoftwareAuditSummary(ShowPlatformSoftwareAuditSummarySchema):
    """Parser for show platform software audit summary"""

    cli_command = 'show platform software audit summary'
    
    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)
        
        # AUDIT LOG ON chassis 1 route-processor 0
        p1 = re.compile(r'^AUDIT LOG ON chassis (?P<chassis>\d+) route-processor (?P<route_process>\d+)$')

        # AUDIT LOG ON ACTIVE
        p2 = re.compile(r'^AUDIT LOG ON (?P<chassis>\w+)$')

        # AVC Denial count: 82
        p3 = re.compile(r'^AVC Denial count: (?P<avc_denial_count>\d+)$')

        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()

            # AUDIT LOG ON chassis 1 route-processor 0
            m = p1.match(line)
            if m:
                chassis_dict = ret_dict.setdefault('chassis', {}).setdefault(m.groupdict()['chassis'], {})
                chassis_dict['route_process'] = int(m.groupdict()['route_process'])
                continue

            # AUDIT LOG ON ACTIVE
            m = p2.match(line)
            if m:
                chassis_dict = ret_dict.setdefault('chassis', {}).setdefault(m.groupdict()['chassis'].lower(), {})
                continue

            # AVC Denial count: 82
            m = p3.match(line)
            if m:
                chassis_dict['avc_denial_count'] = int(m.groupdict()['avc_denial_count'])
                continue
        
        return ret_dict


class ShowPlatformSoftwareFedQosInterfaceIngressNpiDetailedSchema(MetaParser):
    """Schema for show platform software fed {switch} {mode} qos interface {interface} ingress npi detailed"""
    schema = {
        Optional('interface'): {
            Any(): {
                'cgid': str,
                'no_of_classes': int,
                'tcg_ref_count': int,
                'filter_state': str,
                'vmr_state': str
            }
        },
        'classmap': {
            Any(): {
                'cgid': str,
                'clid': str,
                'tccg_ref_count': int,
                'null_bind_count': int,
                'class_seq_number': str,
                'child_classes': int,
                Optional('filter'): {
                    Any(): {
                        'value': str
                    }
                }
            }
        },
        Optional('tcg'): {
            'npi_tcg': {
                'config_state': str,
                'operational_state': str,
                'parent_info': list,
                'child_tcg': int,
                'mark_action': int,
                'police_action': int,
                'queue_action': int,
                'no_of_tccg': int
            },
            Optional('tccg'): {
                Any(): {
                    'class_map_name': str,
                    'clid': str,
                    'child_cgid': str,
                    'null_bind': bool,
                    Optional('action'): {
                        Any(): {
                            'action_type': str,
                            'marking_method': str,
                            'mark_value': int,
                            'mark_type': str,
                            'qos_group': int,
                            'traffic_class': int,
                            'discard_class': int
                        }
                    }
                }
            }
        }
    }


class ShowPlatformSoftwareFedQosInterfaceIngressNpiDetailed(
        ShowPlatformSoftwareFedQosInterfaceIngressNpiDetailedSchema):
    """Parser for show platform software fed {switch} {mode} qos interface {interface} ingress npi detailed"""
    
    cli_command = ['show platform software fed {switch} {mode} qos interface {interface} ingress npi detailed', 
        'show platform software fed {mode} qos interface {interface} ingress npi detailed']
    
    def cli(self, mode, interface, switch=None, output=None):
        if output is None:
            if switch:
                cmd = self.cli_command[0].format(switch=switch, mode=mode, interface=interface)
            else:
                cmd = self.cli_command[1].format(mode=mode, interface=interface)
            
            output = self.device.execute(cmd)

        # [HundredGigE1/0/5, map1, Ingress]: CGID = 0x738310
        # [HundredGigE1/0/5.100, map1, Ingress]: CGID = 0x738310
        p1 = re.compile(r'^\[(?P<interface>[\w\/\.]+),.+$')

        # cgid: 0x738310
        p1_1 = re.compile(r'^cgid:\s+(?P<cgid>\w+)$')
        
        # No of classes: 4
        p1_2 = re.compile(r'^No of classes:\s+(?P<no_of_classes>\d+)$')

        # TCG ref count: 1
        p1_3 = re.compile(r'^TCG ref count:\s+(?P<tcg_ref_count>\d+)$')

        # Filter state: UP TO DATE
        p1_4 = re.compile(r'^Filter state:\s+(?P<filter_state>[\w\s]+)$')

        # VMR state: UP TO DATE
        p1_5 = re.compile(r'^VMR state:\s+(?P<vmr_state>[\w\s]+)$')

        # Classmap Information
        p2 = re.compile(r'^Classmap Information$')

        # Class name: cs1(cgid: 0x738310, clid: 0x6A611)
        p2_1 = re.compile(r'^Class name: (?P<class_name>[\w\s\-]+)\(cgid: (?P<cgid>\w+)\, clid: (?P<clid>\w+)\)$')
        
        # TCCG ref count: 1
        p2_2 = re.compile(r'^TCCG ref count: (?P<tccg_ref_count>\d+)$')

        # NULL Bind count: 1
        p2_3 = re.compile(r'^NULL Bind count: (?P<null_bind_count>\d+)$')

        # Class seq no.: 0x1FFFFF
        p2_4 = re.compile(r'^Class seq no\.: (?P<class_seq_number>\w+)$')
        
        # No of child classes: 0
        p2_5 = re.compile(r'^No of child classes: (?P<child_classes>\d+)$')

        # Filter: FILTER_MATCH_IP_DSCP
        p2_6 = re.compile(r'^Filter: (?P<filter_name>[\w\s]+)$')

        # Value: 0x8
        p2_7 = re.compile(r'^Value: (?P<value>\w+)$')

        # TCG Information
        p3 = re.compile(r'^TCG Information$')

        # NPI TCG Values:
        p3_1 = re.compile(r'^NPI TCG Values:$')

        # Config state: VALID
        p3_2 = re.compile(r'^Config state: (?P<config_state>[\w\s]+)$')
        
        # Operational state: IN HARDWARE
        p3_3 = re.compile(r'^Operational state: (?P<operational_state>[\w\s]+)$')

        # Parent Info: [0x0, 0x0, 0]
        p3_4 = re.compile(r'^Parent Info: \[(?P<parent_info>[\w\s\,]+)\]$')

        # No of Child TCGs: 0
        p3_5 = re.compile(r'^No of Child TCGs: (?P<child_tcg>\d+)$')

        # Mark Action count: 1
        p3_6 = re.compile(r'^Mark Action count: (?P<mark_action>\d+)$')

        # Police Action count: 3
        p3_7 = re.compile(r'^Police Action count: (?P<police_action>\d+)$')

        # Queue Action count: 0
        p3_8 = re.compile(r'^Queue Action count: (?P<queue_action>\d+)$')

        # No of TCCGs: 4
        p3_9 = re.compile(r'^No of TCCGs: (?P<no_of_tccg>\d+)$')

        #  TCCG 0:
        p4 = re.compile(r'^TCCG (?P<tccg>\d+):$')

        # Class-map name: cs5(0x6A651)
        p4_1 = re.compile(r'^Class-map name: (?P<class_map_name>[\w\s\-]+)\((?P<clid>\w+)\)$')

        # Child cgid: 0x0
        p4_2 = re.compile(r'^Child cgid: (?P<child_cgid>\w+)$')

        # Null Bind: True
        p4_3 = re.compile(r'^Null Bind: (?P<null_bind>\w+)$')

        # Action 0
        p4_4 = re.compile(r'^Action (?P<action>\d+)$')

        # Action Type: Marking
        p4_5 = re.compile(r'^Action Type: (?P<action_type>[\w\s]+)$')

        # Marking Method : Normal
        p4_6 = re.compile(r'^Marking Method : (?P<marking_method>[\w\s]+)$')

        # Mark value: 32
        p4_7 = re.compile(r'^Mark value: (?P<mark_value>\d+)$')

        # Mark Type: DSCP
        p4_8 = re.compile(r'^Mark Type: (?P<mark_type>\w+)$')

        # QoS Group: 255
        p4_9 = re.compile(r'^QoS Group: (?P<qos_group>\d+)$')
        
        # Traffic Class: 255
        p4_10 = re.compile(r'^Traffic Class: (?P<traffic_class>\d+)$')

        # Discard Class: 255
        p4_11 = re.compile(r'^Discard Class: (?P<discard_class>\d+)$')

        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()

            # [HundredGigE1/0/5, map1, Ingress]: CGID = 0x738310
            m = p1.match(line)
            if m:
                int_dict = ret_dict.setdefault('interface', {}).setdefault(Common.convert_intf_name(m.groupdict()['interface']), {})
                continue
            
            # cgid: 0x738310
            m = p1_1.match(line)
            if m:
                int_dict.setdefault('cgid', m.groupdict()['cgid'])
                continue

            # No of classes: 4
            m = p1_2.match(line)
            if m:
                int_dict.setdefault('no_of_classes', int(m.groupdict()['no_of_classes']))
                continue

            # TCG ref count: 1
            m = p1_3.match(line)
            if m:
                int_dict.setdefault('tcg_ref_count', int(m.groupdict()['tcg_ref_count']))
                continue
            
            # Filter state: UP TO DATE
            m = p1_4.match(line)
            if m:
                int_dict.setdefault('filter_state', m.groupdict()['filter_state'])
                continue
            
            # VMR state: UP TO DATE
            m = p1_5.match(line)
            if m:
                int_dict.setdefault('vmr_state', m.groupdict()['vmr_state'])
                continue
            
            # Classmap Information
            m = p2.match(line)
            if m:
                classmap_dict = ret_dict.setdefault('classmap', {})
                continue

            # Class name: cs1(cgid: 0x738310, clid: 0x6A611)
            m = p2_1.match(line)
            if m:
                class_dict = classmap_dict.setdefault(m.groupdict()['class_name'], {})
                class_dict['cgid'] = m.groupdict()['cgid']
                class_dict['clid'] = m.groupdict()['clid']
                continue

            # TCCG ref count: 1
            m = p2_2.match(line)
            if m:
                class_dict['tccg_ref_count'] = int(m.groupdict()['tccg_ref_count'])
                continue

            # NULL Bind count: 1
            m = p2_3.match(line)
            if m:
                class_dict['null_bind_count'] = int(m.groupdict()['null_bind_count'])
                continue

            # Class seq no.: 0x1FFFFF
            m = p2_4.match(line)
            if m:
                class_dict['class_seq_number'] = m.groupdict()['class_seq_number']
                continue

            # No of child classes: 0
            m = p2_5.match(line)
            if m:
                class_dict['child_classes'] = int(m.groupdict()['child_classes'])
                continue

            # Filter: FILTER_MATCH_IP_DSCP
            m = p2_6.match(line)
            if m:
                filt_dict = class_dict.setdefault('filter', {}).setdefault(m.groupdict()['filter_name'].lower(), {})
                continue

            # Value: 0x8
            m = p2_7.match(line)
            if m:
                filt_dict['value'] = m.groupdict()['value']
                continue

            # TCG Information
            m = p3.match(line)
            if m:
                tcg_dict = ret_dict.setdefault('tcg', {})
                continue
            
            # NPI TCG Values:
            m = p3_1.match(line)
            if m:
                npi_tcg_dict = tcg_dict.setdefault('npi_tcg', {})
                continue
            
            # Config state: VALID
            m = p3_2.match(line)
            if m:
                npi_tcg_dict['config_state'] = m.groupdict()['config_state']
                continue
            
            # Operational state: IN HARDWARE
            m = p3_3.match(line)
            if m:
                npi_tcg_dict['operational_state'] = m.groupdict()['operational_state']
                continue

            # Parent Info: [0x0, 0x0, 0]
            m = p3_4.match(line)
            if m:
                npi_tcg_dict['parent_info'] = m.groupdict()['parent_info'].split(', ')
                continue

            # No of Child TCGs: 0
            m = p3_5.match(line)
            if m:
                npi_tcg_dict['child_tcg'] = int(m.groupdict()['child_tcg'])
                continue

            # Mark Action count: 1
            m = p3_6.match(line)
            if m:
                npi_tcg_dict['mark_action'] = int(m.groupdict()['mark_action'])
                continue
            
            # Police Action count: 3
            m = p3_7.match(line)
            if m:
                npi_tcg_dict['police_action'] = int(m.groupdict()['police_action'])
                continue

            # Queue Action count: 0
            m = p3_8.match(line)
            if m:
                npi_tcg_dict['queue_action'] = int(m.groupdict()['queue_action'])
                continue        

            # No of TCCGs: 4
            m = p3_9.match(line)
            if m:
                npi_tcg_dict['no_of_tccg'] = int(m.groupdict()['no_of_tccg'])
                continue            

            #  TCCG 0:
            m = p4.match(line)
            if m:
                tccg_dict = tcg_dict.setdefault('tccg', {}).setdefault(m.groupdict()['tccg'], {})
                continue            

            # Class-map name: cs5(0x6A651)
            m = p4_1.match(line)
            if m:
                tccg_dict['class_map_name'] = m.groupdict()['class_map_name']
                tccg_dict['clid'] = m.groupdict()['clid']
                continue             

            # Child cgid: 0x0
            m = p4_2.match(line)
            if m:
                tccg_dict['child_cgid'] = m.groupdict()['child_cgid']
                continue            

            # Null Bind: True
            m = p4_3.match(line)
            if m:
                tccg_dict['null_bind'] = True if m.groupdict()['null_bind'] == 'True' else False
                continue               

            # Action 0
            m = p4_4.match(line)
            if m:
                action_dict = tccg_dict.setdefault('action', {}).setdefault(m.groupdict()['action'], {})
                continue              

            # Action Type: Marking
            m = p4_5.match(line)
            if m:
                action_dict['action_type'] = m.groupdict()['action_type']
                continue            

            # Marking Method : Normal
            m = p4_6.match(line)
            if m:
                action_dict['marking_method'] = m.groupdict()['marking_method']
                continue             

            # Mark value: 32
            m = p4_7.match(line)
            if m:
                action_dict['mark_value'] = int(m.groupdict()['mark_value'])
                continue           

            # Mark Type: DSCP
            m = p4_8.match(line)
            if m:
                action_dict['mark_type'] = m.groupdict()['mark_type']
                continue             

            # QoS Group: 255
            m = p4_9.match(line)
            if m:
                action_dict['qos_group'] = int(m.groupdict()['qos_group'])
                continue             

            # Traffic Class: 255
            m = p4_10.match(line)
            if m:
                action_dict['traffic_class'] = int(m.groupdict()['traffic_class'])
                continue           

            # Discard Class: 255
            m = p4_11.match(line)
            if m:
                action_dict['discard_class'] = int(m.groupdict()['discard_class'])
                continue             

        return ret_dict


class ShowPlatHardFedActiveQosQueueStatsOqMulticastAttachSchema(MetaParser):
    """Schema for show platform hardware fed switch {switch_num} qos queue stats oq multicast attach"""

    schema = {
        'oq_id': {
            Any(): {
                'interface': str,
            },
        },
    }

class ShowPlatHardFedActiveQosQueueStatsOqMulticastAttach(ShowPlatHardFedActiveQosQueueStatsOqMulticastAttachSchema):
    """Parser for show platform hardware fed switch {switch_num} qos queue stats oq multicast attach"""

    cli_command = ['show platform hardware fed active qos queue stats oq multicast attach',
        'show platform hardware fed switch {switch_num} qos queue stats oq multicast attach']

    def cli(self, switch_num=None, output=None):
        if output is None:
            if switch_num:
                cmd = self.cli_command[1].format(switch_num=switch_num)
            else:
                cmd = self.cli_command[0]
            output = self.device.execute(cmd)

        #  HundredGigE1/0/5              6
        p1 = re.compile(r"^(?P<interface>\S+)\s+(?P<oq_id>\d+)$")

        ret_dict = {}

        for line in output.splitlines():
            line = line.strip()
            
            #  HundredGigE1/0/5              6
            m = p1.match(line)
            if m:
                oq_dict = ret_dict.setdefault('oq_id', {}).setdefault(int(m.groupdict()['oq_id']), {})
                oq_dict.setdefault('interface', Common.convert_intf_name(m.groupdict()['interface']))
                continue

        return ret_dict

class ShowPlatformSoftwareFedSecurityFedIpsgIfIdSchema(MetaParser):
    """
        Schema for 
            * show platform software fed {switch} {mode} security-fed ipsg if-id {if_id}
            * show platform software fed {mode} security-fed ipsg if-id {if_id}
    """
    schema = {
        Or('ip', 'mac'): {
            Any(): {
                'handle': int
            }
        }
    }


class ShowPlatformSoftwareFedSecurityFedIpsgIfId(ShowPlatformSoftwareFedSecurityFedIpsgIfIdSchema):
    """
        Parser for 
            * show platform software fed {switch} {mode} security-fed ipsg if-id {if_id}
            * show platform software fed {mode} security-fed ipsg if-id {if_id}
    """

    cli_command = ['show platform software fed {mode} security-fed ipsg if-id {if_id}',
                'show platform software fed {switch} {mode} security-fed ipsg if-id {if_id}']
    
    def cli(self, mode, if_id, switch=None, output=None):
        if output is None:
            if switch:
                cmd = self.cli_command[1].format(switch=switch, mode=mode, if_id=if_id)
            else:
                cmd = self.cli_command[0].format(mode=mode, if_id=if_id)
            
            output = self.device.execute(cmd)
        
        # 10.1.1.1           2056770536     00:11:01:00:00:01    2047852776
        p1 = re.compile(r'^(?P<ip>\S+)\s+(?P<ip_handle>\d+)\s+(?P<mac>\S+)\s+(?P<mac_handle>\d+)$')

        ret_dict = {}
        for line in output.splitlines():
            line = line.strip()

            # 10.1.1.1           2056770536     00:11:01:00:00:01    2047852776
            m = p1.match(line)
            if m:
                group_dict = m.groupdict()
                ip_dict = ret_dict.setdefault('ip', {}).setdefault(group_dict['ip'], {})
                ip_dict['handle'] = int(group_dict['ip_handle'])
                mac_dict = ret_dict.setdefault('mac', {}).setdefault(group_dict['mac'], {})
                mac_dict['handle'] = int(group_dict['mac_handle'])
                continue
        
        return ret_dict


class ShowXfsuStatusSchema(MetaParser):
    """
        Schema for show xfsu status
    """
    schema = {
        Optional('reload_fast_platform_status'): str,
        'graceful_reload_infra_status': str,
        'uptime_before_fast_reload': int,
        'client': {
            Any(): {
                'id': str,
                'status': str
            }
        }
    }


class ShowXfsuStatus(ShowXfsuStatusSchema):
    """
        Parser for show xfsu status
    """
    cli_command = 'show xfsu status'

    def cli(self, output=None):
        if output is None:
            output = self.device.execute(self.cli_command)
        
        # Reload Fast PLATFORM Status: Not started yet
        p1 = re.compile(r'^Reload Fast PLATFORM Status: (?P<reload_fast_platform_status>.+)$')

        # Graceful Reload Infra Status: Started in stacking mode, not running
        p2 = re.compile(r'^Graceful Reload Infra Status: (?P<graceful_reload_infra_status>.+)$')

        # Minimum required system uptime before fast reload can be supported is 5 seconds
        p3 = re.compile(r'^Minimum required system uptime before fast reload can be supported is (?P<uptime_before_fast_reload>\d+) seconds$')
        
        # Client OSPFV3                          : (0x10203004) Status: GR stack none: Up
        # Client OSPF                            : (0x10203003) Status: GR stack none: Up
        # Client IS-IS                           : (0x10203002) Status: GR stack none: Up
        # Client GR_CLIENT_FIB                   : (0x10203001) Status: GR stack none: Up
        # Client GR_CLIENT_RIB                   : (0x10203000) Status: GR stack none: Up
        p4 = re.compile(r'^Client (?P<client>\S+)\s+: \((?P<id>\S+)\) Status: (?P<status>.+)$')

        ret_dict = {}
        for line in output.splitlines():
            line = line.strip()

            # Reload Fast PLATFORM Status: Not started yet
            m = p1.match(line)
            if m:
                ret_dict['reload_fast_platform_status'] = m.groupdict()['reload_fast_platform_status']
                continue
            
            # Graceful Reload Infra Status: Started in stacking mode, not running
            m = p2.match(line)
            if m:
                ret_dict['graceful_reload_infra_status'] = m.groupdict()['graceful_reload_infra_status']
                continue

            # Minimum required system uptime before fast reload can be supported is 5 seconds
            m = p3.match(line)
            if m:
                ret_dict['uptime_before_fast_reload'] = int(m.groupdict()['uptime_before_fast_reload'])
                continue

            # Client OSPFV3                          : (0x10203004) Status: GR stack none: Up
            # Client OSPF                            : (0x10203003) Status: GR stack none: Up
            # Client IS-IS                           : (0x10203002) Status: GR stack none: Up
            # Client GR_CLIENT_FIB                   : (0x10203001) Status: GR stack none: Up
            # Client GR_CLIENT_RIB                   : (0x10203000) Status: GR stack none: Up
            m = p4.match(line)
            if m:
                output_dict = m.groupdict()
                client_dict = ret_dict.setdefault('client', {}).setdefault(output_dict['client'].lower().replace('-', '_'), {})
                client_dict['id'] = output_dict['id']
                client_dict['status'] = output_dict['status']
                continue
        
        return ret_dict


class ShowGracefulReload(ShowXfsuStatus):
    """
        Parser for show graceful-reload
    """

    cli_command = 'show graceful-reload'

    def cli(self, output=None):
        return super().cli(output=output)
